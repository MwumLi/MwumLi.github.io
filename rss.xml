<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
        <title>倘若微小</title>
        <description>倘若微小 - MwumLi</description>
        <link></link>
        <atom:link href="" rel="self" type="application/rss+xml" />
        <lastBuildDate>Sun, 24 Nov 2019 09:34:33 -0600</lastBuildDate>
        <pubDate>Sun, 24 Nov 2019 09:34:33 -0600</pubDate>
        <ttl>60</ttl>


        <item>
                <title>使用 nc 读写 TCP/UDP 连接</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#选项&quot; id=&quot;markdown-toc-选项&quot;&gt;选项&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#使用&quot; id=&quot;markdown-toc-使用&quot;&gt;使用&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#建立原始-tcp-连接&quot; id=&quot;markdown-toc-建立原始-tcp-连接&quot;&gt;建立原始 TCP 连接&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#端口扫描&quot; id=&quot;markdown-toc-端口扫描&quot;&gt;端口扫描&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#发送文件&quot; id=&quot;markdown-toc-发送文件&quot;&gt;发送文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#聊天工具&quot; id=&quot;markdown-toc-聊天工具&quot;&gt;聊天工具&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#连接-memcached&quot; id=&quot;markdown-toc-连接-memcached&quot;&gt;连接 memcached&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#使用代理&quot; id=&quot;markdown-toc-使用代理&quot;&gt;使用代理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#一次性-web-server&quot; id=&quot;markdown-toc-一次性-web-server&quot;&gt;一次性 Web Server&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#文件夹传输&quot; id=&quot;markdown-toc-文件夹传输&quot;&gt;文件夹传输&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#远程克隆磁盘&quot; id=&quot;markdown-toc-远程克隆磁盘&quot;&gt;远程克隆磁盘&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#shell&quot; id=&quot;markdown-toc-shell&quot;&gt;shell&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#反向-shell&quot; id=&quot;markdown-toc-反向-shell&quot;&gt;反向 shell&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nc&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;netcat&lt;/code&gt; 的缩写, 是类 unix 系统下一个功能强大的命令行网络工具, 用来在两台主机之间建立 TCP 或者 UDP 连接, 并通过标准输入输出进行读和写&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nc&lt;/code&gt; 强大之处在于输出是标准输出(&lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;), 输入来自标准输入(&lt;code class=&quot;highlighter-rouge&quot;&gt;stdin&lt;/code&gt;), 以至于可以很容易通过管道和重定向直接使用或被其他程序和脚本调用。正因为它的这种特性, 以至于你能发挥你的想象力用它做很多事情:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;端口扫描: 通过与目的 IP 建立连接, 从而扫描目的IP 的端口是否开放&lt;/li&gt;
  &lt;li&gt;聊天工具: 一边使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;nc&lt;/code&gt; 监听一个端口, 另一边使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;nc&lt;/code&gt; 成功连接这个端口即可互相通信&lt;/li&gt;
  &lt;li&gt;发送文件: 与目的 IP 建立连接, 配合重定向, 源地址读取文件, 目的地址接收文件&lt;/li&gt;
  &lt;li&gt;目录传输: tar 命令和管道的结合&lt;/li&gt;
  &lt;li&gt;远程克隆磁盘: dd 命令和管道的结合&lt;/li&gt;
  &lt;li&gt;配合 ssh config 的 ProxyCommand 命令进行跳板登录  &lt;br /&gt;
…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nc&lt;/code&gt; 有很多变种, &lt;code class=&quot;highlighter-rouge&quot;&gt;ncat&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;pnetcat&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;socat&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;sock&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;socket&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;sbd&lt;/code&gt; 都是指它, 在不同的系统下, 都进行了不同程度的修改, 但是无论怎样, 都可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;nc&lt;/code&gt; 这个名字&lt;/p&gt;

&lt;h2 id=&quot;选项&quot;&gt;选项&lt;/h2&gt;

&lt;p&gt;下面列举的选项并不一定都能使用, 具体根据当前操作系统安装的 &lt;code class=&quot;highlighter-rouge&quot;&gt;nc&lt;/code&gt; 版本有关&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-s source_ip_address&lt;/code&gt;:  指定 &lt;code class=&quot;highlighter-rouge&quot;&gt;nc&lt;/code&gt; 应用与远程主机建立连接的 IP  &lt;br /&gt;
  如果不使用此选项, 默认为使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;0.0.0.0&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-p source_port&lt;/code&gt;: 指定 &lt;code class=&quot;highlighter-rouge&quot;&gt;nc&lt;/code&gt; 应用与远程主机建立连接的源端口  &lt;br /&gt;
如果不指定此选项, 则随机一个可用的端口&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-z&lt;/code&gt;: nc 仅仅扫描指定主机的端口, 而不发送任何数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-w timeout&lt;/code&gt;: 指定与远程主机建立连接成功后超过 timeout 秒自动断开连接  &lt;br /&gt;
如果不使用此选项, 则默认无超时&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-l [ip]:port&lt;/code&gt; : 监听端口 port, 相当于本机启动了一个服务  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ip&lt;/code&gt; 是可选的, 如果不指定, 默认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;0.0.0.0&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-x proxy_address[:port]&lt;/code&gt;: 指定 nc 请求时使用的代理服务  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;port&lt;/code&gt; 是可选的, 如果不指定 port, 则代理服务的 port 为指定代理协议的众所周知的端口: &lt;code class=&quot;highlighter-rouge&quot;&gt;1080&lt;/code&gt;(SOCKS), &lt;code class=&quot;highlighter-rouge&quot;&gt;3128&lt;/code&gt;(HTTPS)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-X proxy_version&lt;/code&gt; - 指定 nc 请求时使用代理服务的协议
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy_version&lt;/code&gt; 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt; : 表示使用的代理为 SOCKS4 代理&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy_version&lt;/code&gt; 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt; : 表示使用的代理为 SOCKS5 代理&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy_version&lt;/code&gt; 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;connect&lt;/code&gt; : 表示使用的代理为 HTTPS 代理&lt;/li&gt;
      &lt;li&gt;如果不指定协议, 则默认使用的代理为 SOCKS5 代理&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-u&lt;/code&gt;: 指定使用的 UDP 协议  &lt;br /&gt;
      如果不使用此选项, 默认为使用 TCP 协议&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-e command&lt;/code&gt; : 执行给出的命令, &lt;code class=&quot;highlighter-rouge&quot;&gt;--exec&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-c command&lt;/code&gt; : 通过 /bin/sh 执行命令 command, &lt;code class=&quot;highlighter-rouge&quot;&gt;--sh-exec&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt; : 打印详细的输出&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;

&lt;h3 id=&quot;建立原始-tcp-连接&quot;&gt;建立原始 TCP 连接&lt;/h3&gt;

&lt;p&gt;与 &lt;code class=&quot;highlighter-rouge&quot;&gt;www.baidu.com&lt;/code&gt; 的 80 端口建立一个 TCP 连接(本地端口随机):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ nc www.baidu.com 80
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用本地 &lt;code class=&quot;highlighter-rouge&quot;&gt;1234&lt;/code&gt; 端口与 &lt;code class=&quot;highlighter-rouge&quot;&gt;www.baidu.com&lt;/code&gt; 的 80 端口建立一个 TCP 连接:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ nc -p 1234 www.baidu.com 80
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;与 &lt;code class=&quot;highlighter-rouge&quot;&gt;www.baidu.com&lt;/code&gt; 的 80 端口建立一个 TCP 连接, 超过 5s 自动断开:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ nc -w 5 www.baidu.com 80
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;与 &lt;code class=&quot;highlighter-rouge&quot;&gt;www.baidu.com&lt;/code&gt; 的 80 端口建立一个 TCP 连接, 并发送请求头, 模拟浏览器访问百度:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ echo `GET / HTTP/1.o\r\n\r\n` | nc -p 21337 www.baidu.com 80
	HTTP/1.1 200 OK
	Date: Sun, 10 Dec 2017 08:28:45 GMT
	Content-Type: text/html
	Content-Length: 14613
	...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面用法相当于:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ nc -p 31337 www.baidu.com 80
 		GET / HTTP/1.0
	(回车)
	(回车)
	HTTP/1.1 200 OK
	Date: Sun, 10 Dec 2017 08:28:45 GMT
	Content-Type: text/html
	Content-Length: 14613
	

	nc -p 31337 -w 5 host.example.com 42
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;与 &lt;code class=&quot;highlighter-rouge&quot;&gt;host.example.com&lt;/code&gt; 的 53 端口建立一个 UDP 连接:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  nc -u host.example.com 53
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;10.1.2.3&lt;/code&gt; 作为本地 IP 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;host.example.com&lt;/code&gt; 的 42 端口建立一个 TCP 连接:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  nc -s 10.1.2.3 host.example.com 42
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;端口扫描&quot;&gt;端口扫描&lt;/h3&gt;

&lt;p&gt;端口扫描经常被系统管理员和黑客用来发现在一些机器上开放的端口，帮助他们识别系统中的漏洞&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;检查 &lt;code class=&quot;highlighter-rouge&quot;&gt;127.0.0.1&lt;/code&gt; 的 TCP 端口 &lt;code class=&quot;highlighter-rouge&quot;&gt;9324-9326&lt;/code&gt; 是否开启&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ nc 127.0.0.1 -z 9320-9330
  Connection to 127.0.0.1 port 9325 [tcp/*] succeeded!
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;可以看到只有 9325 端口是开放的, &lt;code class=&quot;highlighter-rouge&quot;&gt;-z 9320-9330&lt;/code&gt; 指定了扫描的端口范围是 9320 到 9330&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;详细展示 &lt;code class=&quot;highlighter-rouge&quot;&gt;127.0.0.1&lt;/code&gt; 的 TCP 端口 &lt;code class=&quot;highlighter-rouge&quot;&gt;9324-9326&lt;/code&gt; 的开启状况, 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt; 选项:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ nc -v -w 2 127.0.0.1 -z 9324-9326
  nc: connectx to 127.0.0.1 port 9324 (tcp) failed: Connection refused
  found 0 associations
  found 1 connections:
           1: flags=82&amp;lt;CONNECTED,PREFERRED&amp;gt;
                  outif lo0
                  src 127.0.0.1 port 65482
                  dst 127.0.0.1 port 9325
                  rank info not available
                  TCP aux info available

  Connection to 127.0.0.1 port 9325 [tcp/*] succeeded!
  nc: connectx to 127.0.0.1 port 9326 (tcp) failed: Connection refused
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;可以看到发出了三个请求, 只有 9325 端口处于监听状态, 并且显示更为详细的连接成功的请求信息&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;发送文件&quot;&gt;发送文件&lt;/h3&gt;

&lt;p&gt;把 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.11.2&lt;/code&gt; 上的文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;demo.tar.bz2&lt;/code&gt; 发送到 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.11.3&lt;/code&gt;, 并保存为 &lt;code class=&quot;highlighter-rouge&quot;&gt;demo.tar.bz2&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.11.3&lt;/code&gt; 上: &lt;code class=&quot;highlighter-rouge&quot;&gt;nc -l 1234 &amp;gt; demo.tar.bz2&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.11.2&lt;/code&gt; 上: &lt;code class=&quot;highlighter-rouge&quot;&gt;nc 192.168.11.3 1234 &amp;lt; demo.tar.bz2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;聊天工具&quot;&gt;聊天工具&lt;/h3&gt;

&lt;p&gt;通过在 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.11.2&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.11.3&lt;/code&gt; 上建立 TCP 连接来实现聊天:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.11.3&lt;/code&gt; 上: &lt;code class=&quot;highlighter-rouge&quot;&gt;nc -l 1234&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.11.2&lt;/code&gt; 上: &lt;code class=&quot;highlighter-rouge&quot;&gt;nc 192.168.11.2 1234&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样, 双方就可以相互交流了, 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+C&lt;/code&gt; 退出&lt;/p&gt;

&lt;h3 id=&quot;连接-memcached&quot;&gt;连接 memcached&lt;/h3&gt;

&lt;p&gt;连接 &lt;code class=&quot;highlighter-rouge&quot;&gt;memcached&lt;/code&gt; 服务器, 执行命令: 假设 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.11.2&lt;/code&gt; 上启动了一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;memcached&lt;/code&gt;, 并且端口为 &lt;code class=&quot;highlighter-rouge&quot;&gt;11211&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;连接 192.168.11.2 上的 memcached 服务, 并执行 stats 打印 memcached 运行状态:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ echo 'stats' | nc 192.168.11.2 11211
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;充当一个 memecached 客户端, 你可以执行 memcached 的操作指令:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ nc 192.168.11.2 11211
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;使用代理&quot;&gt;使用代理&lt;/h3&gt;

&lt;p&gt;有些网络不能直接访问, 只能通过代理服务才能访问&lt;/p&gt;

&lt;p&gt;通过代理连接 &lt;code class=&quot;highlighter-rouge&quot;&gt;host.example.com&lt;/code&gt; 的 42 端口:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	# 使用 HTTP 代理 http://10.2.3.4:8080 与 host.example.com 的 42 端口连接
	$ nc -x10.2.3.4:8080 -Xconnect host.example.com 42

	# 使用 socks4 代理 socks4://10.2.3.4:8080 连接 host.example.com 的 42 端口
	$ nc -x10.2.3.4:8080 -X4 host.example.com 42

	# 使用 socks5 代理 socks5://10.2.3.4:8080 连接 host.example.com 的 42 端口
	$ nc -x10.2.3.4:8080 -X5 host.example.com 42
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ssh 使用代理: 在 ssh 的配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.ssh/config&lt;/code&gt; 配置选项 &lt;code class=&quot;highlighter-rouge&quot;&gt;ProxyCommand&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	Host web
		HostName    192.168.11.2
		IdentityFile ~/.ssh/id_rsa
		Port        22
		User        root
		ProxyCommand nc -x127.0.0.1:7070 %h %p
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;一次性-web-server&quot;&gt;一次性 Web Server&lt;/h3&gt;

&lt;p&gt;监听 8080 端口, 如果通过 http 访问, 则返回文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt; 的内容, 然后断开:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	{ printf 'HTTP/1.0 200 OK\r\nContent-Length: %d\r\n\r\n' &quot;$(wc -c &amp;lt; file)&quot;; cat file; } | nc -l 8080&quot;&amp;gt;)&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;文件夹传输&quot;&gt;文件夹传输&lt;/h3&gt;

&lt;p&gt;配合 tar 命令和管道, 在两台主机之间传输文件夹内容&lt;/p&gt;

&lt;p&gt;把 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.11.2&lt;/code&gt; 的文件夹 &lt;code class=&quot;highlighter-rouge&quot;&gt;dir&lt;/code&gt; 发往 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.11.3&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在 192.168.11.2 上: &lt;code class=&quot;highlighter-rouge&quot;&gt;tar -cvf - dir | nc -l 1234&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在 192.168.11.3 上: &lt;code class=&quot;highlighter-rouge&quot;&gt;nc 192.168.11.2 1234 | tar xvf -&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用 tar 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;-j&lt;/code&gt; 选项(&lt;code class=&quot;highlighter-rouge&quot;&gt;bzip2&lt;/code&gt;) 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt; 选项(&lt;code class=&quot;highlighter-rouge&quot;&gt;gzip&lt;/code&gt;) 进行数据压缩传输&lt;/p&gt;

&lt;h3 id=&quot;远程克隆磁盘&quot;&gt;远程克隆磁盘&lt;/h3&gt;

&lt;p&gt;配合 dd 命令和管道, 进行远程磁盘读写&lt;/p&gt;

&lt;p&gt;把 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.11.2&lt;/code&gt; 上的 &lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/sda&lt;/code&gt; 克隆到 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.11.3&lt;/code&gt; 上的 &lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/sdb&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在 192.168.11.2 上: &lt;code class=&quot;highlighter-rouge&quot;&gt;dd if=/dev/sda | nc -l 1234&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在 192.168.11.3 上: &lt;code class=&quot;highlighter-rouge&quot;&gt;nc 192.168.11.2 1234 | dd of=/dev/sdb&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;shell&quot;&gt;shell&lt;/h3&gt;

&lt;p&gt;可以打开一个远程主机的 bash, 对远程主机进行操作&lt;/p&gt;

&lt;p&gt;从本地远程打开 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.11.3&lt;/code&gt; 的 shell:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在 192.168.11.3 上: &lt;code class=&quot;highlighter-rouge&quot;&gt;nc -l 1234 -e /bin/bash&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在本地: &lt;code class=&quot;highlighter-rouge&quot;&gt;nc 192.168.11.3 1234&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果不支持 &lt;code class=&quot;highlighter-rouge&quot;&gt;-e&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;-c&lt;/code&gt; 选项, 可以这样做:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在 192.168.11.3 上:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ mkfifo /tmp/tmp_fifo
  $ cat /tmp/tmp_fifo | /bin/sh 2&amp;gt;&amp;amp;1 | nc -l 1234 &amp;gt; /tmp/tmp_fifo
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在本地: &lt;code class=&quot;highlighter-rouge&quot;&gt;nc 192.168.11.3 1234&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;反向-shell&quot;&gt;反向 shell&lt;/h3&gt;

&lt;p&gt;在服务端访问客户端的 shell&lt;/p&gt;

&lt;p&gt;服务器 &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.11.2&lt;/code&gt; 访问本地 shelk:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在服务器上: &lt;code class=&quot;highlighter-rouge&quot;&gt;nc -l 1234&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在本机: &lt;code class=&quot;highlighter-rouge&quot;&gt;nc 192.168.11.2 1234 -e /bin/bash&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>/%E8%AE%B0%E5%BD%95/2017/12/12/netcat-usage/</link>
                <guid>/%E8%AE%B0%E5%BD%95/2017/12/12/netcat-usage</guid>
                <pubDate>Tue, 12 Dec 2017 00:00:00 -0600</pubDate>
        </item>

        <item>
                <title>使用最大余额法计算百分比</title>
                <description>

&lt;p&gt;最大余额法, 英文为 Largest Remainder Method, 又称数额值, 是议会选举中分配议席的一种方法:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;议会选举会提供固定数量的席位(total seats), 而所有的选票除以 total seats 的值就是每一个席位所占有的选票的数目(seat votes); 某政党得票总数除以 seat votes 就是这个政党的得票结果(整数部分+余数部分), 得票结果的整数部分就是该政党首次所获取的席位; 最后将剩下一部分席位尚未分配, 这些席位按照各政党的余数部分的大小按照顺序依次分配 1 个席位, 直至分配完毕,最大余额方法因而得名&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;具体背景介绍请参看维基百科: &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E9%A4%98%E9%A1%8D%E6%B3%95&quot;&gt;最大余额法&lt;/a&gt; 或 &lt;a href=&quot;https://en.wikipedia.org/wiki/Largest_remainder_method&quot;&gt;Largest remainder method&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那最大余额法和我们这里求取百分比有什么关系呢?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般情况下, 我们求取百分比的方法是这样的: &lt;code class=&quot;highlighter-rouge&quot;&gt;part-number/total-number*100%&lt;/code&gt;, 然后遵循四舍五入(或者其他…)的原则保留一定精度, 这样做事没错的, 但是这种方式下算出来所有百分比之和有可能不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;100%&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;而使用最大余额法求取百分比, 求取的所有百分比之后一定是 &lt;code class=&quot;highlighter-rouge&quot;&gt;100%&lt;/code&gt;, 使用文字描述解释起来比较麻烦, 参考下面 Javascript 实现来理解:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
 * 给定一个精度, 计算一组数据中某项数据占据的百分比, 确保所有数据的百分比之和为 1, 即 100%
 *
 * @param  {Array.&amp;lt;number&amp;gt;} valueList a list of all data
 * @param  {number} idx index of the data to be processed in valueList
 * @param  {number} precision integer number showing digits of precision
 * @return {number} percent ranging from 0 to 100
 */
function getPercentWithPrecision(valueList, idx, precision) {
  if (!valueList[idx]) return 0;

  // 计算 valueList 中所有数据项之和
  sum = valueList.reduce(function(acc, val) {
  	return acc + val;
  }, 0);

  if (sum === 0) return 0;

  // 中间值, 用来计算总席位数和扩大比例来保留精度
  var digits = Math.pow(10, precision);

  // 计算每组数据的得票结果(整数部分和余额部分): 整数部分为所得该数据首次分配席位, 余额部分决定首次分配之后剩余席位的分配 
  var votesPerQuota = valueList.map(function(val) {
    // 乘以 digits, 是为了通过扩大比例来保留精度, 这样可以确保正数部分是已经确定的议席位置
    // 乘以 100, 是因为最后返回结果为百分比
    return (val / sum) * digits * 100;
  });

  // 总席位数: 因为所有quota除以sum之和为1, 上一步计算为了保留精度和返回为百分比, 把得票结果扩大了 digits*100 倍, 因此总席位数计算方式如下
  var targetSeats = digits * 100;

  // 首次分配席位
  var seats = votesPerQuota.map(function(votes) {
    return Math.floor(votes); // 整数部分就是每个quota首次分配的席位
  });

  // 当前已经分配出去的席位总数
  var currentSum = seats.reduce(function(acc, val) {
    return acc + val;
  }, 0);

  // 计算每个quota的余额
  var remainder = votesPerQuota.map(function(votes, idx) {
    return votes - seats[idx];
  });

  // 分配剩余席位, 直到所有席位分配完毕
  while (currentSum &amp;lt; targetSeats) {
    var max = Number.NEGATIVE_INFINITY; // 最大余额, 初始重置为无穷小
    var maxId = null; // 余数最大的 id

    // 选出这组余额数据中最大值
    for (var i = 0, len = remainder.length; i &amp;lt; len; ++i) {
      if (remainder[i] &amp;gt; max) {
      	max = remainder[i];
      	maxId = i;
      }
    }

    ++seats[maxId];       // 最大余数对应数据席位 +1
    remainder[maxId] = 0; // 最大余数重置为 0, 保证不会再分配
    ++currentSum;         // 当前已分配席位总数 +1, 保证最终可以退出分配循环
  }

  // idx 对应数据分配的席位除以总席位数就是 idx 在这组数据中保留精度 precision 的百分比
  return seats[idx] / digits;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
                <link>/2017/11/19/percent-with-the-largest-remainder-method/</link>
                <guid>/2017/11/19/percent-with-the-largest-remainder-method</guid>
                <pubDate>Sun, 19 Nov 2017 00:00:00 -0600</pubDate>
        </item>

        <item>
                <title>CRLF 还是 LF</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#crlf-还是-lf&quot; id=&quot;markdown-toc-crlf-还是-lf&quot;&gt;CRLF 还是 LF&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dos-和-unix-的相互转换&quot; id=&quot;markdown-toc-dos-和-unix-的相互转换&quot;&gt;dos 和 unix 的相互转换&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#dos2unix-和-unix2dos&quot; id=&quot;markdown-toc-dos2unix-和-unix2dos&quot;&gt;dos2unix 和 unix2dos&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#使用-nodejs-转换-crlf-和-lf&quot; id=&quot;markdown-toc-使用-nodejs-转换-crlf-和-lf&quot;&gt;使用 nodejs 转换 CRLF 和 LF&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#使用-git-转换-crlf-和-lf&quot; id=&quot;markdown-toc-使用-git-转换-crlf-和-lf&quot;&gt;使用 git 转换 CRLF 和 LF&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Windows 系统和类 UNIX 系统在处理换行符的时候有些差异:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Windows 系统采用回车和换行两个字符来结束一行,即 &lt;code class=&quot;highlighter-rouge&quot;&gt;\r\n&lt;/code&gt; 作为换行, 经常简称为 &lt;code class=&quot;highlighter-rouge&quot;&gt;CRLF&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;类 Unix 系统采用使用换行字符结束一行,即 &lt;code class=&quot;highlighter-rouge&quot;&gt;\n&lt;/code&gt; 作为换行, 经常简称为 &lt;code class=&quot;highlighter-rouge&quot;&gt;LF&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;在过去, Mac OS 使用回车字符结束一行, 即 &lt;code class=&quot;highlighter-rouge&quot;&gt;\r&lt;/code&gt;, 简称为 &lt;code class=&quot;highlighter-rouge&quot;&gt;CR&lt;/code&gt;, 但是现在最新的系统已经采用 &lt;code class=&quot;highlighter-rouge&quot;&gt;LF&lt;/code&gt; 作为换行, 与所有类 UNIX 系统保持一致&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果经常需要在 Windows 和 类 Unix 系统上切换工作或者与其他人在不同系统间协同工作, 这些差异往往就会扰乱你(们)的跨平台协作, 比如在进行读写文件后, 发现文件显示 &lt;code class=&quot;highlighter-rouge&quot;&gt;^M&lt;/code&gt; 这样的字符; 比如 git 提交的时候, 可能在提交记录里面会出现整个文件都被更改的局面…&lt;/p&gt;

&lt;p&gt;以 CRLF 作为换行符的文本文件经常被称作 &lt;strong&gt;DOS 格式文件&lt;/strong&gt;, 而以 LF 作为换行符文本文件, 被称作 &lt;strong&gt;UNIX 格式文件&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;crlf-还是-lf&quot;&gt;CRLF 还是 LF&lt;/h2&gt;

&lt;p&gt;如果进行跨平台的协同工作, 特别是使用 git 进行代码版本管理, 最好统一换行符, &lt;strong&gt;建议使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;LF&lt;/code&gt;(即&lt;code class=&quot;highlighter-rouge&quot;&gt;\n&lt;/code&gt;) 作为换行符&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt; 命令查看 dos 格式文件:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ file dos_utf8_file.txt 
dos_utf8_file.txt: UTF-8 Unicode text, with CRLF line terminators
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt; 命令查看 unix 格式文件:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ file unix_utf8_file.txt
unix_utf8_file.txt: UTF-8 Unicode text
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;dos-和-unix-的相互转换&quot;&gt;dos 和 unix 的相互转换&lt;/h2&gt;

&lt;p&gt;dos 格式文件转换成 Unix 格式文件, 就是把 CRLF 替换为 LF; unix 格式文件转换成 dos 格式文件, 就是把 LF 替换为 CRLF&lt;/p&gt;

&lt;h3 id=&quot;dos2unix-和-unix2dos&quot;&gt;dos2unix 和 unix2dos&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dos2unix&lt;/code&gt;: dos 格式文件转换为 unix 格式文件  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;unix2dos&lt;/code&gt;: unix 格式文件转换为 dos 格式文件&lt;/p&gt;

&lt;p&gt;这是类 UNIX 系统上的两个命令, 如果没有安装, 请先安装&lt;/p&gt;

&lt;h3 id=&quot;使用-nodejs-转换-crlf-和-lf&quot;&gt;使用 nodejs 转换 CRLF 和 LF&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function dos2unix (content) {
  return content.split('\r\n').join('\n');
}

function unix2dos (content) {
  let len = content.length;
  let dos_content = '';
  let lastChar = '', curChar;

  for (let i=0; i&amp;lt;len; i++) {
    curChar = content.charAt(i);

    if (curChar === '\n' &amp;amp;&amp;amp; lastChar !== '\r') {
      dos_content += '\r';
    }
    dos_content += curChar;

    lastChar = curChar;
  }

  return dos_content;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;使用-git-转换-crlf-和-lf&quot;&gt;使用 git 转换 CRLF 和 LF&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;为了保持跨平台一致性, 最好保持行结束符一致, 因此推荐 Windows 设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;autocrlf&lt;/code&gt; 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, 类 UNIX 系统设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;autocrlf&lt;/code&gt; 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;input&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Git 在提交代码时自动地把行结束符 CRLF 转换成 LF, 签出代码时候把行结束符转换为 CRLF:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git config core.autocrlf true
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Git 在提交时把 CRLF 转换成 LF，签出时不转换:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git config core.autocrlf input
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不进行任何转换(默认):&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git config core.autocrlf false
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>/%E8%AE%B0%E5%BD%95/2017/09/16/crlf-or-lf/</link>
                <guid>/%E8%AE%B0%E5%BD%95/2017/09/16/crlf-or-lf</guid>
                <pubDate>Sat, 16 Sep 2017 00:00:00 -0500</pubDate>
        </item>

        <item>
                <title>使用 JavaScript 获取 DOM 元素位置和尺寸</title>
                <description>&lt;p&gt;在一些复杂的页面中, 经常会用 JavaScript 产生一些 DOM 元素的动态效果(滚动到页面某个位置)或者做一些自适应的调整(超出屏幕边缘, 向可视区域调整元素位置)，这个时候我们经常会做一些元素位置和尺寸的计算。浏览器兼容性问题也是不可忽略的一部分，要想写出预想效果的 JavaScript 代码，需要了解一些基本知识。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#涉及-dom-元素定位的属性&quot; id=&quot;markdown-toc-涉及-dom-元素定位的属性&quot;&gt;涉及 DOM 元素定位的属性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#window-对象的尺寸属性&quot; id=&quot;markdown-toc-window-对象的尺寸属性&quot;&gt;window 对象的尺寸属性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#文档坐标和视口坐标&quot; id=&quot;markdown-toc-文档坐标和视口坐标&quot;&gt;文档坐标和视口坐标&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#具体应用&quot; id=&quot;markdown-toc-具体应用&quot;&gt;具体应用&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#得到浏览器窗口的滚动条位置&quot; id=&quot;markdown-toc-得到浏览器窗口的滚动条位置&quot;&gt;得到浏览器窗口的滚动条位置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#视口大小&quot; id=&quot;markdown-toc-视口大小&quot;&gt;视口大小&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#网页大小&quot; id=&quot;markdown-toc-网页大小&quot;&gt;网页大小&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#元素的文档坐标&quot; id=&quot;markdown-toc-元素的文档坐标&quot;&gt;元素的文档坐标&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#元素的视口坐标&quot; id=&quot;markdown-toc-元素的视口坐标&quot;&gt;元素的视口坐标&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;涉及-dom-元素定位的属性&quot;&gt;涉及 DOM 元素定位的属性&lt;/h2&gt;

&lt;p&gt;每个 HTML 元素都有下列属性:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;clientWidth&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;clientHeight&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;clientLeft&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;clientTop&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;offsetWidth&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;offsetHeight&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;offsetLeft&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;offsetTop&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;scrollWidth&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;scrollHeight&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;scrollLeft&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;scrollTop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是具体解释:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;clientHeight 和 clientWidth&lt;/strong&gt;: 用于描述元素内尺寸，是指 &lt;code class=&quot;highlighter-rouge&quot;&gt;元素内容+padding&lt;/code&gt; 大小  &lt;br /&gt;
不包括 border（IE下实际包括、margin 和滚动条部分&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;offsetHeight 和 offsetWidth&lt;/strong&gt;: 用于描述元素外尺寸，是指 &lt;code class=&quot;highlighter-rouge&quot;&gt;元素内容+padding+border&lt;/code&gt;  &lt;br /&gt;
不包括 margin 和滚动条部分&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;clientTop 和 clientLeft&lt;/strong&gt;: 指该元素 border 内外边缘的垂直和水平距离, 即 &lt;code class=&quot;highlighter-rouge&quot;&gt;border-top-width&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;border-left-width&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;offsetTop 和 offsetLeft&lt;/strong&gt;: 指该元素的左上角(&lt;strong&gt;border 外边缘&lt;/strong&gt;) 与已定位的父容器(&lt;strong&gt;offsetParent 对象&lt;/strong&gt;)左上角(&lt;strong&gt;padding 外边缘&lt;/strong&gt;)的距离, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;元素的 margin-top + offsetParent.padding-top&lt;/code&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;元素的 margin-left + offsetParent.padding-left&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;offsetParent&lt;/strong&gt;: 指该元素最近的定位 (&lt;code class=&quot;highlighter-rouge&quot;&gt;relative&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;absolute&lt;/code&gt;) 祖先元素，递归上溯，如果没有祖先元素是定位的话，会返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;scrollWidth和scrollHeigh&lt;/strong&gt; : 是指元素的&lt;code class=&quot;highlighter-rouge&quot;&gt;内容区域 + padding + 溢出尺寸&lt;/code&gt;  &lt;br /&gt;
当内容正好和内容区域匹配, 这时候没有溢出，这些属性与 &lt;code class=&quot;highlighter-rouge&quot;&gt;clientWidth和clientHeight&lt;/code&gt; 相等&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;scrollLeft 和 scrollTop&lt;/strong&gt;: 是指元素滚动条当前所在位置, 是&lt;strong&gt;可写&lt;/strong&gt;的  &lt;br /&gt;
通过给这两个属性赋值, 从而使页面滚动到指定位置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;写了两个 demo 对应理解:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/assets/demos/fe/client-offset-scroll#client-offset-title&quot;&gt;演示 client/offset 相关的几种属性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/assets/demos/fe/client-offset-scroll#scroll-title&quot;&gt;演示 scroll 相关的几种属性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;window-对象的尺寸属性&quot;&gt;window 对象的尺寸属性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;window.innerWidth&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;window.innerHeight&lt;/code&gt;: 浏览器视口的宽(包含垂直滚动条)和高(水平滚动条), 不包含菜单，工具栏等   &lt;br /&gt;
因为不是 W3C 技术规范或推荐规范的一部分, 所以有些浏览器不支持&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;window.outerWidth&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;window.outerHeight&lt;/code&gt;: 浏览器的宽和高, 包含菜单，工具栏等&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;window.pageXOffset&lt;/code&gt;: 浏览器水平滚动条的位置,&lt;code class=&quot;highlighter-rouge&quot;&gt;window.scrollX&lt;/code&gt; 的别名, 但兼容性更好  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;window.pageYOffset&lt;/code&gt;: 浏览器垂直滚动条的位置,&lt;code class=&quot;highlighter-rouge&quot;&gt;window.scrollY&lt;/code&gt; 的别名, 但兼容性更好&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;文档坐标和视口坐标&quot;&gt;文档坐标和视口坐标&lt;/h2&gt;

&lt;p&gt;当我们计算一个 DOM 元素位置也就是坐标的时候，会涉及到两种坐标系: &lt;strong&gt;文档坐标&lt;/strong&gt; 和 &lt;strong&gt;视口坐标&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;浏览器呈现给人眼看到网页的那部分就是视口, 不包含浏览器外壳（菜单，工具栏，状态栏等&lt;/p&gt;

&lt;p&gt;我们经常用到的 &lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt; 就是整个网页，而不仅仅是从视口看到的那部分内容，还包括因为窗口大小限制而出现滚动条的部分，它的左上角就是我们所谓相对于文档坐标的原点&lt;/p&gt;

&lt;p&gt;如果文档小于等于视口, 则不会出现滚动条, 文档左上角和视口左上角相同&lt;/p&gt;

&lt;p&gt;因此, 在两种坐标系之间进行切换, 需要加上或减去滚动的偏移量&lt;/p&gt;

&lt;p&gt;为了在坐标系之间进行转换, 需要判定浏览器窗口的滚动条位置:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; 对象的 &lt;code class=&quot;highlighter-rouge&quot;&gt;pageXoffset&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;pageYoffset&lt;/code&gt; 提供这些值(IE 8 及更早版本除外)&lt;/li&gt;
  &lt;li&gt;如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;window.pageXoffset&lt;/code&gt; 不存在, 那么:
    &lt;ul&gt;
      &lt;li&gt;标准模式下, 获取 &lt;code class=&quot;highlighter-rouge&quot;&gt;document.documentElement&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;scrollTop/scrollLeft&lt;/code&gt;的值来代替&lt;/li&gt;
      &lt;li&gt;怪异模式下, 获取 &lt;code class=&quot;highlighter-rouge&quot;&gt;document.body&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;scrollTop/scrollLeft&lt;/code&gt;的值来代替&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;具体应用&quot;&gt;具体应用&lt;/h2&gt;

&lt;h3 id=&quot;得到浏览器窗口的滚动条位置&quot;&gt;得到浏览器窗口的滚动条位置&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getScrollOffsets(w) {
	var w = w || window;
	if (w.pageXoffset != null) { // &amp;gt; IE8
		return { x: w.pageXoffset, y: pageYoffset };
	}

	var d = w.document.documentElement; // 标准模式
	if (document.compatMode == &quot;BackCompat&quot;) { // 怪异模式
		d = w.document.body;
	}
	return { x: d.scrollLeft, y: d.scrollTop };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;视口大小&quot;&gt;视口大小&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getViewportSize(w) {
	var w = w || window;
	if (w.innerWidth != null) {
			return { width: w.innerWidth, height: w.innerHeight };
	}

	var d = w.document.documentElement; // 标准模式
	if (document.compatMode == &quot;BackCompat&quot;) { // 怪异模式
		d = w.document.body;
	}

	return { width: d.clientWidth, height: d.clientHeight };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;网页大小&quot;&gt;网页大小&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getPageSize(w) {
	var w = w || window;

	var d = w.document.documentElement; // 标准模式
	if (document.compatMode == 'BackCompat') { // 标准模式
		d = w.document.body;
	}

	// 无滚动条时, clientWidth 与 scrollWidth 相同, 但由于不同浏览器处理方式不一致, 因此应该取其中较大值
	return {
		width: Math.max(d.scrollWidth, d.clientWidth),
		height: Math.max(d.scrollHeight, d.clientHeight)
	};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;元素的文档坐标&quot;&gt;元素的文档坐标&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;得到元素的文档坐标, 如果浏览器有滚动条, 可以滚动浏览器到指定元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getElementScrollCoords(element) {
	var actualLeft = element.offsetLeft, actualTop = element.offsetTop;
	var current = element.offsetParent;
	while (current !== null){
		// 注意要加上边界宽度
		actualLeft += (current.offsetLeft + current.clientLeft);
		actualTop += (current.offsetTop + current.clientTop);
		current = current.offsetParent;
	}
	return {x: actualLeft, y: actualTop}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;元素的视口坐标&quot;&gt;元素的视口坐标&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getElementViewportCoords(element) {
	var scrollCoords = getElementScrollCoords(element);
	var scrollOffsets = getScrollOffsets();

	// 视口坐标 = 文档坐标 - 滚动条坐标
	return {
		x: scrollCoords.x - scrollOffsets.x,
		y: scrollCoords.y - scrollOffsets.y
	}
}

// 或者使用 element.getBoundingClientRect()
function getElementViewportCoords(element) {
	var clientRect = element.getBoundingClientRect();
	return {
		x: clientRect.left,
		y: clientRect.top
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
                <link>/%E8%AE%B0%E5%BD%95/2017/08/21/get-dom-coords-size-by-javascript/</link>
                <guid>/%E8%AE%B0%E5%BD%95/2017/08/21/get-dom-coords-size-by-javascript</guid>
                <pubDate>Mon, 21 Aug 2017 00:00:00 -0500</pubDate>
        </item>

        <item>
                <title>浏览器的标准模式和怪异模式</title>
                <description>&lt;p&gt;现代的浏览器一般都有两种渲染模式: 标准模式(Standards mode)和怪异模式(Quirks mode)  &lt;br /&gt;
标准模式下, 浏览器按照 HTML 与 CSS 标准对文档进行解析和渲染; 而在怪异模式下，浏览器则按照旧有的非标准的实现方式对文档进行解析和渲染。&lt;/p&gt;

&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#为什么要做如此区分&quot; id=&quot;markdown-toc-为什么要做如此区分&quot;&gt;为什么要做如此区分?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#浏览器如何确定使用哪种渲染模式&quot; id=&quot;markdown-toc-浏览器如何确定使用哪种渲染模式&quot;&gt;浏览器如何确定使用哪种渲染模式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#判断当前浏览器采用的渲染模式&quot; id=&quot;markdown-toc-判断当前浏览器采用的渲染模式&quot;&gt;判断当前浏览器采用的渲染模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;为什么要做如此区分&quot;&gt;为什么要做如此区分?&lt;/h2&gt;

&lt;p&gt;在 HTML 与 CSS 的标准化未完成之前, 各个浏览器对 HTML 和 CSS 的解析有各自不同的实现, 而有很多旧的网页都是按照这些非标准的实现去设计的。  &lt;br /&gt;
在 HTML 与 CSS 标准确定之后，浏览器一方面要按照标准去实现对 HTML 与 CSS 的支持，另一方面又要保证对非标准的旧网页设计的后向兼容性。  &lt;br /&gt;
因此, 现代的浏览器一般会支持两种渲染模式: 标准模式和怪异模式。&lt;/p&gt;

&lt;h2 id=&quot;浏览器如何确定使用哪种渲染模式&quot;&gt;浏览器如何确定使用哪种渲染模式&lt;/h2&gt;

&lt;p&gt;如果 HTML 文件首部包含文档类型声明 &lt;code class=&quot;highlighter-rouge&quot;&gt;DOCTYPE&lt;/code&gt;, 那么浏览器就会启动标准模式, 按照指定的文档类型标准解析和渲染文档  &lt;br /&gt;
对于没有文档类型声明或者文档类型声明不正确的文档，浏览器就会认为它是一个旧的HTML文档，就会使用怪异模式解析和渲染该文档&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;/code&gt; 是所有可用的 &lt;code class=&quot;highlighter-rouge&quot;&gt;DOCTYPE&lt;/code&gt; 之中最简单的，而且是 HTML5 所推荐的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;判断当前浏览器采用的渲染模式&quot;&gt;判断当前浏览器采用的渲染模式&lt;/h2&gt;

&lt;p&gt;JavaScript 中, &lt;code class=&quot;highlighter-rouge&quot;&gt;document.compatMode&lt;/code&gt; 是用来判断当前浏览器采用的渲染方式  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;document.compatMode&lt;/code&gt; 的值为 &lt;code class=&quot;highlighter-rouge&quot;&gt;CSS1Compat&lt;/code&gt;(标准模式) 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;BackCompat&lt;/code&gt;(怪异模式)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let mode = document.compatMode;
if (mode == 'BackCompat') {
	console.log('当前浏览器正在使用怪异模式渲染当前页面');
}
if (mode == 'CSS1Compat') {
	console.log('当前浏览器正在使用标准模式渲染当前页面');
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参考mdn: &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/compatMode&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/compatMode&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/%E8%AE%B0%E5%BD%95/2017/08/20/browser-standards-quirks-mode/</link>
                <guid>/%E8%AE%B0%E5%BD%95/2017/08/20/browser-standards-quirks-mode</guid>
                <pubDate>Sun, 20 Aug 2017 00:00:00 -0500</pubDate>
        </item>

        <item>
                <title>调整 virtualbox 虚拟机磁盘大小</title>
                <description>

&lt;p&gt;VirtualBox 是一个免费的虚拟化产品, 可以用来构建虚拟机  &lt;br /&gt;
它可以运行各大平台(Mac/Linux/OS) 上, 可以支持现有的绝大部分系统&lt;/p&gt;

&lt;p&gt;VirtualBox 的构建的虚拟机一旦构建完毕, 磁盘的配置就几乎不能更改了, 至少从其界面并没有看到任何可以更改的操作&lt;/p&gt;

&lt;p&gt;但是并不是没有办法, VirtualBox 安装完成之后, 同时还集成安装了 VirtualBox 的一些工具命令&lt;/p&gt;

&lt;p&gt;比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;VBoxManage&lt;/code&gt;, 我们今天用它来解决调整 virtualbox 虚拟机磁盘大小这个问题&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;进入 Virutalbox 存放 VM 的路径,找到你的虚拟机的文件夹并进入  &lt;br /&gt;
快捷方法 : &lt;code class=&quot;highlighter-rouge&quot;&gt;打开 virtualbox -&amp;gt; 右键你要操作的 VM -&amp;gt; 在文件搜索器 Finder 中显示&lt;/code&gt;  &lt;br /&gt;
我这里只是写了 Mac 下的操作内容, 其他平台也相差不多, 就最后一步的右键菜单内容有点不一样, 不过聪明的你一定知道怎么选择&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # 假设我们已经进来, VirtualBox 具体镜像文件夹下的目录内容如下
 $ ls
 Logs                                         docker_default_1462932932793_38985.vbox
 Snapshots                                    docker_default_1462932932793_38985.vbox-prev
 box-disk1.vmdk
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看磁盘文件信息, 记录原来磁盘文件的 uuid&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ VBoxManage showhdinfo box-disk1.vmd
 UUID:           6f5838ee-4319-4885-8eea-6276c9fbbe37
 Parent UUID:    base
 State:          locked write
 Type:           normal (base)
 Location:       /Users/Luo/VirtualBox VMs/docker_default_1462932932793_38985/box-disk1.vmdk
 Storage format: VMDK
 Format variant: dynamic default
 Capacity:       40960 MBytes
 Size on disk:   2795 MBytes
 Encryption:     disabled
 In use by VMs:  docker_default_1462932932793_38985 (UUID: 76746809-f711-4936-915c-49e27195d4f7) 可以看到 old UUID : `6f5838ee-4319-4885-8eea-6276c9fbbe37`  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;克隆 &lt;code class=&quot;highlighter-rouge&quot;&gt;.vmdk&lt;/code&gt; 镜像为一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;.vdi&lt;/code&gt;  镜像&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ VBoxManage clonehd box-disk1.vmdk new-disk1.vdi --format vdi
 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%
 Clone medium created in format 'vdi'. UUID: af5fbd4d-b4f9-4392-b78d-00822b3c32ca
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调整 &lt;code class=&quot;highlighter-rouge&quot;&gt;.vdi&lt;/code&gt; 镜像的大小  &lt;br /&gt;
比如调整为 50G (51200MB)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ VBoxManage modifyhd new-disk.vdi --resize 51200
 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;克隆 &lt;code class=&quot;highlighter-rouge&quot;&gt;.vdi&lt;/code&gt; 镜像为一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;.vmdk&lt;/code&gt; 镜像&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ VBoxManage clonehd new-disk.vdi resized-disk.vmdk --format vmdk
 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%
 Clone medium created in format 'vmdk'. UUID: 362b43f9-f562-49c9-8218-1235be0d16a7 记下 new UUID : `362b43f9-f562-49c9-8218-1235be0d16a7`
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改虚拟机镜像目录下的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.box&lt;/code&gt; 后缀的文件&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;new UUID&lt;/code&gt; 替换所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;old UUID&lt;/code&gt;  &lt;br /&gt;
使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;resized-disk.vmdk&lt;/code&gt; 替换所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;box-disk1.vmdk&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至此, 虚拟机的磁盘大小已经从 40G 调整到 50G  &lt;br /&gt;
(以前的 box-disk1.vmdk 和 中间生成的 new-disk1.vdi 文件你可以清除掉了)&lt;/p&gt;

</description>
                <link>/%E8%AE%B0%E5%BD%95/2016/07/07/modify-hard-size-for-virtualbox/</link>
                <guid>/%E8%AE%B0%E5%BD%95/2016/07/07/modify-hard-size-for-virtualbox</guid>
                <pubDate>Thu, 07 Jul 2016 00:00:00 -0500</pubDate>
        </item>

        <item>
                <title>Docker 的安装与使用</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#what-is-docker&quot; id=&quot;markdown-toc-what-is-docker&quot;&gt;What is Docker?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#安装&quot; id=&quot;markdown-toc-安装&quot;&gt;安装&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#mac-os-x&quot; id=&quot;markdown-toc-mac-os-x&quot;&gt;Mac OS X&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#windows&quot; id=&quot;markdown-toc-windows&quot;&gt;Windows&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#linux&quot; id=&quot;markdown-toc-linux&quot;&gt;Linux&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#非-root-用户使用-docker&quot; id=&quot;markdown-toc-非-root-用户使用-docker&quot;&gt;非 root 用户使用 docker&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#docker-基本命令&quot; id=&quot;markdown-toc-docker-基本命令&quot;&gt;Docker 基本命令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#docker-容器&quot; id=&quot;markdown-toc-docker-容器&quot;&gt;Docker 容器&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#docker-镜像的命令&quot; id=&quot;markdown-toc-docker-镜像的命令&quot;&gt;Docker 镜像的命令&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#构建镜像&quot; id=&quot;markdown-toc-构建镜像&quot;&gt;构建镜像&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#登录-docker-registry&quot; id=&quot;markdown-toc-登录-docker-registry&quot;&gt;登录 Docker Registry&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#docker-commit&quot; id=&quot;markdown-toc-docker-commit&quot;&gt;docker commit&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#docker-build&quot; id=&quot;markdown-toc-docker-build&quot;&gt;docker build&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#构建缓存是什么&quot; id=&quot;markdown-toc-构建缓存是什么&quot;&gt;构建缓存是什么&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dockefile&quot; id=&quot;markdown-toc-dockefile&quot;&gt;Dockefile&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#volume-与数据共享&quot; id=&quot;markdown-toc-volume-与数据共享&quot;&gt;VOLUME 与数据共享&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#容器与宿主机&quot; id=&quot;markdown-toc-容器与宿主机&quot;&gt;容器与宿主机&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#容器之间&quot; id=&quot;markdown-toc-容器之间&quot;&gt;容器之间&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#容器互联&quot; id=&quot;markdown-toc-容器互联&quot;&gt;容器互联&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#docker-局域网&quot; id=&quot;markdown-toc-docker-局域网&quot;&gt;docker 局域网&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#link-互联&quot; id=&quot;markdown-toc-link-互联&quot;&gt;link 互联&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#一些概念&quot; id=&quot;markdown-toc-一些概念&quot;&gt;一些概念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#相关链接&quot; id=&quot;markdown-toc-相关链接&quot;&gt;相关链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;what-is-docker&quot;&gt;What is Docker?&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker 就是容器&lt;/code&gt;(类似虚拟机), 在很多人眼里, Docker 就是这么一个印象  &lt;br /&gt;
在这之前, 我也是这样认为的&lt;/p&gt;

&lt;p&gt;事实上, Docker 不仅仅是容器, 它是一系列 Docker 组件的集合, 包括 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Docker 客户端和服务端&lt;/li&gt;
  &lt;li&gt;Docker 镜像&lt;/li&gt;
  &lt;li&gt;Docker 容器&lt;/li&gt;
  &lt;li&gt;Docker Registry&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://www.docker.com/what-docker&quot; title=&quot;What is Docker?&quot;&gt;官方文档说&lt;/a&gt; :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Docker allows you to package an application with all of its dependencies into a standardized unit for software development.  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;简而言之, Docker 可以打包应用以及相关依赖到一个相对独立的单元( Docker 镜像)&lt;/p&gt;

&lt;p&gt;因此, 我们只需要构建一次 Docker 镜像, 就可以在以后的开发和部署环境中保证一致的应用运行环境  &lt;br /&gt;
从而避免环境不一致引发应用的兼容性错误  &lt;br /&gt;
(前提是宿主机上已经安装了 Docker)&lt;/p&gt;

&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;

&lt;h3 id=&quot;mac-os-x&quot;&gt;Mac OS X&lt;/h3&gt;

&lt;p&gt;Mac OS 下安装见这里: &lt;a href=&quot;https://docs.docker.com/engine/installation/mac/&quot;&gt;https://docs.docker.com/engine/installation/mac/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;windows&quot;&gt;Windows&lt;/h3&gt;

&lt;p&gt;Windows 下安装见这里 : &lt;a href=&quot;https://docs.docker.com/engine/installation/windows/&quot;&gt;https://docs.docker.com/engine/installation/windows/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;linux&quot;&gt;Linux&lt;/h3&gt;

&lt;p&gt;Docker 支持多种 Linux 的发行版本的安装  &lt;br /&gt;
具体见这里 : &lt;a href=&quot;https://docs.docker.com/engine/installation/linux/&quot;&gt;https://docs.docker.com/engine/installation/linux/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;非-root-用户使用-docker&quot;&gt;非 root 用户使用 docker&lt;/h3&gt;

&lt;p&gt;假如你想以非 root 用户的身份使用 docker , 你应该考虑添加你的用户到 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker&lt;/code&gt; 用户组  &lt;br /&gt;
命令如下 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo usermod -aG docker your-user
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;记住 : 只有 log out, 然后 back in 才能使之生效&lt;/p&gt;

&lt;h2 id=&quot;docker-基本命令&quot;&gt;Docker 基本命令&lt;/h2&gt;

&lt;h3 id=&quot;docker-容器&quot;&gt;Docker 容器&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;查看 docker 是否存在&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo docker info
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;返回所有容器和镜像的数量, 以及 docker 所使用的执行驱动和存储驱动&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建和启动容器, 并运行指定命令&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo docker run  ubuntu ls
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker run&lt;/code&gt; 命令首先在本地寻找命令指定的镜像 &lt;code class=&quot;highlighter-rouge&quot;&gt;ubuntu&lt;/code&gt;  &lt;br /&gt;
假如没有找到, 那么会在 Docker 官方维护的 Docker Hub Registry 上寻找,一旦找到镜像, 就会下载该镜像并存储到本地  &lt;br /&gt;
接着, &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run &lt;/code&gt; 会以此镜像为基础, 创建并启动一个容器  &lt;br /&gt;
最后在容器中执行命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;创建一个具有交互 Shell 的容器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo docker run -i -t ubuntu /bin/bash
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-i&lt;/code&gt; 保证容器中 &lt;code class=&quot;highlighter-rouge&quot;&gt;STDIN&lt;/code&gt; 是开启的  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;-t&lt;/code&gt; 告诉 Docker 为创建的容器分配一个伪 tty 终端  &lt;br /&gt;
然后指定运行命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/bash&lt;/code&gt;, 这样新创建的容器才会有一个交互式的 shell&lt;/p&gt;

    &lt;p&gt;如果通过管道与 shell 进行交互,仅仅使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-i&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; echo &quot;Hello,world&quot; | sudo docker run -i ubuntu cat
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为容器指定主机名 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo docker run --rm -h MwumLi ubuntu hostname
 MwumLi
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-h&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;--hostname&lt;/code&gt; 指定容器的主机名&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;端口映射 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # 随机分配宿主机的端口到 docker 指定端口
 # 从宿主机的端口 `49153~65535` 中随机选一个映射到容器的 80 端口  
 $ sudo docker -d -p 80 ubuntu nginx -g &quot;daemon off;&quot;
 
 # 指定容器与宿主机之间的端口映射关系 `-p 宿主端口:容器端口`  
 # 把宿主机的 8080 端口映射到 Docker 容器的 80 端口上  
 $ sudo docker -d -p 8080:80 ubuntu nginx -g &quot;daemon off;&quot;  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt; 指定要暴露的容器端口号, 这个端口号是创建镜像的时候使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;EXPOSE&lt;/code&gt; 指定的端口号(&lt;code class=&quot;highlighter-rouge&quot;&gt;EXPOSE 可以指定多次&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看容器 &lt;code class=&quot;highlighter-rouge&quot;&gt;ps&lt;/code&gt;  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker ps&lt;/code&gt; – 列出当前处于运行状态的 docker container  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;docke ps -l&lt;/code&gt; – 列出最后一次运行的容器(包括正在运行和已停止)  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker ps -a&lt;/code&gt; – 列出所有的容器（包括正在运行和已停止的）  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker ps -n x&lt;/code&gt; – 列出最后 X 个容器(包括运行和停止)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为容器命名 &lt;code class=&quot;highlighter-rouge&quot;&gt;--name&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ docker run --name your-name -i -t ubuntu bash
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;这会创建一个容器名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;your-name&lt;/code&gt; 的容器  &lt;br /&gt;
如果你不使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--name&lt;/code&gt; 指定，它会随机生成一个名字  &lt;br /&gt;
名称必须在当前环境唯一，如果已经存在同名容器，那么会创建失败, 除非删除原有的容器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重新启动已经停止的容器 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo docker start container_name/container_id
 $ sudo docker restart container_name/container_id
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;附着到容器的会话中 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo docker attach container_name/container_id
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;(你可能还需要按下回车键才能进入会话)   &lt;br /&gt;
这个和 &lt;code class=&quot;highlighter-rouge&quot;&gt;tmux attach&lt;/code&gt; 很相似, 都是重新进入之前的会话&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个守护式容器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo docker run -d  --name mwum-daemon ubuntu /bin/sh -c &quot;while true; do echo hello,world!; sleep 1; done&quot;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; 表示后台运行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看容器日志 &lt;code class=&quot;highlighter-rouge&quot;&gt;logs&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker logs container_name/container_id
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;如果想监控 docker 的日志, 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;tail -f&lt;/code&gt; 命令非常相似,按 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+C&lt;/code&gt; 退出日志跟踪&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker logs -f container_name/container_id
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;查看最后 10 行内容 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker logs --tail 10 container_name/container_id
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;始终读取最新 10 行日志 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker logs --tail 10 -f container_name/container_id
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看容器内部的进程 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker top container_name/container_id
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在运行状态的容器内部运行新进程 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 在 docker 容器内部建了个新文件 /etc/new_file
$ sudo docker exec -d container_name/container_id touch /etc/new_file             

# 启动交互式shell
$ sudo docker exec -i -t container_name/container_id bash    
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;停止容器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker stop container_name/container_id        # 发送 SIGTERM 信号
$ sudo docker kill container_name/container_id        # 发送 SIGKILL 信号(快速停止容器)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stop&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt; 都是通过发送信号来实现停止容器  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;kill -s &lt;/code&gt; 指定发送的信号&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自动重启容器 &lt;code class=&quot;highlighter-rouge&quot;&gt;--restart&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 无论容器退出代码是什么，都会一直重启
$ sudo docker run --restart=always -d ubuntu command          
	
# 当容器退出代码为非0时，才会自动重启  
$ sudo docker run --restart=on-failure -d ubuntu command  


# 当容器退出代码为非0时，Docker 会尝试重启该容器, 最多重启 5 次  
$ sudo docker run --restart-on-failure:5 -d ubuntu command 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取某个容器的详细信息 &lt;code class=&quot;highlighter-rouge&quot;&gt;inspect&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker inspect container_name/container_id
$ sudo docker inspect --format='{{ .State.Running }}' container_name/container_id     # 返回是否运行, --format 可用来选择查询
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;一次也可指定多个容器  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;--format&lt;/code&gt; 可以指定打印某一项信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删除容器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 容器必须是停止运行状态
$ sudo docker rm container_name/container_id  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;docker-镜像的命令&quot;&gt;Docker 镜像的命令&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;列出镜像&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo docker images  # 列出所有的镜像  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删除镜像&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo docker rmi image_name/image_id 
 # 删除所有的镜像
 $ sudo docker rmi `docker images -a -q` 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;镜像删除之前, 必须保证没有使用此镜像的容器; 否则, 删除失败&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拉取仓库中的镜像(比如Ubuntu)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # 会把顶级仓库中所有 ubuntu 镜像拉下来
 $ sudo docker pull ubuntu     
 # 会把顶级仓库中 tag 为 12.04 的 ubuntu 镜像拉取下来  
 $ sudo docker pull ubuntu:12.04 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;搜索镜像(仓库名或用户名)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo docker search chef
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看镜像详细情形 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo docker inspect image
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看镜像的构建历史 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo docker history image
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;构建镜像&quot;&gt;构建镜像&lt;/h2&gt;

&lt;p&gt;这里所说的构建镜像不是真正的创建镜像, 而是基于一个已有的基础镜像构建镜像而已  &lt;br /&gt;
如果想从零开始, 那么参考 : &lt;a href=&quot;https://docs.docker.com/engine/userguide/eng-image/baseimages/&quot;&gt;https://docs.docker.com/engine/userguide/eng-image/baseimages/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;两种构建办法 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker commit&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker build&lt;/code&gt; 配合 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt; 文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Docker hub 与 Github 的自动化构建(请自行搜索)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;登录-docker-registry&quot;&gt;登录 Docker Registry&lt;/h3&gt;

&lt;p&gt;对于一般用户来说，我们都会选择使用 Docker 公司提供的 Registry : Docker Hub 来作为我们的远程 docker 仓库  &lt;br /&gt;
因此，需要注册一个 Docker Hub 账户&lt;/p&gt;

&lt;p&gt;命令行登录 Docker Hub : &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo docker login&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;认证信息会保存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.docker/config.json&lt;/code&gt;, 以共后面推送使用&lt;/p&gt;

&lt;p&gt;命令行退出 Docker hub : &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo docker logout&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;docker-commit&quot;&gt;docker commit&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;创建一个具有命令交互式的容器&lt;/li&gt;
  &lt;li&gt;在其中修改某些东西后, 安装新软件、修改配置等, 然后 &lt;code class=&quot;highlighter-rouge&quot;&gt;exit&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把当前已修改容器打包成镜像 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo docker commit container username/repository_name
 # 可以指定一些描述信息 :  
 $ sudo docker commit -m &quot;new custom images&quot; --author=&quot;MwumLi&quot; container username/repository_name
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提交过程暂停容器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ docker commit --pause=false &amp;lt;container_id&amp;gt; .
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在一个运行中的容器中执行提交动作是不被推荐的，这会导致文件处于不一致的状态  &lt;br /&gt;
  现在你可以在提交过程中暂停容器的运行&lt;/p&gt;

&lt;h3 id=&quot;docker-build&quot;&gt;docker build&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker build&lt;/code&gt; 指令需要配合一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt; 文件  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt; 是对一个构建过程的描述, 类似于 &lt;code class=&quot;highlighter-rouge&quot;&gt;Vagrant&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Vagrantfile&lt;/code&gt;  &lt;br /&gt;
只要建立这个文件，再加上要求的基础镜像, 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker build&lt;/code&gt; 命令就可以构建出一个新的镜像&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;新建目录 &lt;code class=&quot;highlighter-rouge&quot;&gt;static_web&lt;/code&gt;,进入目录，新建文件&lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ mkdir static_web &amp;amp;&amp;amp; cd static_web &amp;amp;&amp;amp; touch Dockerfile
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;这个目录会存储你的构建上下文, 构建的时候，Docker 的守护进程就可以访问到这个目录下的文件了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;根据需求, 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockefile&lt;/code&gt; 中写上你的指令  &lt;br /&gt;
Dockefile 指令看目录 : Dockefile&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开始构建 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; static_web $ sudo docker build -t=&quot;username/repository_name:tag&quot; .
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不使用构建缓存 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; static_web $ sudo docker build --no-cache -t=&quot;username/repository_name:tag&quot;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新建 &lt;code class=&quot;highlighter-rouge&quot;&gt;.dockerignore&lt;/code&gt;, 在里面添加不需要发送给 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker daemon&lt;/code&gt; 的文件, 类似于 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt;  &lt;br /&gt;
在构建开始时中,会首先把构建目录下的所有文件发送给 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker daemon&lt;/code&gt;  &lt;br /&gt;
我们可以指定某些文件不用被发送到 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker daemon&lt;/code&gt;, 这样可以加快构建速度&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;构建缓存是什么&quot;&gt;构建缓存是什么&lt;/h4&gt;

&lt;p&gt;构建过程是一步一步的, 每一条指令的执行都会进行一次提交, 这样会形成一系列镜像层&lt;/p&gt;

&lt;p&gt;修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt; 中某条指令后再次构建, 那条指令之前的指令就不需要再次执行&lt;/p&gt;

&lt;p&gt;这就是构建缓存&lt;/p&gt;

&lt;p&gt;构建缓存可以说是加快了我们重新构建镜像的速度&lt;/p&gt;

&lt;h2 id=&quot;dockefile&quot;&gt;Dockefile&lt;/h2&gt;

&lt;p&gt;使用数组方式作为命令的参数的时候，请使用双引号，不要使用单引号&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 指定基础镜像
FROM ubuntu:14.04  
# 触发器
# 当此镜像作为基础镜像构建新镜像的时候,执行下面 ONBUILD 紧跟的 ADD 命令
# 但是构建生成的子镜像作为基础镜像构建新的镜像的时候, 就不在起作用
# 在子镜像构建过程中紧跟 FROM 指令之后执行
ONBUILD ADD . /app/src

# 添加镜像作者以及email等信息
MAINTAINER MwumLi mwumli@hotmail.com

# 添加环境变量 refreshed
ENV refreshed 2016-03-02

# 指定卷  
# 具体见下文 : 数据共享
VOLUME /opt/data

# 指定镜像会以什么样的用户执行
# 有以下 6 种使用方式
# 默认用户为 root
USER user
USER user:group
USER uid
USER uid:gid
USER user:gid
USER uid:group

# ADD 和 COPY 指令用来把构建上下文目录下的东西复制到镜像中  
# 区别在于 ADD 在复制压缩文件时, 会自动解压  

# 指定镜像构建时要运行的命令: 命令会被执行成 `bash -c &quot;apt-get update&quot;`
# 更新了软件源
RUN apt-get update

# 指定构建时要运行的命令: 命令会直接执行 
# 推荐这种方式, 之后的 CMD 指定也推荐这种语法
# 安装 nginx
RUN [&quot;apt-get&quot;, &quot;install&quot;, &quot;nginx&quot;]

# 告诉 Docker 80 端口将会被容器的应用程序所使用
# 可以指定多次来指定多个端口
# 但 Docker 并不会自动打开这些端口, 需要在使用 docker run 的使用 -p 参数来指定      
EXPOSE 80

# 指定容器被启动时要运行命令  
# 如果 `docker run` 并没有指定要运行的命令，那么会运行 CMD 指定的命令
# 如果 `docker run` 指定运行的命令，那么就执行指定的命令，CMD 就会被忽略
# CMD 只能指定一条运行的命令，如果指定多次，以最后一次为准  
# 默认输出 &quot;Welcome, Here is docker&quot;
CMD [&quot;echo&quot;, &quot;Welcome, Here is docker&quot;]

# 指定容器被启动时要运行的执行
# 但这个和 CMD 有点不一样  
# 如果 `docker run` 命令指定运行的命令，指定命令会被添加到把 ENTRYPOINT 所有参数后面执行
# 如果没有指定, 会把 CMD 中指定的参数添加到 ENTRYPOINT 中参数末尾执行
ENTRYPOINT [&quot;echo&quot;, &quot;进入点&quot;]
CMD [&quot;cmd 作为 ENTRYPOINT 参数&quot;]

# 更改工作目录
# WORKDIR 命令之后的命令执行都在这个 WORKDIR 指定目录下
# 包括最终容器的工作目录(不是用户主目录)
# 默认在 `/root` 下
WORKDIR /home
RUN mkdir MwumLi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;volume-与数据共享&quot;&gt;VOLUME 与数据共享&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VOLUME&lt;/code&gt; 是 Dockerfile 中的指令, 用来在 docker 中指定一个卷&lt;/p&gt;

&lt;p&gt;Docker 中的卷类似于虚拟机共享文件夹的概念  &lt;br /&gt;
因此可以通过卷来实现 docker 容器之间, docker 容器与宿主机之间的数据共享&lt;/p&gt;

&lt;h3 id=&quot;容器与宿主机&quot;&gt;容器与宿主机&lt;/h3&gt;

&lt;p&gt;通过指定卷来实现容器与宿主机之间的数据共享&lt;/p&gt;

&lt;p&gt;有两种方式指定卷 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在 Dockerfile 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;VOLUME&lt;/code&gt; 指令 : &lt;code class=&quot;highlighter-rouge&quot;&gt;VOLUME /opt/data&lt;/code&gt;  &lt;br /&gt;
使用此 Dockerfile 构建镜像, 并以此镜像创建的容器, 会自动在宿主机的 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/docker/volumes/&lt;/code&gt; 下新建一个文件夹(文件夹名是一串随机字符串)  &lt;br /&gt;
这个文件夹会被挂载在这个容器的 &lt;code class=&quot;highlighter-rouge&quot;&gt;/opt/data&lt;/code&gt; 下  &lt;br /&gt;
如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;/opt/data&lt;/code&gt; 不存在, 那么会自动创建  &lt;br /&gt;
当使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run --rm&lt;/code&gt; 创建容器的时候, 一旦容器停止, 会自动删除容器及其卷&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;命令行中使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt; 参数&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # 这种方式和 `VOLUME` 指令的效果一样
 $ sudo docker run -it -v /opt/data ubuntu bash

 # 宿主机当前目录下的 `data/` 被挂载到容器 `/opt/data` 下
 $ sudo docker run -it -v $PWD/data:/opt/data ubuntu bash
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;容器之间&quot;&gt;容器之间&lt;/h3&gt;

&lt;p&gt;容器之间只要共享卷, 就可以实现数据共享&lt;/p&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--volumes-from&lt;/code&gt; :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker run -it --volumes-from container debian /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样创建的容器会共享容器 container 的卷, 达到了数据共享的目的&lt;/p&gt;

&lt;h2 id=&quot;容器互联&quot;&gt;容器互联&lt;/h2&gt;

&lt;p&gt;Docker 想要达到的目标是一个容器最好只允许运行一个应用  &lt;br /&gt;
然而目前互联网的应用都是多个应用组合在一起的应用程序栈&lt;/p&gt;

&lt;p&gt;因此，我们需要让每个 docker 容器运行一个单独的应用(比如nginx, mysql, redis 等), 然后通过某种技术实现容器间的互联&lt;/p&gt;

&lt;h3 id=&quot;docker-局域网&quot;&gt;docker 局域网&lt;/h3&gt;

&lt;p&gt;在安装 Docker 时, 会创建一个新的网络接口 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt;  &lt;br /&gt;
每个 docker 容器都会在这个接口上分配一个 ip 地址  &lt;br /&gt;
接口 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt; 是一个虚拟的以太网桥, 用于连接容器和本地宿主网络&lt;/p&gt;

&lt;p&gt;如果进一步查看 Docker 宿主机的其他网络接口, 会发现一系列以 &lt;code class=&quot;highlighter-rouge&quot;&gt;veth*&lt;/code&gt; 接口&lt;/p&gt;

&lt;p&gt;Docker 每创建一个容器就会创建一组互联的网络接口,这组接口就像管道的两端  &lt;br /&gt;
这组接口其中一端作为容器里的 &lt;code class=&quot;highlighter-rouge&quot;&gt;eht0&lt;/code&gt; 接口  &lt;br /&gt;
而另一端命名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;veth*&lt;/code&gt;, 作为宿主机的一个端口  &lt;br /&gt;
这个虚拟网线一端插在名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt; 的网桥上, 另一端插在容器里&lt;/p&gt;

&lt;p&gt;通过把每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;veth*&lt;/code&gt; 接口绑定到 docker0 网桥, Docker 创建了一个虚拟子网  &lt;br /&gt;
这个子网由宿主机和所有的 docker 容器共享&lt;/p&gt;

&lt;h3 id=&quot;link-互联&quot;&gt;link 互联&lt;/h3&gt;

&lt;p&gt;从上面我们可以得到一个结论 : 宿主机和docker 容器组成了一个虚拟子网, 在这个子网内可以互相访问&lt;/p&gt;

&lt;p&gt;那么互联的方案就可以得到 : 直接通过 子网 IP 相互访问&lt;/p&gt;

&lt;p&gt;但是这样存在这么几个问题 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;应用程序需要对容器的 IP 做硬编码&lt;/li&gt;
  &lt;li&gt;如果重启容器, Docker 会改变容器的 IP 地址&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此, 这种方案并不时最好的方案&lt;/p&gt;

&lt;p&gt;docker 提供了一个参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;--link&lt;/code&gt;, 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--link&lt;/code&gt; 实现容器间的互联 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker run --rm -it --name juan  --link redis:db ubuntu:14.04 bash
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样创建的容器与 &lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt; 容器连接起来, &lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt; 被称为子容器, 而新创建的这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;juan&lt;/code&gt; 容器被称为父容器  &lt;br /&gt;
在父容器内部, 会形成这样两个动态更新的信息 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt; 文件, 发现 &lt;code class=&quot;highlighter-rouge&quot;&gt;db&lt;/code&gt;(与命令行 db 对应)对应一个 ip 地址, 即子容器的地址&lt;/li&gt;
  &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;env | grep DB&lt;/code&gt;(DB 与命令行 db 大写对应) 可以看到与子容器相关的ip、端口环境变量&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当被子容器重启，一旦 ip 地址发生变化，会自动更新链接容器中的 host 以及 环境变量&lt;/p&gt;

&lt;p&gt;通过这些信息, 我们就可以实现父子容器之间的通信, 并且避免了硬编码的问题以及 IP 地址改变的问题&lt;/p&gt;

&lt;p&gt;由于安全原因, 可以强制 Docker 只允许有连接的容器之间互相通信  &lt;br /&gt;
需要在启动 Docker 守护进程时加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;--icc=false&lt;/code&gt; 的标志，就会关闭所有没有连接的容器间的通信&lt;/p&gt;

&lt;h2 id=&quot;一些概念&quot;&gt;一些概念&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Docker 是一系列 Docker 组件的集合, 是一个统称&lt;/li&gt;
  &lt;li&gt;Docker 是一个 C/S 架构的程序&lt;/li&gt;
  &lt;li&gt;Docker 服务端 : 一个守护进程, 管理容器以及响应 Docker 客户端的请求&lt;/li&gt;
  &lt;li&gt;Docker 客户端 : 一个命令行工具, 用户通过它与 Docker 服务端交互, 来操纵和查看容器&lt;/li&gt;
  &lt;li&gt;Docker 镜像 : 类似于操作系统镜像, 可以通过多种方式构建&lt;/li&gt;
  &lt;li&gt;Docker 容器 : 类似一个虚拟机, Docker 镜像运行在 Docker 容器中, 形成一个完整的隔离化的应用程序运行环境&lt;/li&gt;
  &lt;li&gt;Docker Registry : 类似于 git 服务器一样的存在, 代码是开源的，你可以搭建自己的私有 Registry&lt;/li&gt;
  &lt;li&gt;Docker Hub : 类似于 Github 一样的存在, 是 Docker 公司搭建的 Docker Registry 服务, 和 Github 一样公共,免费&lt;/li&gt;
  &lt;li&gt;Docker 仓库: 类似于 Github 上的一个个项目一样&lt;/li&gt;
  &lt;li&gt;Docker 仓库下可以有很多镜像 : 类似同一个 Git 项目的不同 Tag 一样, Docker 仓库下的不同镜像是靠 tag 来区分的&lt;/li&gt;
  &lt;li&gt;Docker 用户仓库命名 : &lt;code class=&quot;highlighter-rouge&quot;&gt;username/repository_name&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Docker 顶层仓库 : &lt;code class=&quot;highlighter-rouge&quot;&gt;repository_name&lt;/code&gt;, 只包含仓库名, 顶层仓库是由 Docker 公司和选定的能提供优质基础镜像的厂商管理  &lt;br /&gt;
用户通常基于这些基础镜像构建自己的镜像  &lt;br /&gt;
同时顶层仓库也代表个厂商和 docker 公司的一种承诺, 即顶层仓库中的镜像是架构良好、安全且最新的&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;某个具体的 Docker 镜像 :  &lt;br /&gt;
用户仓库 : &lt;code class=&quot;highlighter-rouge&quot;&gt;username/repository_name:tag&lt;/code&gt;  &lt;br /&gt;
顶层仓库 : &lt;code class=&quot;highlighter-rouge&quot;&gt;repository_name:tag&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Docker 的镜像的构建和 git 仓库代码提交类似, 同样有 &lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;pull&lt;/code&gt; 等操作，学习过程中可以类比来看&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;相关链接&quot;&gt;相关链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Understand the architecture : &lt;a href=&quot;https://docs.docker.com/engine/understanding-docker/&quot;&gt;https://docs.docker.com/engine/understanding-docker/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Docker 官网 : &lt;a href=&quot;https://www.docker.com/&quot;&gt;https://www.docker.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>/%E8%BD%AF%E4%BB%B6/2016/03/14/docker-install-and-usage/</link>
                <guid>/%E8%BD%AF%E4%BB%B6/2016/03/14/docker-install-and-usage</guid>
                <pubDate>Mon, 14 Mar 2016 00:00:00 -0500</pubDate>
        </item>

        <item>
                <title>clearfix 引发的思考</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#清除浮动&quot; id=&quot;markdown-toc-清除浮动&quot;&gt;清除浮动&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#clear-与块级元素&quot; id=&quot;markdown-toc-clear-与块级元素&quot;&gt;clear 与块级元素&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#避免-collapsing--margins&quot; id=&quot;markdown-toc-避免-collapsing--margins&quot;&gt;避免 Collapsing  margins&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#总结&quot; id=&quot;markdown-toc-总结&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考文档&quot; id=&quot;markdown-toc-参考文档&quot;&gt;参考文档　&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.clearfix:before, 
.clearfix:after {
    content: &quot; &quot;;
    display: table;
}

.clearfix:after {
    clear: both;
}

.clearfix {
    zoom: 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;clearfix&lt;/code&gt; 这个 class 很受前端开发者欢迎  &lt;br /&gt;
主要用它来清除浮动和防止 Collapsing margins (外边距折叠), 且保证跨浏览器的兼容性  &lt;br /&gt;
简述如下 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zoom: 1&lt;/code&gt; : 为了兼容 IE6/7&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:before&lt;/code&gt; : 用来防止 top-margin collapse 和保证当 IE6/7 应用 &lt;code class=&quot;highlighter-rouge&quot;&gt;zoom:1&lt;/code&gt; 时的是视觉一致性&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:after&lt;/code&gt; : 用来清除浮动&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于它的具体讲解可以参考这篇文章 : &lt;a href=&quot;http://nicolasgallagher.com/micro-clearfix-hack/&quot;&gt;http://nicolasgallagher.com/micro-clearfix-hack/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面是我了解 &lt;code class=&quot;highlighter-rouge&quot;&gt;clearfix&lt;/code&gt; 具体作用的一些思考 :&lt;/p&gt;

&lt;h2 id=&quot;清除浮动&quot;&gt;清除浮动&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;float: left&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;float: right&lt;/code&gt; 可以让我们的元素浮动到文档左边和右边  &lt;br /&gt;
因为浮动让元素像漂在水中的叶子一样 “浮” 起来, 脱离标准文档流, 所以不占有原来流空间  &lt;br /&gt;
之后的元素就有可能和浮动元素重叠或完全遮挡消失&lt;/p&gt;

&lt;p&gt;比如，这段代码(没有浮动):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div style=&quot;background: red; width: 150px; height: 80px;&quot;&amp;gt;div1&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;background: green; width: 300px; height: 50px;&quot;&amp;gt;div2&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;background: yellow; width: 100px; height: 100px&quot;&amp;gt;div3&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;background: cyan; width: 250px; height: 60px&quot;&amp;gt;div4&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它的效果是这样的 :  &lt;br /&gt;
&lt;img src=&quot;/assets/imgs/css-clearfix/float-normal.jpg&quot; alt=&quot;float-normal&quot; /&gt;&lt;/p&gt;

&lt;p&gt;给代码增加浮动 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div style=&quot;background: red; width: 150px; height: 80px;&quot;&amp;gt;div1&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;background: green; width: 300px; height: 50px;float: left;&quot;&amp;gt;div2&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;background: yellow; width: 100px; height: 100px&quot;&amp;gt;div3&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;background: cyan; width: 250px; height: 60px&quot;&amp;gt;div4&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;效果是这样的 :  &lt;br /&gt;
&lt;img src=&quot;/assets/imgs/css-clearfix/float-left.jpg&quot; alt=&quot;float-left&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以很明显的看到, div3 的区域被 div2 遮挡住了&lt;/p&gt;

&lt;p&gt;因此, 清除浮动是一件很有必要的事情, 清除浮动方法很多, 可以参考: &lt;a href=&quot;https://segmentfault.com/a/1190000002616482#articleHeader3&quot;&gt;https://segmentfault.com/a/1190000002616482#articleHeader3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里主要讲述一下 &lt;code class=&quot;highlighter-rouge&quot;&gt;clearfix&lt;/code&gt; 中清除浮动的方法 :&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用一个容器元素包含浮动元素, 给容器元素添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;class=&quot;clearfix&quot;&lt;/code&gt;  &lt;br /&gt;
这样主要利用 &lt;code class=&quot;highlighter-rouge&quot;&gt;:after&lt;/code&gt; psudo-element 给容器元素尾部添加一个空的元素  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;display: table&lt;/code&gt; 让其成为一个块级元素  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;clear:both&lt;/code&gt;保证清除前面的浮动  &lt;br /&gt;
只有块级元素的 &lt;code class=&quot;highlighter-rouge&quot;&gt;clear&lt;/code&gt; 属性会生效. 内联元素并不会(事实上，我并没有找到相关资料来证明，只是我实验多次下的结论)  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;zoom:1&lt;/code&gt; 保证跨浏览器的兼容性(IE6/7), 触发 &lt;code class=&quot;highlighter-rouge&quot;&gt;hasLayout&lt;/code&gt; 属性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;clear-与块级元素&quot;&gt;clear 与块级元素&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;为什么上面会把 &lt;code class=&quot;highlighter-rouge&quot;&gt;:after&lt;/code&gt; psudo-elemnt 声明为一个块级元素呢?&lt;/strong&gt;  &lt;br /&gt;
那是因为只有块级元素设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;clear&lt;/code&gt; 才会生效, 而内联元素并不会生效  &lt;br /&gt;
(事实上，我并没有找到相关资料来证明这个结论，但是，我实验多次，发现确实如此)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么这里要使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;display: table&lt;/code&gt;，不使用其他的声明呢(比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt;)?&lt;/strong&gt;  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:before&lt;/code&gt; 中使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;table&lt;/code&gt; 把其声明为一个 BFC, 而 &lt;code class=&quot;highlighter-rouge&quot;&gt;table&lt;/code&gt; 有能力表示这个元素为一个块级元素  &lt;br /&gt;
所以可能考虑到共用代码, 所以 &lt;code class=&quot;highlighter-rouge&quot;&gt;:after&lt;/code&gt; 中也是用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;display: table&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;避免-collapsing--margins&quot;&gt;避免 Collapsing  margins&lt;/h2&gt;

&lt;p&gt;有两种情况会引起 Collapsing margin :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;父子元素(不一定是直接父子) 之间会发生 margin-top 和 margin-bottom 的折叠  &lt;br /&gt;
(如果之间没有 &lt;code class=&quot;highlighter-rouge&quot;&gt;border、padding、inlne-content、height、min-height、max-height&lt;/code&gt; 分割的话)  &lt;br /&gt;
这篇讨论 &lt;a href=&quot;http://stackoverflow.com/questions/9519841/why-does-this-css-margin-top-style-not-work&quot;&gt;http://stackoverflow.com/questions/9519841/why-does-this-css-margin-top-style-not-work&lt;/a&gt; 很好的演示了这点&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;邻近元素同时设置 margin, 前面的 margin-bottom 和 后面的 margin-top 融合取最大的&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;clearfix&lt;/code&gt; 是这么做的 :&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;父子的话, 给父元素添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;.clearfix&lt;/code&gt;; 紧邻的话，给前一个元素添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;.clearfix&lt;/code&gt;  &lt;br /&gt;
这样主要利用 :before psudo-element 给元素内部前面添加一个空的元素  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;display: table&lt;/code&gt; 保证它是一个 BFC(BFC 可以隔断外边距折叠)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;:before&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;:after&lt;/code&gt; 最大的好处应该是避免添加 HTML 代码到我们的代码, 破坏代码的整体感&lt;/p&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;clearfix&lt;/code&gt; 的时候, 有的时候不仅仅是为了清除浮动带来的影响，还有防止 Collapsing margins  &lt;br /&gt;
因此，当你发现布局不对的时候，可以试一试&lt;/p&gt;

&lt;p&gt;当然, 在使用前, 请确定 &lt;code class=&quot;highlighter-rouge&quot;&gt;clearfix&lt;/code&gt; 和本文章首部的内容一致&lt;/p&gt;

&lt;h2 id=&quot;参考文档&quot;&gt;参考文档　&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhongxinWang/archive/2013/03/27/2984764.html&quot;&gt;http://www.cnblogs.com/zhongxinWang/archive/2013/03/27/2984764.html&lt;/a&gt;  &lt;br /&gt;
这篇文章主要讲了浮动的影响, 图文并茂, 但是没有 code, 但是对于初学者理解浮动的影响有很大帮助&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000002616482#articleHeader3&quot;&gt;https://segmentfault.com/a/1190000002616482#articleHeader3&lt;/a&gt;  &lt;br /&gt;
这篇文章主要讨论了清除浮动, 还算完全&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://nicolasgallagher.com/micro-clearfix-hack/&quot;&gt;http://nicolasgallagher.com/micro-clearfix-hack/&lt;/a&gt;  &lt;br /&gt;
这是 clearfix 的起源, 分析了 clearfix 的原理&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html&quot;&gt;http://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html&lt;/a&gt;  &lt;br /&gt;
  这里讲了BFC，生成一个 BFC 以及 BFC 的使用,图文并茂, 有 code&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/9519841/why-does-this-css-margin-top-style-not-work&quot;&gt;http://stackoverflow.com/questions/9519841/why-does-this-css-margin-top-style-not-work&lt;/a&gt;  &lt;br /&gt;
这里面讨论了 margin-top 与父元素的 margin-top 的折叠的危害以及解决，一个很好的例子　&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.w3.org/TR/CSS21/box.html#collapsing-margins&quot;&gt;http://www.w3.org/TR/CSS21/box.html#collapsing-margins&lt;/a&gt;  &lt;br /&gt;
英文官方文档, 讲述 collapsing margin 引发的情况&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin_collapsing&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin_collapsing&lt;/a&gt;  &lt;br /&gt;
mdn 上的文章, 讲述 collapsing margin, 中文&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>/%E5%89%8D%E7%AB%AF/2015/12/24/css-clearfix/</link>
                <guid>/%E5%89%8D%E7%AB%AF/2015/12/24/css-clearfix</guid>
                <pubDate>Thu, 24 Dec 2015 00:00:00 -0600</pubDate>
        </item>

        <item>
                <title>使用 Selenium with Python 进行 web 自动化测试</title>
                <description>

&lt;p&gt;见这篇文章 : &lt;a href=&quot;https://www.zybuluo.com/mwumli/note/222253&quot;&gt;使用 Selenium with Python 进行 web 自动化测试&lt;/a&gt;&lt;/p&gt;
</description>
                <link>/2015/11/19/automated-test-by-selenium/</link>
                <guid>/2015/11/19/automated-test-by-selenium</guid>
                <pubDate>Thu, 19 Nov 2015 00:00:00 -0600</pubDate>
        </item>

        <item>
                <title>Ubuntu 下搭建 go 运行环境</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#二进制安装-go&quot; id=&quot;markdown-toc-二进制安装-go&quot;&gt;二进制安装 Go&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#升级-go&quot; id=&quot;markdown-toc-升级-go&quot;&gt;升级 Go&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#卸载-go&quot; id=&quot;markdown-toc-卸载-go&quot;&gt;卸载 Go&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#go-语言版的-helloworld&quot; id=&quot;markdown-toc-go-语言版的-helloworld&quot;&gt;go 语言版的 HelloWorld&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考链接&quot; id=&quot;markdown-toc-参考链接&quot;&gt;参考链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里介绍一下如何搭建 go 语言的编译运行环境以及一个初始 Hello 程序&lt;/p&gt;

&lt;p&gt;Go 有两种构建方式 : 源码安装和二进制安装&lt;/p&gt;

&lt;p&gt;二进制安装比较简单, 这里主要讲述二进制安装&lt;/p&gt;

&lt;h2 id=&quot;二进制安装-go&quot;&gt;二进制安装 Go&lt;/h2&gt;

&lt;p&gt;下载适合你系统的 Go : &lt;a href=&quot;https://golang.org/dl/#featured&quot;&gt;https://golang.org/dl/#featured&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Go 的二进制的会默认假定安装到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/go/&lt;/code&gt; 中&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果你 &lt;strong&gt;安装 Go 到默认位置&lt;/strong&gt; , 那么你需要这样做 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz
 $ echo &quot;export PATH=$PATH:/usr/local/go/bin&quot; &amp;gt;&amp;gt; ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你需要 &lt;strong&gt;安装 Go 到指定位置&lt;/strong&gt; (Eg: &lt;code class=&quot;highlighter-rouge&quot;&gt;~/go/&lt;/code&gt;), 那么这样做 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ tar -C ~/ -xzf go$VERSION.$OS-$ARCH.tar.gz
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;然后在 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.bashrc&lt;/code&gt; 末尾添加 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; export GOROOT=$HOME/go
 export PATH=$PATH:$GOROOT/bin
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;GOROOT&lt;/code&gt; 仅仅在安装 go 到指定位置的时候才需要设置&lt;/p&gt;

&lt;p&gt;只要你的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt; 生效, 那么你可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;go version&lt;/code&gt; 打印当前 go 的版本号来确定是否安装成功&lt;/p&gt;

&lt;h2 id=&quot;升级-go&quot;&gt;升级 Go&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;必须卸载已存在的旧的版本&lt;/li&gt;
  &lt;li&gt;按照上述方法安装新的 Go&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;卸载-go&quot;&gt;卸载 Go&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;删除 go 安装目录, 默认 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/go/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在 shell 配置文件中去掉 Go 环境变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;GOROOT&lt;/code&gt; 以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt; 中 go 路径的配置&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;go-语言版的-helloworld&quot;&gt;go 语言版的 HelloWorld&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hello.go&lt;/code&gt; :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello, Wolrd. 你好, 世界.&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后命令行中直接运行 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ go run hello.go
Hello,World. 你好, 世界!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;go run&lt;/code&gt; 包含编译和运行两步&lt;/p&gt;

&lt;p&gt;你可以先生成可执行文件, 然后执行可执行文件, 比如这样 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ go build hello.go
$ ls
hello hello.go
$ ./hello
Hello,World. 你好, 世界!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://docscn.studygolang.com/doc/install&quot;&gt;Go 的安装起步&lt;/a&gt;  &lt;br /&gt;
这里有各种系统下 Go 的安装与配置&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://docscn.studygolang.com/doc/code.html&quot;&gt;如何使用 Go 编程&lt;/a&gt;  &lt;br /&gt;
在这里你可以看到一个简单 Go 包的开发  &lt;br /&gt;
并介绍用 go 工具来获取、 构建并安装 Go 包及命令的标准方式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://docscn.studygolang.com/&quot;&gt;Go 语言中文官方文档&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://docs.studygolang.com/&quot;&gt;Go 语言英文官方文档&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://studygolang.com/&quot;&gt;Go 语言中文网&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
                <link>/%E6%90%AD%E5%BB%BA/2015/11/10/run-go-in-ubuntu/</link>
                <guid>/%E6%90%AD%E5%BB%BA/2015/11/10/run-go-in-ubuntu</guid>
                <pubDate>Tue, 10 Nov 2015 00:00:00 -0600</pubDate>
        </item>

        <item>
                <title>Sublime Text 安装与配置的那些事</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#简介&quot; id=&quot;markdown-toc-简介&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#安装&quot; id=&quot;markdown-toc-安装&quot;&gt;安装&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#sublime-text-2&quot; id=&quot;markdown-toc-sublime-text-2&quot;&gt;Sublime Text 2&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#sublime-text-3&quot; id=&quot;markdown-toc-sublime-text-3&quot;&gt;Sublime Text 3&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#系统配置&quot; id=&quot;markdown-toc-系统配置&quot;&gt;系统配置&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#中文输入和搜索&quot; id=&quot;markdown-toc-中文输入和搜索&quot;&gt;中文输入和搜索&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#固化在左侧的-dock-里&quot; id=&quot;markdown-toc-固化在左侧的-dock-里&quot;&gt;固化在左侧的 dock 里&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#设置默认打开文档&quot; id=&quot;markdown-toc-设置默认打开文档&quot;&gt;设置默认打开文档&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#注册&quot; id=&quot;markdown-toc-注册&quot;&gt;注册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.sublimetext.com/&quot;&gt;Sublime Text&lt;/a&gt; 是一个很好用的编辑器, 无论对于编程还是文本编辑, 都非常不错&lt;/p&gt;

&lt;p&gt;它小巧且速度非常快，支持 &lt;code class=&quot;highlighter-rouge&quot;&gt;Win/Mac/Linux&lt;/code&gt; 等多种平台  &lt;br /&gt;
也同时支持 32 位与 64 位&lt;/p&gt;

&lt;p&gt;它支持各种流行编程语言的语法高亮、代码补全&lt;/p&gt;

&lt;p&gt;它可以像 vim 一样安装插件，增强本身没有的功能，而且有比 Vim 更方便的插件浏览、安装和管理方式    &lt;br /&gt;
只需要一两个命令，就可以方便下载，等待使用&lt;/p&gt;

&lt;p&gt;它收费, 但是它提供免费使用，当然无限期，无限制，只是偶尔提醒你木有购买，而且频率很低，这点让人觉得很赞&lt;/p&gt;

&lt;p&gt;好的软件, 总是要付出软件创作者的巨大的心力, 如果你有足够的金子, 不妨买一个 &lt;a href=&quot;http://www.sublimetext.com/buy&quot;&gt;key&lt;/a&gt; 赞助一下&lt;/p&gt;

&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;

&lt;p&gt;Sublimex Text 目前有两个版本 2 和 3, 2 应该属于 LTS(Long Term Support),而 3 是 beta, 不过也算稳定&lt;/p&gt;

&lt;p&gt;至于安装哪个, 取决于你的选择&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下载地址&lt;/strong&gt; :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Sublime Text 2 : &lt;a href=&quot;http://www.sublimetext.com/2&quot;&gt;http://www.sublimetext.com/2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Sulimex Text 3 : &lt;a href=&quot;http://www.sublimetext.com/3&quot;&gt;http://www.sublimetext.com/3&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里只写 Ubuntu 下的安装与配置&lt;/p&gt;

&lt;h3 id=&quot;sublime-text-2&quot;&gt;Sublime Text 2&lt;/h3&gt;

&lt;p&gt;两种安装方式 :  源安装 和 下载压缩包&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;源安装&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo add-apt-repository ppa:webupd8team/sublime-text-2  
$ sudo apt-get update  
$ sudo apt-get install sublime-text
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;压缩包安装&lt;/strong&gt; :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下载 Sublime text 2 : &lt;a href=&quot;http://www.sublimetext.com/2&quot;&gt;http://www.sublimetext.com/2&lt;/a&gt;  &lt;br /&gt;
(提供的是一个压缩包, 暂且命名为 Sublime-Text-2.0.2-x64.tar.bz2)&lt;/li&gt;
  &lt;li&gt;解压缩到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/opt&lt;/code&gt; 下 : &lt;code class=&quot;highlighter-rouge&quot;&gt;tar -xjvf Sublime-Text-2.0.2-x64.tar.bz2 -C /opt&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;建立软链接到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/bin&lt;/code&gt; 下 : &lt;code class=&quot;highlighter-rouge&quot;&gt;ln -s /opt/Sublime_Text_2 /usr/bin/subl&lt;/code&gt;  &lt;br /&gt;
(建立在 PATH 变量任意路径下都可以)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;sublime-text-3&quot;&gt;Sublime Text 3&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载 Sublime Text 3: &lt;a href=&quot;http://www.sublimetext.com/3&quot;&gt;http://www.sublimetext.com/3&lt;/a&gt;  &lt;br /&gt;
(提供的是一个 deb 文件, 暂且命名为为 sublime-text_build-3083_amd64.deb)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;命令安装 : &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo dpkg -i sublime-text_build-3083_amd64.deb&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果出现依赖错误, 可以执行 : &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get install -f&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;系统配置&quot;&gt;系统配置&lt;/h2&gt;

&lt;p&gt;在 Linux , 要想正常使用 Sublime, 你需要做些系统相关的配置&lt;/p&gt;

&lt;h3 id=&quot;中文输入和搜索&quot;&gt;中文输入和搜索&lt;/h3&gt;

&lt;p&gt;Ubuntu 下, Sublimex Text 不能输入中文, 这个网上已经给出解决方案&lt;/p&gt;

&lt;p&gt;通过压缩包方式安装 Sublime, 在应用程序搜索中, 不会搜索到 Sublime  &lt;br /&gt;
(按下 Window 键, 就唤起了应用程序搜索面板)&lt;/p&gt;

&lt;p&gt;解决方法如下 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;新建文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;sublime-imfix.c&lt;/code&gt; :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; /*
    
  * sublime-imfix.c Use LD_PRELOAD to interpose some function to fix sublime
  * input method support for linux. By Cjacker Huang &amp;lt;jianzhong.huang at
  * i-soft.com.cn&amp;gt;
  * 
  * gcc -shared -o libsublime-imfix.so sublime_imfix.c `pkg-config --libs
  * --cflags gtk+-2.0` -fPIC LD_PRELOAD=./libsublime-imfix.so sublime_text 
    
  */
    
 #include &amp;lt;gtk/gtk.h&amp;gt;        
 #include &amp;lt;gdk/gdkx.h&amp;gt;
    
 typedef GdkSegment GdkRegionBox;        
    
    
 struct _GdkRegion {
     long            size;
     long            numRects;
     GdkRegionBox   *rects;
     GdkRegionBox    extents;
 };      
 GtkIMContext   *local_context;      
    
 void gdk_region_get_clipbox(const GdkRegion * region, GdkRectangle * rectangle)
 {
    
     g_return_if_fail(region != NULL);
     g_return_if_fail(rectangle != NULL);        
        

     rectangle-&amp;gt;x = region-&amp;gt;extents.x1;
     rectangle-&amp;gt;y = region-&amp;gt;extents.y1;
     rectangle-&amp;gt;width = region-&amp;gt;extents.x2 - region-&amp;gt;extents.x1;
     rectangle-&amp;gt;height = region-&amp;gt;extents.y2 - region-&amp;gt;extents.y1;
     GdkRectangle    rect;       
        

     rect.x = rectangle-&amp;gt;x;
     rect.y = rectangle-&amp;gt;y;
     rect.width = 0;
     rect.height = rectangle-&amp;gt;height;
    
     // The caret width is 2;
     // Maybe sometimes we will make a mistake, but for most of the time, it
     // should be the caret.
     if (rectangle-&amp;gt;width == 2 &amp;amp;&amp;amp; GTK_IS_IM_CONTEXT(local_context)) {
         gtk_im_context_set_cursor_location(local_context, rectangle);
     }
 }       
    
    
 // this is needed, for example, if you input something in file dialog and
 // return back the edit area
 // context will lost, so here we set it again.      
    
    
 static GdkFilterReturn event_filter(GdkXEvent * xevent, GdkEvent * event,
                                     gpointer im_context)
 {
     XEvent         *xev = (XEvent *) xevent;        

     if (xev-&amp;gt;type == KeyRelease &amp;amp;&amp;amp; GTK_IS_IM_CONTEXT(im_context)) {

         GdkWindow      *win = g_object_get_data(G_OBJECT(im_context), &quot;window&quot;);        
    
         if (GDK_IS_WINDOW(win))
             gtk_im_context_set_client_window(im_context, win);
    
     }
    
     return GDK_FILTER_CONTINUE;
 }       
    
    
 void gtk_im_context_set_client_window(GtkIMContext * context,
                                       GdkWindow * window)
 {
    
     GtkIMContextClass *klass;       
    
     g_return_if_fail(GTK_IS_IM_CONTEXT(context));
     klass = GTK_IM_CONTEXT_GET_CLASS(context);
    
     if (klass-&amp;gt;set_client_window)
         klass-&amp;gt;set_client_window(context, window);      
            
     if (!GDK_IS_WINDOW(window))
         return;
    
     g_object_set_data(G_OBJECT(context), &quot;window&quot;, window);

     int             width = gdk_window_get_width(window);
     int             height = gdk_window_get_height(window);     
    
     if (width != 0 &amp;amp;&amp;amp; height != 0) {
    
         gtk_im_context_focus_in(context);
         local_context = context;
     }
    
     gdk_window_add_filter(window, event_filter, context);
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装编译环境 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; sudo apt-ger install build-essential libgtk2.0-dev -y
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编译共享库 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; gcc -shared -o libsublime-imfix.so sublime-imfix.c  `pkg-config --libs --cflags gtk+-2.0` -fPIC
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;移动共享库到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/&lt;/code&gt; 下 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; sudo mv libsublime-imfix.so /usr/lib/
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试一下是否能输入中文 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; LD_PRELOAD=./libsublime-imfix.so subl
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;命令行启动，自动使用共享库 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; echo &quot;LD_PRELOAD=/usr/lib/libsublime-imfix.so subl&quot; &amp;gt;&amp;gt; ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加应用程序菜单,自动使用共享库 :  &lt;br /&gt;
新建 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/share/applications/sublime_text.desktop&lt;/code&gt;, 内容如下 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [Desktop Entry]
 Version=1.0
 Type=Application
 Name=Sublime Text
 GenericName=Text Editor
 Comment=Sophisticated text editor for code, markup and prose
 Exec=bash -c 'LD_PRELOAD=/usr/lib/libsublime-imfix.so /opt/sublime_text/sublime_text %F'
 Terminal=false
 MimeType=text/plain;
 Icon=sublime-text
 Categories=TextEditor;Development;
 StartupNotify=true
 Actions=Window;Document;

 [Desktop Action Window]
 Name=New Window
 Exec=bash -c 'LD_PRELOAD=/usr/lib/libsublime-imfix.so /opt/sublime_text/sublime_text -n'
 OnlyShowIn=Unity;

 [Desktop Action Document]
 Name=New File
 Exec=bash -c 'LD_PRELOAD=/usr/lib/libsublime-imfix.so /opt/sublime_text/sublime_text --command new_file'
 OnlyShowIn=Unity;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;重启或注销生效&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;固化在左侧的-dock-里&quot;&gt;固化在左侧的 dock 里&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;通过命令行或者应用程序菜单启动 Sublime&lt;/li&gt;
  &lt;li&gt;在 dock 里会出现 Sublime 的图标, 点击右键，选择&lt;code class=&quot;highlighter-rouge&quot;&gt;lock from Launcher&lt;/code&gt;,然后它就被锁定在 dock 中了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以后你就可以直接可以从 dock 中打开 Sublime&lt;/p&gt;

&lt;h3 id=&quot;设置默认打开文档&quot;&gt;设置默认打开文档&lt;/h3&gt;

&lt;p&gt;希望使用 sublime 成为某种特定文档的默认打开方式, 可以这样做 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;右键文件，选择&lt;code class=&quot;highlighter-rouge&quot;&gt;Propertites&lt;/code&gt;（属性）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点击&lt;code class=&quot;highlighter-rouge&quot;&gt;Open With&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Default Application&lt;/code&gt; 下选择&lt;code class=&quot;highlighter-rouge&quot;&gt;Sublime Text&lt;/code&gt;, 点击 &lt;code class=&quot;highlighter-rouge&quot;&gt;Set as default&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样，你双击打开每一个这种类型的文件，都会自动用&lt;code class=&quot;highlighter-rouge&quot;&gt;Sublime Text&lt;/code&gt;打开&lt;/p&gt;

&lt;h2 id=&quot;注册&quot;&gt;注册&lt;/h2&gt;

&lt;p&gt;虽然可以一直免费使用，但是弹出来的警告框总是令人很不爽  &lt;br /&gt;
有幸在网络上搜集到一枚 Sublimex Text 2 的注册码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;----- BEGIN LICENSE -----
Andrew Weber
Single User License
EA7E-855605
813A03DD 5E4AD9E6 6C0EEB94 BC99798F
942194A6 02396E98 E62C9979 4BB979FE
91424C9D A45400BF F6747D88 2FB88078
90F5CC94 1CDC92DC 8457107A F151657B
1D22E383 A997F016 42397640 33F41CFC
E1D0AE85 A0BBD039 0E9C8D55 E1B89D5D
5CDB7036 E56DE1C0 EFCC0840 650CD3A6
B98FC99C 8FAC73EE D2B95564 DF450523
------ END LICENSE ------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不过，若是大家手头方便的话，不妨支持一下&lt;a href=&quot;http://www.sublimetext.com/buy&quot;&gt;正版&lt;/a&gt;，毕竟辛辛苦苦做一个软件不容易，何况还是这么好的软件(将来可能会更好)&lt;/p&gt;

</description>
                <link>/%E8%BD%AF%E4%BB%B6/2015/11/06/sublime-text-such-things/</link>
                <guid>/%E8%BD%AF%E4%BB%B6/2015/11/06/sublime-text-such-things</guid>
                <pubDate>Fri, 06 Nov 2015 00:00:00 -0600</pubDate>
        </item>

        <item>
                <title>Ubuntu 下安装 nodejs</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ubuntu-下的安装&quot; id=&quot;markdown-toc-ubuntu-下的安装&quot;&gt;Ubuntu 下的安装&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#源安装&quot; id=&quot;markdown-toc-源安装&quot;&gt;源安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#node-version-manager&quot; id=&quot;markdown-toc-node-version-manager&quot;&gt;Node Version Manager&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#安装&quot; id=&quot;markdown-toc-安装&quot;&gt;安装&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#使用&quot; id=&quot;markdown-toc-使用&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;各大平台下 nodejs 的安装看这里 : &lt;a href=&quot;https://nodejs.org/en/download/package-manager/#windows&quot;&gt;https://nodejs.org/en/download/package-manager/#windows&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Nodejs 发展比较快, 所以版本更新迭代快&lt;/p&gt;

&lt;h2 id=&quot;ubuntu-下的安装&quot;&gt;Ubuntu 下的安装&lt;/h2&gt;

&lt;h3 id=&quot;源安装&quot;&gt;源安装&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Nodejs v5.x&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -sL https://deb.nodesource.com/setup_5.x | sudo -E bash -
sudo apt-get install -y nodejs
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Nodejs v4.x&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -sL https://deb.nodesource.com/setup_4.x | sudo -E bash -
sudo apt-get install -y nodejs
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;假如你在使用 Ubuntu 12.04 以及更低版本,请升级你的系统, 再进行安装  &lt;br /&gt;
至于原因，看这里 : &lt;a href=&quot;https://github.com/nodesource/distributions/blob/master/OLDER_DISTROS.md&quot;&gt;https://github.com/nodesource/distributions/blob/master/OLDER_DISTROS.md&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;node-version-manager&quot;&gt;Node Version Manager&lt;/h3&gt;

&lt;p&gt;Nodejs 升级迭代很快, 不同的 Nodejs 项目，可能使用的是不同版本的 Nodejs  &lt;br /&gt;
因此, 要维持多个 Nodejs 项目, 那就需要一种工具来管理 nodejs&lt;/p&gt;

&lt;p&gt;这就是 Node Version Manager&lt;/p&gt;

&lt;p&gt;目前, 有两个比较有名的 Node Version Manager : &lt;a href=&quot;https://github.com/tj/n&quot;&gt;n&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/creationix/nvm&quot;&gt;nvm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Github 上 nvm 的 Star 明显是 n 的 2 倍多  &lt;br /&gt;
因此, 这里讲述一下 nvm 的安装与使用&lt;/p&gt;

&lt;p&gt;nvm 项目地址 : &lt;a href=&quot;https://github.com/creationix/nvm&quot;&gt;https://github.com/creationix/nvm&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;安装&quot;&gt;安装&lt;/h4&gt;

&lt;p&gt;nvm 给出了自动安装的脚本, 因此你可以用过 &lt;code class=&quot;highlighter-rouge&quot;&gt;wget&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt; 实现自动安装, 看这里 :&lt;br /&gt;
&lt;a href=&quot;https://github.com/creationix/nvm#install-script&quot;&gt;https://github.com/creationix/nvm#install-script&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里主要讲一下手动安装  &lt;br /&gt;
手动安装可以使你明白自动安装到底做了什么&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装前的准备 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; sudo apt-get install build-essential libssl-dev -y
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;克隆仓库到 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.nvm&lt;/code&gt; :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; git clone https://github.com/creationix/nvm.git ~/.nvm &amp;amp;&amp;amp; cd ~/.nvm &amp;amp;&amp;amp; git checkout `git describe --abbrev=0 --tags`
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加下面到 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.bashrc&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.profile&lt;/code&gt;或 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.zshrc&lt;/code&gt;) :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; export NVM_DIR=&quot;$HOME/.nvm&quot;
 [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;amp;&amp;amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;使用&quot;&gt;使用&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装一个指定的版本 : &lt;code class=&quot;highlighter-rouge&quot;&gt;nvm install v0.10.32&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装最新的 0.10.x 版本 : &lt;code class=&quot;highlighter-rouge&quot;&gt;nvm install 0.10&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 v0.10.32 版本的 nodejs 去运行 app.js :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; nvm run 0.10.32 node app.js
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示已安装的 v0.10.32 node 的安装路径 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; nvm which v0.10.32
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;node&lt;/code&gt; 代表最新版本的 node, 因此你可以直接在 &lt;code class=&quot;highlighter-rouge&quot;&gt;nvm use&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;nvm install&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;nvm exec&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;nvm which&lt;/code&gt; 中使用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在一个 nodejs 中集成其他版本的 &lt;code class=&quot;highlighter-rouge&quot;&gt;npm&lt;/code&gt; :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; nvm install v5.0 --reinstall-packages-from=4.2
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用系统安装的 node :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; nvm use system
 nvm run system --version
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;列出当前已经安装的 node :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; nvm ls
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;列出当前可以获得的 node :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; nvm ls-remote
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
                <link>/%E8%AE%B0%E5%BD%95/2015/11/03/install-nodejs-on-ubuntu/</link>
                <guid>/%E8%AE%B0%E5%BD%95/2015/11/03/install-nodejs-on-ubuntu</guid>
                <pubDate>Tue, 03 Nov 2015 00:00:00 -0600</pubDate>
        </item>

        <item>
                <title>构建 SSH 隧道 -- 端口转发</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ssh-隧道&quot; id=&quot;markdown-toc-ssh-隧道&quot;&gt;SSH 隧道&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ssh-隧道的类型&quot; id=&quot;markdown-toc-ssh-隧道的类型&quot;&gt;SSH 隧道的类型&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参数提前说明&quot; id=&quot;markdown-toc-参数提前说明&quot;&gt;参数提前说明&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#动态端口转发--socks-代理&quot; id=&quot;markdown-toc-动态端口转发--socks-代理&quot;&gt;动态端口转发 – SOCKS 代理&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#假设&quot; id=&quot;markdown-toc-假设&quot;&gt;假设&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#命令原型&quot; id=&quot;markdown-toc-命令原型&quot;&gt;命令原型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#实际使用&quot; id=&quot;markdown-toc-实际使用&quot;&gt;实际使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#本地端口转发&quot; id=&quot;markdown-toc-本地端口转发&quot;&gt;本地端口转发&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#假设-1&quot; id=&quot;markdown-toc-假设-1&quot;&gt;假设&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#命令原型-1&quot; id=&quot;markdown-toc-命令原型-1&quot;&gt;命令原型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#实际使用-1&quot; id=&quot;markdown-toc-实际使用-1&quot;&gt;实际使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#远程端口转发&quot; id=&quot;markdown-toc-远程端口转发&quot;&gt;远程端口转发&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#假设-2&quot; id=&quot;markdown-toc-假设-2&quot;&gt;假设&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#命令原型-2&quot; id=&quot;markdown-toc-命令原型-2&quot;&gt;命令原型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#实际应用&quot; id=&quot;markdown-toc-实际应用&quot;&gt;实际应用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ssh-一些辅助参数&quot; id=&quot;markdown-toc-ssh-一些辅助参数&quot;&gt;SSH 一些辅助参数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#相关命令&quot; id=&quot;markdown-toc-相关命令&quot;&gt;相关命令&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#代理软件&quot; id=&quot;markdown-toc-代理软件&quot;&gt;代理软件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ssh-隧道&quot;&gt;SSH 隧道&lt;/h2&gt;

&lt;p&gt;使用 SSH 可以进行端口转发，从而实现流往某端口的数据被加密后传向另一机器,这个过程形似构造了一条通道，因此也称之为 SSH 隧道(SSH Tunnel)&lt;/p&gt;

&lt;p&gt;使用 SSH 隧道可以让数据被加密并透明地传输到远端系统&lt;/p&gt;

&lt;h3 id=&quot;ssh-隧道的类型&quot;&gt;SSH 隧道的类型&lt;/h3&gt;

&lt;p&gt;SSH 隧道有三种类型 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;动态端口转发 (socks 代理)&lt;/li&gt;
  &lt;li&gt;本地端口转发&lt;/li&gt;
  &lt;li&gt;远程端口转发&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;参数提前说明&quot;&gt;参数提前说明&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bind_address&lt;/code&gt; – 可选的, 监听的网卡地址
    &lt;ol&gt;
      &lt;li&gt;省略 – 取决于  &lt;code class=&quot;highlighter-rouge&quot;&gt;GatewayPorts&lt;/code&gt; 的设置(man 手册可以看到，但是没有在 Ubuntu 14.04中找到)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;localhost&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;127.0.0.1&lt;/code&gt; – 监听 127.0.0.1, 仅能用于本地&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0.0.0.0&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; – 监听本机所有网络接口&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hostX&lt;/code&gt; – 主机 hostX 的 ip 或 域名&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hostX_port&lt;/code&gt; – 主机hostX 的空闲端口
    &lt;ol&gt;
      &lt;li&gt;0 - 1023 : 特权端口,只能 root 用户才能进行端口转发  &lt;br /&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports&quot;&gt;特权端口列表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;1024 - 65535 : 选择一个没被占用的端口&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;user@hostX&lt;/code&gt; – 用户名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; 可以登录主机 hostX&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;动态端口转发--socks-代理&quot;&gt;动态端口转发 – SOCKS 代理&lt;/h2&gt;

&lt;p&gt;支持 SOCKS4 和 SOCKS5 代理&lt;/p&gt;

&lt;h3 id=&quot;假设&quot;&gt;假设&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;存在两台主机 host1, host2&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host1 可以 SSH 连接 host2&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以使 host1 某端口的数据发往 host2, host2 根据其应用程序协议发出到指定地址, 就好像是从 host2 直接发出的数据&lt;/p&gt;

&lt;p&gt;可以认为我们搭建了一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_server&quot;&gt;代理服务器(Proxy Server)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;于是就有了下面这个命令 (&lt;code class=&quot;highlighter-rouge&quot;&gt;host1上执行&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;命令原型&quot;&gt;命令原型&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;host1 $ ssh -D [bind_address:]host1_port user@host2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;动态端口转发的过程 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;host1 申请了一个 socket 来监听 &lt;code class=&quot;highlighter-rouge&quot;&gt;bind_address:host1_port&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host1 与 host2 建立一条 ssh 隧道&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当 host1 有请求 &lt;code class=&quot;highlighter-rouge&quot;&gt;bind_address:host1_port&lt;/code&gt;, 请求数据会从 ssh 隧道发往 host2&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host2 收到数据, 根据数据的应用程序协议去发送数据到指定的地址&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;返回数据会按原有路径返还&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;实际使用&quot;&gt;实际使用&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;host1 $ ssh -D 127.0.0.1:7070 user@host2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;chrome 上使用 proxy SwitchySharp 进行代理设置
    &lt;ol&gt;
      &lt;li&gt;新建情景模式 &lt;code class=&quot;highlighter-rouge&quot;&gt;proxy&lt;/code&gt;, 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;socks代理&lt;/code&gt; 那行填入 &lt;code class=&quot;highlighter-rouge&quot;&gt;127.0.0.1&lt;/code&gt; 和 端口那栏填入 &lt;code class=&quot;highlighter-rouge&quot;&gt;7070&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;点击 proxy SwitchySharp 的头标, 勾选 &lt;code class=&quot;highlighter-rouge&quot;&gt;proxy&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Ubuntu 下使用 proxychains 为应用程序设置代理
    &lt;ol&gt;
      &lt;li&gt;安装 – &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get install proxychains&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;修改配置文件(&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/proxychains.conf&lt;/code&gt;)的 &lt;code class=&quot;highlighter-rouge&quot;&gt;[ProxyList]&lt;/code&gt; 为自己的代理 : &lt;code class=&quot;highlighter-rouge&quot;&gt;socks4 127.0.0.1 7070&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;让程序使用代理 : &lt;code class=&quot;highlighter-rouge&quot;&gt;proxychains program-name&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt; 进行下载验证&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ curl --socks5 localhost:7070 download-link
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;本地端口转发&quot;&gt;本地端口转发&lt;/h2&gt;

&lt;h3 id=&quot;假设-1&quot;&gt;假设&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;存在三台主机 host1, host2, host3&lt;/li&gt;
  &lt;li&gt;host1 和 host3 不能通信&lt;/li&gt;
  &lt;li&gt;host2 可以同时和 host1 与 host3 通信&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此, 我们可以借助 host2 实现 host1 和 host3 的通信&lt;/p&gt;

&lt;p&gt;于是就有了下面这个命令原型(&lt;code class=&quot;highlighter-rouge&quot;&gt;host1 上执行&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;命令原型-1&quot;&gt;命令原型&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;host1 $ ssh -L [bind_address:]host1_port:host3:host3_port user@host2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;本地端口转发的过程 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;绑定 host1 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;bind_address:host1_port&lt;/code&gt;, 与 host2 构建一条 SSH 隧道&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当我们请求 &lt;code class=&quot;highlighter-rouge&quot;&gt;bind_address:host1_port&lt;/code&gt; 时, 请求的数据通过 SSH 隧道到达 host2，host2 就会把数据发送到 host3 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;host3_port&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;返回的数据按照原路返回&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;实际使用-1&quot;&gt;实际使用&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;通过访问 host1 本地 8080 端口来访问 host3 的 80 端口(host3 已经安装 Web 服务)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; host1 $ ssh -L 8080:host3:80 user@host2
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;执行完成，在 host1 浏览器中 输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;localhost:8080&lt;/code&gt; 即可看到 host3 的 Web 页面  &lt;br /&gt;
如果使用 xshell 等工具访问 host1, 那么可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;curl localhost:8080&lt;/code&gt; 来查看 Web 内容&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host1 使用 ssh 登录 host3 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; host1 $ ssh -L 2030:host3:22 user@host2
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;现在你可以在另开一个 host1 终端输入 : &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh -p 2030 user@host3&lt;/code&gt; 去登录 host3&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;远程端口转发&quot;&gt;远程端口转发&lt;/h2&gt;

&lt;h3 id=&quot;假设-2&quot;&gt;假设&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;存在三台主机 host1, host2, host3&lt;/li&gt;
  &lt;li&gt;host1 和 host3 不能相互访问&lt;/li&gt;
  &lt;li&gt;host2 可以和 host3 相互访问&lt;/li&gt;
  &lt;li&gt;host2 可以 ssh 访问 host1&lt;/li&gt;
  &lt;li&gt;host1 不可以访问 host2&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样的话, host1 就不可以 ssh 连接 host2 了，所以本地端口转发就不能用了  &lt;br /&gt;
而 host2 可以 ssh 连接 host1, 那么 host1 就可以借助这条连接与 host3 进行通信&lt;/p&gt;

&lt;p&gt;这就是 SSH 的远程端口转发&lt;/p&gt;

&lt;p&gt;于是就有了下面这个命令原型 (&lt;code class=&quot;highlighter-rouge&quot;&gt;host2 上执行&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;命令原型-2&quot;&gt;命令原型&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;host2 $ ssh -R [bind_address:]host1_port:host3:host3_port user@host1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;远程端口转发的过程 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;host2 与 host1 构建了一条 ssh 隧道&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host1 申请了一个 socket 随时监听 &lt;code class=&quot;highlighter-rouge&quot;&gt;bind_address:host1_port&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当 host1 有请求 &lt;code class=&quot;highlighter-rouge&quot;&gt;bind_address:host1_port&lt;/code&gt; 时, 请求的数据会从 ssh 隧道 发往 host2&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host2 收到数据, 然后转发数据到 &lt;code class=&quot;highlighter-rouge&quot;&gt;host3:host3_port&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;返回数据按原路径返还&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;实际应用&quot;&gt;实际应用&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;通过访问 host1 本地 8080 端口来访问 host3 的 80 端口(host3 已经安装 Web 服务)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; host2 $ ssh -R 8080:host3:80 user@host1
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;执行完成，在 host1 浏览器中 输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;localhost:8080&lt;/code&gt; 即可看到 host3 的 Web 页面  &lt;br /&gt;
如果使用 xshell 等工具访问 host1, 那么可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;curl localhost:8080&lt;/code&gt; 来查看 Web 内容&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host1 使用 ssh 登录 host3 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; host2 $ ssh -R 2030:host3:22 user@host1
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;现在你可以在另开一个 host1 终端输入 : &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh -p 2030 user@host3&lt;/code&gt; 去登录 host3&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;ssh-一些辅助参数&quot;&gt;SSH 一些辅助参数&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-q&lt;/code&gt; – 安静模式. 抑制警告和诊断信息&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-T&lt;/code&gt; – 不分配伪终端，只是使用隧道&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-N&lt;/code&gt; – 不运行远程命令(仅对端口转发有用)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt; – 后台运行
    &lt;ul&gt;
      &lt;li&gt;配合 &lt;code class=&quot;highlighter-rouge&quot;&gt;-N&lt;/code&gt; 一起使用, 否则产生 &lt;code class=&quot;highlighter-rouge&quot;&gt;Cannot fork into background without a command to execute.&lt;/code&gt;的错误&lt;/li&gt;
      &lt;li&gt;或者在命令末尾加上一个简单的命令 : &lt;code class=&quot;highlighter-rouge&quot;&gt;sleep 30&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-n&lt;/code&gt; – 重定向标准输入到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/null&lt;/code&gt;(阻止从标准输入读)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-o ServerAliveInterval=60&lt;/code&gt; – 让 SSH 每隔一段时间发送一些消息,避免隧道关闭 &lt;code class=&quot;highlighter-rouge&quot;&gt;Write failed: Broken pipe&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt; – 打印调试信息&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ssh -qTfnN -D 7070 xxx@yyy.com	//ssh 后台动态端口转发
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;相关命令&quot;&gt;相关命令&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;查看端口是否占用 : &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo lsof -i :port&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt; 下载文档&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;代理软件&quot;&gt;代理软件&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.proxycap.com/download.html&quot;&gt;proxycap&lt;/a&gt; – windows&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.proxifier.com/&quot;&gt;Proxifier&lt;/a&gt; – windows/OS – 全局代理&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://proxychains.sourceforge.net/&quot;&gt;proxychains&lt;/a&gt; – Linux&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/darkk/redsocks&quot;&gt;readsocks&lt;/a&gt; – Linux&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://tsocks.sourceforge.net/&quot;&gt;tsocks&lt;/a&gt; – Linux – 全局代理&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm?utm_source=chrome-app-launcher-info-dialog&quot;&gt;Proxy SwitchySharp&lt;/a&gt; – chrome&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt; 支持 socks4/SOCKS5 等代理下载  – 太棒了, 命令行用起来很方便&lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>/%E8%AE%B0%E5%BD%95/2015/09/25/ssh-port-forwarding/</link>
                <guid>/%E8%AE%B0%E5%BD%95/2015/09/25/ssh-port-forwarding</guid>
                <pubDate>Fri, 25 Sep 2015 00:00:00 -0500</pubDate>
        </item>

        <item>
                <title>使用 SSH 进行远程操作</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ssh-copy-id-做了什么&quot; id=&quot;markdown-toc-ssh-copy-id-做了什么&quot;&gt;ssh-copy-id 做了什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#做些什么几个实例&quot; id=&quot;markdown-toc-做些什么几个实例&quot;&gt;做些什么(几个实例)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#远程自动化脚本的实现&quot; id=&quot;markdown-toc-远程自动化脚本的实现&quot;&gt;远程自动化脚本的实现&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#是否允许分配伪终端&quot; id=&quot;markdown-toc-是否允许分配伪终端&quot;&gt;是否允许分配伪终端&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#参考链接&quot; id=&quot;markdown-toc-参考链接&quot;&gt;参考链接&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用 SSH 可以实现直接在本地对远程主机执行操作&lt;/p&gt;

&lt;h2 id=&quot;ssh-copy-id-做了什么&quot;&gt;ssh-copy-id 做了什么&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ssh-copy-id ifmicro@remote-host  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它实现了这样一个功能 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;把 `~/.ssh/id_rsa.pub` 内容添加到 remote-host 的用户 ifmicro 的用户主目录下的文件 `~/.ssh/authorized_keys` 的末尾  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过命令组合, 我们也可以实现同样的功能 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ssh ifmicro@remote-host 'mkdir -p .ssh &amp;amp;&amp;amp; cat &amp;gt;&amp;gt; .ssh/authorized_keys &amp;amp;&amp;amp; chmod 600 .ssh/authorized_keys' &amp;lt; ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因此, 我们可以得出这样一个结论 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SSH 可以在用户和服务器之间，建立一条通道来实现命令和数据的传输  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;做些什么几个实例&quot;&gt;做些什么(几个实例)&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;复制 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello-cpp/&lt;/code&gt; 目录下的东西到远程主机的 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/hello-cpp&lt;/code&gt; 目录下 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ tar czv hello-cpp | ssh ifmicro@remote-host 'tar xz'
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将服务器 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/hello-cpp/&lt;/code&gt; 下的东西复制到本地当前目录 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ ssh ifmicro@remote-host 'tar czv hello-cpp' | tar xz
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看服务器的有多少个用户 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ ssh ifmicro@remote-host 'ls .. | wc -w'
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;远程自动化脚本的实现&quot;&gt;远程自动化脚本的实现&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 这只是一个远程自动化脚本的架构  &lt;/span&gt;
remote_auto&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
	ssh -T &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt; &amp;lt;&amp;lt;&lt;span class=&quot;s2&quot;&gt;&quot;EOF&quot;&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, I'm in &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;, my name is&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;whoami&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;;
	&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;;
	&lt;span class=&quot;c&quot;&gt;# 这里可以添加更多的命令&lt;/span&gt;
	EOF
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 这里可以继续添加更多其他服务器执行任务&lt;/span&gt;
remote_auto ifmicro@remote-host-1 &amp;amp;
remote_auto ifmicro@remote-host-1 &amp;amp;
...

&lt;span class=&quot;c&quot;&gt;# 等待所有后台进程结束&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;wait&lt;/span&gt; 
&lt;span class=&quot;c&quot;&gt;# 做些结果处理&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;自行填充这个脚本中的内容&lt;/li&gt;
  &lt;li&gt;请学习 &lt;a href=&quot;http://www.tldp.org/LDP/abs/html/here-docs.html&quot;&gt;here Document&lt;/a&gt; 的语法&lt;/li&gt;
  &lt;li&gt;根据需求使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh -T&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh -t&lt;/code&gt; 、&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh -tt&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;是否允许分配伪终端&quot;&gt;是否允许分配伪终端&lt;/h3&gt;

&lt;p&gt;当采用 Here Document 执行命令的时候，可能会出现 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Pseudo-terminal will not be allocated because stdin is not a terminal.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;意思是无法分配一个伪终端给这个 ssh 链接&lt;/p&gt;

&lt;p&gt;在伪终端中执行脚本, 可以进行交互  &lt;br /&gt;
而没有伪终端, 则不能进行交互&lt;/p&gt;

&lt;p&gt;因此对于此的解决方案就呼之欲出了 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;禁止分配伪终端 – 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh -T&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;强制分配伪终端 – 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh -t&lt;/code&gt;  或 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh -tt&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里是 &lt;code class=&quot;highlighter-rouge&quot;&gt;man ssh&lt;/code&gt; 中这两个参数的描述 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-T	Disable pseudo-terminal allocation.
-t	Force pseudo-terminal allocation. This can be used to execute arbitrary screen-based 
	programs on a remote machine, which can be very useful, e.g. when implementing menu 
	services. Multiple -t options force tty allocation, even if ssh has no local tty
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们上面的自动化脚本框架中使用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh -T&lt;/code&gt;, 是因为对于自动化来说，基本上不用交互的  &lt;br /&gt;
当然也有可能需要交互, 可以考虑 &lt;code class=&quot;highlighter-rouge&quot;&gt;expect&lt;/code&gt; 来实现自动交互&lt;/p&gt;

&lt;h3 id=&quot;参考链接&quot;&gt;参考链接&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.unixmantra.com/2014/03/a-simple-way-to-send-multiple-line-commands-over-ssh.html&quot;&gt;a-simple-way-to-send-multiple-line-commands-over-ssh&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.tldp.org/LDP/abs/html/here-docs.html&quot;&gt;Here Document-en&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://shouce.jb51.net/shell/here-docs.html&quot;&gt;Here Document-zh&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.open-open.com/lib/view/open1415793400445.html&quot;&gt;shell 操作之 read、cat 和 here document&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>/%E8%AE%B0%E5%BD%95/2015/09/23/ssh-remote-run-cmd/</link>
                <guid>/%E8%AE%B0%E5%BD%95/2015/09/23/ssh-remote-run-cmd</guid>
                <pubDate>Wed, 23 Sep 2015 00:00:00 -0500</pubDate>
        </item>

        <item>
                <title>使用 SSH 登录服务器</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ssh-是什么&quot; id=&quot;markdown-toc-ssh-是什么&quot;&gt;SSH 是什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#安装-ssh&quot; id=&quot;markdown-toc-安装-ssh&quot;&gt;安装 SSH&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#两种登陆方式&quot; id=&quot;markdown-toc-两种登陆方式&quot;&gt;两种登陆方式&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#使用密码口令登录服务器&quot; id=&quot;markdown-toc-使用密码口令登录服务器&quot;&gt;使用密码口令登录服务器&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#使用&quot; id=&quot;markdown-toc-使用&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#验证流程&quot; id=&quot;markdown-toc-验证流程&quot;&gt;验证流程&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#使用公钥实现无密码登录&quot; id=&quot;markdown-toc-使用公钥实现无密码登录&quot;&gt;使用公钥实现无密码登录&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#使用-1&quot; id=&quot;markdown-toc-使用-1&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#登录流程&quot; id=&quot;markdown-toc-登录流程&quot;&gt;登录流程&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#第一次登录服务器&quot; id=&quot;markdown-toc-第一次登录服务器&quot;&gt;第一次登录服务器&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#中间人攻击&quot; id=&quot;markdown-toc-中间人攻击&quot;&gt;中间人攻击&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#公钥加密技术&quot; id=&quot;markdown-toc-公钥加密技术&quot;&gt;公钥加密技术&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#一些思考&quot; id=&quot;markdown-toc-一些思考&quot;&gt;一些思考&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#一些相关的文件&quot; id=&quot;markdown-toc-一些相关的文件&quot;&gt;一些相关的文件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#待补充&quot; id=&quot;markdown-toc-待补充&quot;&gt;待补充&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ssh-是什么&quot;&gt;SSH 是什么&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Secure_Shell&quot;&gt;SSH&lt;/a&gt; 是一个允许两台电脑之间通过安全的连接进行数据交换的网络协议  &lt;br /&gt;
它采用公钥加密技术对传输的数据进行加密, 保证了数据的保密性和完整性&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/OpenSSH&quot;&gt;OpenSSH&lt;/a&gt; 是 SSH 协议的一种实现，是一种比较 popular 的远程登录服务器的软件&lt;/p&gt;

&lt;h2 id=&quot;安装-ssh&quot;&gt;安装 SSH&lt;/h2&gt;

&lt;p&gt;Linux 主机普遍默认安装 OpenSSH&lt;/p&gt;

&lt;p&gt;客户端安装 ssh client 去登录服务器 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install openssh-client
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;服务器端安装 ssh server 用以验证客户端的登录 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install openssh-server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;两种登陆方式&quot;&gt;两种登陆方式&lt;/h2&gt;

&lt;p&gt;SSH 提供两种登录服务器的方式 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用密码口令&lt;/li&gt;
  &lt;li&gt;使用公钥实现无密码登录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在此，做出以下假定 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;服务器上的用户名 : &lt;code class=&quot;highlighter-rouge&quot;&gt;ifmicro&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;服务器地址 : &lt;code class=&quot;highlighter-rouge&quot;&gt;remote-host&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;服务器的 SSH 服务监听端口 : &lt;code class=&quot;highlighter-rouge&quot;&gt;22&lt;/code&gt;(默认)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使用密码口令登录服务器&quot;&gt;使用密码口令登录服务器&lt;/h3&gt;

&lt;h4 id=&quot;使用&quot;&gt;使用&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ssh ifmicro@remote-host
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果本地用户名也是 &lt;code class=&quot;highlighter-rouge&quot;&gt;ifmicro&lt;/code&gt; , 那么 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ssh ifmicro
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;假如你的服务器 SSH 服务监听端口是 &lt;code class=&quot;highlighter-rouge&quot;&gt;2222&lt;/code&gt; , 那么 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ssh -p 2222 ifmicro@remote-host
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;验证流程&quot;&gt;验证流程&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;客户端想服务器发送登录请求&lt;/li&gt;
  &lt;li&gt;服务器收到请求，把自己的公钥发给用户&lt;/li&gt;
  &lt;li&gt;用户使用这个公钥，对自己的密码进行加密，然后发送给服务器&lt;/li&gt;
  &lt;li&gt;服务器用自己的私钥对收到加密后的密码进行解密，如果密码正确，就同意用户登录&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使用公钥实现无密码登录&quot;&gt;使用公钥实现无密码登录&lt;/h3&gt;

&lt;h4 id=&quot;使用-1&quot;&gt;使用&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;生成公钥和私钥(如果存在，请忽略) :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;

 Generating public/private rsa key pair.
 Enter file in which to save the key (/home/vagrant/.ssh/id_rsa):
 Enter passphrase (empty for no passphrase):
 Enter same passphrase again:
 Your identification has been saved in /home/vagrant/.ssh/id_rsa.
 Your public key has been saved in /home/vagrant/.ssh/id_rsa.pub.
 The key fingerprint is:
 2e:a3:02:c9:f1:bd:bd:d3:2e:85:26:4c:4a:b6:d1:11 your_email@example.com
 The key's randomart image is:
 +--[ RSA 4096]----+
 |     E.          |
 |     .           |
 |    . .          |
 | . + o           |
 |..= B   S        |
 |o. + + + .       |
 | .    B +        |
 |  .  o * .       |
 |   ..  .=.       |
 +-----------------+
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;一路默认即可，生成的私钥和公钥位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.ssh/&lt;/code&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;id_rsa&lt;/code&gt;(私钥) 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;id_rsa.pub&lt;/code&gt;(公钥)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把公钥添加到服务器的 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.ssh/authorized_keys&lt;/code&gt; 末尾:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ ssh-copy-id -i id_rsa.pub ifmicro@remote-host
 /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
 /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
 ifmicro@remote-host's password:

 Number of key(s) added: 1

 Now try logging into the machine, with:   &quot;ssh 'ifmicro@remote-host'&quot;
 and check to make sure that only the key(s) you wanted were added.
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;可以看到已经成功添加&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 ssh 登录服务器 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ ssh -i ~/.ssh/id_rsa ifmicro@remote-host
 Last login: Tue Sep 22 06:39:30 2015 from 10.18.61.57
 ifmicro@remmote-host $ 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;如果私钥是 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.ssh/id_rsa&lt;/code&gt; ，那么可以忽略 &lt;code class=&quot;highlighter-rouge&quot;&gt;-i ~/.ssh/id_isa&lt;/code&gt;  选项  &lt;br /&gt;
否则，请用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-i private_key&lt;/code&gt; 指定私钥&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;登录流程&quot;&gt;登录流程&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;客户端向服务器发送登录请求&lt;/li&gt;
  &lt;li&gt;服务器收到请求后, 向客户端发送一断随机字符串&lt;/li&gt;
  &lt;li&gt;客户端收到字符串，然后用自己的私钥进行加密，发送给服务器&lt;/li&gt;
  &lt;li&gt;服务器用实现客户给的公钥进行解密, 如果解密成功, 证明用户可信，登录成功&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;第一次登录服务器&quot;&gt;第一次登录服务器&lt;/h3&gt;

&lt;p&gt;第一次登录服务器 , 系统会有如下提示 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The authenticity of host 'remote-host (10.108.79.5)' can't be established.
RSA key fingerprint is 31:51:f8:e3:53:01:c4:76:af:60:9c:3b:b3:1b:5e:37.
Are you sure you want to continue connecting (yes/no)?
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这段话意思是本地主机在这之前没有与服务器 remote-host 建立过链接, 无法确定服务器的真实性  &lt;br /&gt;
只知道 RSA 公钥的指纹&lt;sup id=&quot;fnref:fingerprint&quot;&gt;&lt;a href=&quot;#fn:fingerprint&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，是否要继续连接&lt;/p&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh-keygen&lt;/code&gt; 工具可以生成 SSH 密钥对，其中公钥的长度很长，对于用户来说不容易比较  &lt;br /&gt;
因此对其进行 MD5 计算生成的 128 位指纹进行比较就非常容易了&lt;/p&gt;

&lt;p&gt;为了确认主机的真实性，这里就要求我们事先知道服务器的公钥指纹&lt;/p&gt;

&lt;p&gt;如果你确定这是你要登录的那台服务器，那么输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;yes&lt;/code&gt; 继续连接&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果你采用密码口令登录服务器，那么&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Warning: Permanently added 'remote-host,10.108.79.5' (RSA) to the list of known hosts.
 Enter passphrase for key '/home/vagrant/.ssh/id_rsa':
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;输入密码，如果密码正确，那么登录成功&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你采用公钥认证登录服务器, 那么输出上面这条 &lt;code class=&quot;highlighter-rouge&quot;&gt;Warning&lt;/code&gt;, 就直接登录上服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一次登录成功后, 服务器的公钥会被保存到文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;$HOME/.ssh/known_hosts&lt;/code&gt; 中  &lt;br /&gt;
下次登录服务器，&lt;code class=&quot;highlighter-rouge&quot;&gt;Warning&lt;/code&gt; 消失&lt;/p&gt;

&lt;p&gt;每个 SSH 用户都有自己的 &lt;code class=&quot;highlighter-rouge&quot;&gt;known_hosts&lt;/code&gt; 文件  &lt;br /&gt;
系统也有一个这样的文件，通常是 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/ssh/ssh_known_hosts&lt;/code&gt; 保存一些对所有用户都可信赖的服务器的公钥&lt;/p&gt;

&lt;h3 id=&quot;中间人攻击&quot;&gt;中间人攻击&lt;/h3&gt;

&lt;p&gt;SSH 之所以可以保证安全，是因为采用了公钥加密信息&lt;/p&gt;

&lt;p&gt;在上面我们可以看到，使用密码口令的真个过程本身是安全的, 但是存在这个一个风险 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果有攻击者截获了用户的登录请求，然后冒充服务器，将伪造后的公钥发送给用户  
用户在不知情或难辨真伪的情况下,用这个伪造密钥进行加密，然后发送给服务器  
然后攻击者又一次截获，获得用伪造密钥加密的密码，然后用自己的私钥进行解密，就得到了用户在服务器上的账号和密码  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于使用口令进行 ssh 登录的情况下，伪造的公钥很难辨别真伪  &lt;br /&gt;
因为公钥都是自己签发的, 没有证书中心 (CA) 公正&lt;/p&gt;

&lt;p&gt;可以设想一下 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果攻击者在用户登录服务器时, 截获登录请求，并用伪造的公钥欺骗用户, 那么很容易获取用户在服务上的登录密码  
然后攻击者就可以在服务器上为所欲为(如果有权限的话)
这样, SSH 的安全机制就荡然无存  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这就是著名的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Man-in-the-middle_attack&quot;&gt;中间人攻击&lt;/a&gt;(Man-in-the-middle attack)&lt;/p&gt;

&lt;p&gt;所以，基于密码的安全认证是无法避免中间人攻击&lt;/p&gt;

&lt;h2 id=&quot;公钥加密技术&quot;&gt;公钥加密技术&lt;/h2&gt;

&lt;p&gt;公钥加密技术提供两个密钥 : 公钥(id_rsa.pub) 和 私钥(id_rsa)&lt;/p&gt;

&lt;p&gt;公钥加密技术主要是利用公钥和私钥的互相加密和解密的非对成性 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;公钥加密的文件，只能被私钥解密&lt;/li&gt;
  &lt;li&gt;私钥加密的文件，只能被公钥解密&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;普通的加密技术的加密运算和解密运算使用同样的密钥, 被称作对称密码学&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html&quot;&gt;数字签名是什么&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一些思考&quot;&gt;一些思考&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;为什么要修改 ssh 服务的默认端口 22 ?  &lt;br /&gt;
默认情况下, ssh 服务的端口为 22, 所以那些骇客们都会先从 22 端口入手, 通过 “暴力手段” 获取登录密码  &lt;br /&gt;
所以, 建议修改 ssh 服务默认端口, 这样能一定程度上过滤掉一些不怀好意的访客  &lt;br /&gt;
(虽然说对有心者并没什么鸟用,但是多做点防护总没坏处)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh-copy-id&lt;/code&gt; 到底做了什么?  &lt;br /&gt;
事实上, ssh-copy-id 做了下面脚本做的事 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ ssh ifmicro@remote-host 'mkdir -p .ssh &amp;amp;&amp;amp; cat &amp;gt;&amp;gt; .ssh/authorized_keys &amp;amp;&amp;amp; chmod 600 .ssh/authorized_keys' &amp;lt; ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;一些相关的文件&quot;&gt;一些相关的文件&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;id_rsa&lt;/code&gt;(私钥) 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;id_rsa.pub&lt;/code&gt;(公钥)
    &lt;ul&gt;
      &lt;li&gt;默认情况下, 位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.ssh/id_rsa&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.ssh/id_rsa.pub&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;这是使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh-keygen&lt;/code&gt; 指定 &lt;code class=&quot;highlighter-rouge&quot;&gt;-t rsa&lt;/code&gt; 默认生成的私钥和公钥, 可以在过程中指定生成的文件名&lt;/li&gt;
      &lt;li&gt;默认情况下, ssh 只会读取 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.sss/id_rsa&lt;/code&gt; 去加密  &lt;br /&gt;
如果使用非默认的私钥, 那么需要在 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh -i private-key&lt;/code&gt; 或者使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh-agent&lt;/code&gt; 去管理&lt;/li&gt;
      &lt;li&gt;要保持当前文件权限为 &lt;code class=&quot;highlighter-rouge&quot;&gt;600&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;authorized_keys&lt;/code&gt; – 存储来自客户端的公钥
    &lt;ul&gt;
      &lt;li&gt;默认情况下, 位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.ssh/authorized_keys&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;把来自客户端的公钥添加到这个文件中，就可以实现无密码登录&lt;/li&gt;
      &lt;li&gt;要保持当前文件权限为 &lt;code class=&quot;highlighter-rouge&quot;&gt;600&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;待补充&quot;&gt;待补充&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;ssh-agent 和 ssh 之间的关系&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ssh 端口转发  &lt;br /&gt;
&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html&quot;&gt;SSH原理与运用（二）：远程操作与端口转发&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://wiki.archlinux.org/index.php/Secure_Shell_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)&quot;&gt;Arch Linux&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://help.github.com/articles/generating-ssh-keys/&quot;&gt;Generating SSH keys&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;s. &lt;a href=&quot;http://www.ibm.com/developerworks/cn/aix/library/1006_lisali_sshlogon/#major6&quot;&gt;开发自动化脚本&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:fingerprint&quot;&gt;
      &lt;p&gt;对 RSA 公钥进行 MD5 计算生成的一个 128 位的指纹 &lt;a href=&quot;#fnref:fingerprint&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>/%E8%AE%B0%E5%BD%95/2015/09/21/ssh-login-server/</link>
                <guid>/%E8%AE%B0%E5%BD%95/2015/09/21/ssh-login-server</guid>
                <pubDate>Mon, 21 Sep 2015 00:00:00 -0500</pubDate>
        </item>

        <item>
                <title>用 gitbook 来写书</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#gitbook-是什么&quot; id=&quot;markdown-toc-gitbook-是什么&quot;&gt;GitBook 是什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gitbook-能做些什么&quot; id=&quot;markdown-toc-gitbook-能做些什么&quot;&gt;GitBook 能做些什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ubuntu-下-gitbook-的安装&quot; id=&quot;markdown-toc-ubuntu-下-gitbook-的安装&quot;&gt;Ubuntu 下 gitbook 的安装&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#用-gitbook-来写书&quot; id=&quot;markdown-toc-用-gitbook-来写书&quot;&gt;用 gitbook 来写书&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gitbook-的命令小结&quot; id=&quot;markdown-toc-gitbook-的命令小结&quot;&gt;gitbook 的命令小结&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#构建和运行&quot; id=&quot;markdown-toc-构建和运行&quot;&gt;构建和运行&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#生成电子书pdfepub和mobi&quot; id=&quot;markdown-toc-生成电子书pdfepub和mobi&quot;&gt;生成电子书(PDF、ePub和Mobi)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#指定一个版本&quot; id=&quot;markdown-toc-指定一个版本&quot;&gt;指定一个版本&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#管理版本&quot; id=&quot;markdown-toc-管理版本&quot;&gt;管理版本&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#自定义书本的-css&quot; id=&quot;markdown-toc-自定义书本的-css&quot;&gt;自定义书本的 css&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#用插件来丰富你的书&quot; id=&quot;markdown-toc-用插件来丰富你的书&quot;&gt;用插件来丰富你的书&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#发现插件&quot; id=&quot;markdown-toc-发现插件&quot;&gt;发现插件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#安装插件&quot; id=&quot;markdown-toc-安装插件&quot;&gt;安装插件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#一些插件&quot; id=&quot;markdown-toc-一些插件&quot;&gt;一些插件&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#disqus-评论系统--disqus&quot; id=&quot;markdown-toc-disqus-评论系统--disqus&quot;&gt;disqus 评论系统 – disqus&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#自动化封面--autocover&quot; id=&quot;markdown-toc-自动化封面--autocover&quot;&gt;自动化封面 – autocover&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gitbook-相关链接&quot; id=&quot;markdown-toc-gitbook-相关链接&quot;&gt;GitBook 相关链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gitbook-是什么&quot;&gt;GitBook 是什么&lt;/h2&gt;

&lt;p&gt;GitBook 是一个可以用来构建一本漂亮的电子书的命令行工具&lt;sup id=&quot;fnref:gitbook-online&quot;&gt;&lt;a href=&quot;#fn:gitbook-online&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; , 基于 Node.js&lt;/p&gt;

&lt;p&gt;可以使用 Markdown 文法来写作&lt;/p&gt;

&lt;p&gt;只要你部署好一定的目录结构并且完成书的内容，就能通过命令很方便地转化成网页和其它格式的电子书&lt;/p&gt;

&lt;p&gt;所以，用起来很简单&lt;/p&gt;

&lt;h2 id=&quot;gitbook-能做些什么&quot;&gt;GitBook 能做些什么&lt;/h2&gt;

&lt;p&gt;写一本书，听起来有点太高级，但是往往却是如此现实  &lt;br /&gt;
因此，你可以用 GitBook 来写一本属于你自己的书&lt;/p&gt;

&lt;p&gt;至于书的内容，就由你自己来定:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以是你幻想已久的一个世界&lt;/li&gt;
  &lt;li&gt;可以是平时生活中的小常识&lt;/li&gt;
  &lt;li&gt;可以是一本菜谱&lt;/li&gt;
  &lt;li&gt;可以是你整理知识的小册子&lt;/li&gt;
  &lt;li&gt;可以是…&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ubuntu-下-gitbook-的安装&quot;&gt;Ubuntu 下 gitbook 的安装&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装 nodejs并建立软链接&lt;sup id=&quot;fnref:nodejs&quot;&gt;&lt;a href=&quot;#fn:nodejs&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo apt-get install nodejs -y &amp;amp;&amp;amp; sudo ln -s `which nodejs` /usr/bin/node
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装 NPM&lt;sup id=&quot;fnref:npm&quot;&gt;&lt;a href=&quot;#fn:npm&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo apt-get install npm
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装 gitbook(全局)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo npm install gitbook-cli -g
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;用-gitbook-来写书&quot;&gt;用 gitbook 来写书&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;新建一个项目，命名为 learn-gitbook, 并初始化&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ mkdir learn-gitbook &amp;amp;&amp;amp; cd learn-gitbook
 learn-gitbook $ gitbook init 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;learn-gitbook 下会生成两个文件 README.md 和 SUMMARY.md&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;构建并运行服务器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ gitbook serve ./learn-gitbook  --port 4001
 ...
 Starting server ...
 Serving book on http://localhost:4001
 ...
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;在浏览器中访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:4001&lt;/code&gt;, 就可以看到一个没有内容的书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改书籍名称&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; learn-gitbook $ echo &quot;#learn gitbook&quot; &amp;gt; README.md
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;在浏览器中查看浏览器标签页显示内容的变化&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改书籍介绍的内容&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; learn-gitbook $ echo &quot;GitBook is a command line tool (and Node.js library) for building beautiful books using GitHub/Git and Markdown (or AsciiDoc).&quot; &amp;gt;&amp;gt; README.md
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;在浏览器中查看 Introduction 页面的变化&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增加几个章节(Markdown 的列表和链接语法)  &lt;br /&gt;
在 SUMMARY.md 中增加以下内容 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; * [Part I](part1/README.md)
   * [Writing is nice](part1/writing.md)
   * [GitBook is nice](part1/gitbook.md)
 * [Part II](part2/README.md)
   * [We love feedback](part2/feedback_please.md)
   * [Better tools for authors](part2/better_tools.md)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;重建项目页面和目录 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;learn-gitbook  $ gitbook init		
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;在浏览器中查看左边侧边栏的变化：发现有了几个新的章节&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为每个页面增加内容&lt;/p&gt;

    &lt;p&gt;你只要在相应的页面用 Markdown 文法写作&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增加术语页面(GLOSSARY.md)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; learn-gitbook $ touch GLOSSARY.md &amp;amp;&amp;amp; vim GLOSSARY.md		
 # 术语
 这个术语的定义

 # 另外一个术语
 它的定义可以包含粗体和其他所有类型的内嵌式标记...
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;浏览器中你会发现 : 书中有 &lt;code class=&quot;highlighter-rouge&quot;&gt;术语&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;另外一个术语&lt;/code&gt; 字样的都被高亮，而且可以点击看到它的解释&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 book.json 中指定 gitbook 版本  &lt;br /&gt;
列出已经安装的版本&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; learn-gitbook $ gitbook versions				
 Versions Installed:

      2.2.0
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;新建 book.json,并指定版本 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; learn-gitbook $ touch book.json &amp;amp;&amp;amp; vim book.json
 {
     &quot;gitbook&quot; : &quot;2.2.0&quot;
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;避免运行 gitbook 时输出警告 : &lt;code class=&quot;highlighter-rouge&quot;&gt;warn: you should specify a gitbook version to use in your book.json, for example: 2.x.x&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定书籍所用语言风格  &lt;br /&gt;
修改 book.json 内容为 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; {
     &quot;gitbook&quot; : &quot;2.2.0&quot;,
     &quot;language&quot; : &quot;cn&quot;
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;在浏览器中可以看到侧边栏的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Introduction&lt;/code&gt; 变为 &lt;code class=&quot;highlighter-rouge&quot;&gt;介绍&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为侧边栏顶部增加链接  &lt;br /&gt;
   修改 book.json 内容为 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;gitbook&quot; : &quot;2.2.0&quot;,
    &quot;language&quot; : &quot;cn&quot;,
    &quot;links&quot; : {
        &quot;sidebar&quot; : {
            &quot;倘若微小&quot; : &quot;http://www.ifmicro.com/&quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;在浏览器中可以看到侧边栏顶部增加一个链接，名为 &lt;a href=&quot;http://www.ifmicro.com/&quot;&gt;倘若微小&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后，尽情写下你奇妙的想法，分享给大家吧&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;通过网站分享：把 learn-gitbook/_book 的内容放到一个云服务器上&lt;/li&gt;
  &lt;li&gt;发布电子书到云盘: 生成 pdf、epub、mobi电子书，放到云盘进行分享&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gitbook-的命令小结&quot;&gt;gitbook 的命令小结&lt;/h2&gt;

&lt;h3 id=&quot;构建和运行&quot;&gt;构建和运行&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;初始化项目目录:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ gitbook init
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;会自动生成 SUMMARY.md 中指定的页面目录和页面&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成网站&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ gitbook build book_path output_path
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;构建网页并运行一个小型服务器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ gitbook serve --port 4001  
 ...
 Serving book on http://localhost:4001
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;在浏览器上，访问 http://localhost:4001 , 就可以看到你的书&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;生成电子书pdfepub和mobi&quot;&gt;生成电子书(PDF、ePub和Mobi)&lt;/h3&gt;

&lt;p&gt;第一步 : &lt;a href=&quot;http://www.calibre-ebook.com/download&quot;&gt;安装 calibre&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;第二步 : 执行对应命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ gitbook pdf  book_path  output_path/book_name.pdf
	$ gitbook epub book_path  output_path/book_name.epub
	$ gitbook mobi book_path  output_path/book_name.mobi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;指定一个版本&quot;&gt;指定一个版本&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ gitbook build book_path --gitbook=2.3.0
	$ gitbook help --gitbook=2.3.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;管理版本&quot;&gt;管理版本&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;查看 gitbook 使用&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ gitbook -h
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看可以获得的所有 GitBook 版本:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ gitbook versions:available  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装最新的 GitBook 版本&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo gitbook versions:install latest
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;自定义书本的-css&quot;&gt;自定义书本的 css&lt;/h2&gt;

&lt;p&gt;一般在生成站点时，会有默认的 css (_book/gitbook/style.css)&lt;/p&gt;

&lt;p&gt;你也可以自定义 css，使你的书籍更好看&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;建立 css 文件&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; learn-gitbook $ mkdir -p assets/css &amp;amp;&amp;amp; cd assets/css &amp;amp;&amp;amp; touch myWebStyle.css myPdfStyle.css myMobiStyle.css myEpubStyle.css
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;在 myStyle.css 写下你的样式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 book.json 中添加&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; {
     &quot;styles&quot; : {
         &quot;website&quot; : &quot;assets/css/myWebStyle.css&quot;,
         &quot;pdf&quot; : &quot;assets/css/myPdfStyle.css&quot;,
         &quot;mobi&quot; : &quot;assets/css/myMobiStyle.css&quot;,
         &quot;epub&quot; : &quot;assets/css/myEpubStyle.css&quot;
     }
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;我分别为 site, pdf, mobi, epub 指定了 css, 那么分别生成它们的时候，会在默认的 css 基础上层叠指定的 css&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;用插件来丰富你的书&quot;&gt;用插件来丰富你的书&lt;/h2&gt;

&lt;p&gt;gitbook 文档推荐插件(主题也是插件的一种)的命名方式:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;gitbook-plugin-X&lt;/li&gt;
  &lt;li&gt;gitbook-theme-X&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;发现插件&quot;&gt;发现插件&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/search?q=gitbook-plugin&quot;&gt;NPM-Search-gitbook-plugin&lt;/a&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; https://www.npmjs.com/search?q=gitbook-plugin
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/search?q=gitbook-theme&quot;&gt;NPM-Search-gitbook-theme&lt;/a&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; https://www.npmjs.com/search?q=gitbook-theme
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://plugins.gitbook.com/&quot;&gt;gitbook 插件官方地址&lt;/a&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; http://plugins.gitbook.com/
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;安装插件&quot;&gt;安装插件&lt;/h3&gt;

&lt;p&gt;一旦你发现你需要的插件，在 book.json 添加:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  &quot;plugins&quot;: [&quot;myPlugin&quot;, &quot;anotherPlugin&quot;]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于 gitbook-plugin-X 的插件，请这样安装 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;book-dir $ gitbook install  或者 npm install gitbook-plugin-X
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于 gitbook-theme-X 的插件，请这样安装 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;book-dir $ npm install gitbook-theme-X &amp;amp;&amp;amp; mv node_modules/gitbook-theme-X node_modules/gitbook-plugin-X`
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;PS : 具体插件请参照具体插件的文档&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;一些插件&quot;&gt;一些插件&lt;/h3&gt;

&lt;h4 id=&quot;disqus-评论系统--disqus&quot;&gt;disqus 评论系统 – &lt;a href=&quot;http://plugins.gitbook.com/plugin/disqus&quot;&gt;disqus&lt;/a&gt;&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装 gitbook-plugin-disqus&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; sudo npm install gitbook-plugin-disqus -g
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 book.json 中添加 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; {
     &quot;plugins&quot;: [&quot;disqus&quot;],
     &quot;pluginsConfig&quot;: {
         &quot;disqus&quot;: {
                 &quot;shortName&quot;: &quot;XXXXXXX&quot;
             }
         }  
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shortName&lt;/code&gt; 是你在 &lt;a href=&quot;https://disqus.com/&quot;&gt;disqus.com&lt;/a&gt; 上创建 website 指定的 shortname&lt;/p&gt;

&lt;h4 id=&quot;自动化封面--autocover&quot;&gt;自动化封面 – &lt;a href=&quot;http://plugins.gitbook.com/plugin/autocover&quot;&gt;autocover&lt;/a&gt;&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;安装 &lt;a href=&quot;https://github.com/Automattic/node-canvas/wiki/_pages&quot;&gt;node-canvas&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装 gitbook-plugin-autocover&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; sudo npm install gitbook-plugin-autocover
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 book.json 中添加 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; {
     &quot;plugins&quot;: [&quot;autocover&quot;],
     &quot;pluginsConfig&quot;: {
         &quot;autocover&quot;: {
             &quot;title&quot;: &quot;My Book&quot;,
             &quot;author&quot;: &quot;Author&quot;,
             &quot;font&quot;: {
                 &quot;size&quot;: null,
                 &quot;family&quot;: &quot;Impact&quot;,
                 &quot;color&quot;: &quot;#FFF&quot;
             },
             &quot;size&quot;: {
                 &quot;w&quot;: 1800,
                 &quot;h&quot;: 2360
             },
             &quot;background&quot;: {
                 &quot;color&quot;: &quot;#09F&quot;
             }
         }
     }
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;gitbook-相关链接&quot;&gt;GitBook 相关链接&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;GitBook 官方文档 : &lt;a href=&quot;https://www.gitbook.com/book/gitbookio/documentation/details&quot;&gt;https://www.gitbook.com/book/gitbookio/documentation/details&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GitBook 项目目录 : &lt;a href=&quot;https://github.com/GitbookIO/gitbook&quot;&gt;https://github.com/GitbookIO/gitbook&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gitbook-cli 项目目录 : &lt;a href=&quot;https://github.com/GitbookIO/gitbook-cli&quot;&gt;https://github.com/GitbookIO/gitbook-cli&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GitBook API Documentation : &lt;a href=&quot;http://developer.gitbook.com/&quot;&gt;http://developer.gitbook.com/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GitBook Enterprise Guide : &lt;a href=&quot;https://www.gitbook.com/book/gitbookio/enterprise-guide/details&quot;&gt;https://www.gitbook.com/book/gitbookio/enterprise-guide/details&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:gitbook-online&quot;&gt;
      &lt;p&gt;还有一个与之同名的在线创建和托管书籍的平台&lt;a href=&quot;https://www.gitbook.com/&quot;&gt;www.gitbook.com&lt;/a&gt; &lt;a href=&quot;#fnref:gitbook-online&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:nodejs&quot;&gt;
      &lt;p&gt;采用软链接解决ubuntu下 nodejs 命令名与 gitbook 内部使用 nodejs 命令名不一致&lt;br /&gt;具体看&lt;a href=&quot;http://stackoverflow.com/questions/18130164/nodejs-vs-node-on-ubuntu-12-04#answer-18130296&quot;&gt;nodejs vs node on ubuntu 12.04&lt;/a&gt; &lt;a href=&quot;#fnref:nodejs&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:npm&quot;&gt;
      &lt;p&gt;Node Package Manager , 一个 nodejs 包管理和分发工具 &lt;br /&gt;&lt;a href=&quot;https://github.com/npm/npm&quot;&gt;NPM Github项目地址&lt;/a&gt; &lt;a href=&quot;#fnref:npm&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>/%E8%AE%B0%E5%BD%95/2015/09/07/gitbook/</link>
                <guid>/%E8%AE%B0%E5%BD%95/2015/09/07/gitbook</guid>
                <pubDate>Mon, 07 Sep 2015 00:00:00 -0500</pubDate>
        </item>

        <item>
                <title>用 tmux 保存工作现场</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-是什么&quot; id=&quot;markdown-toc-tmux-是什么&quot;&gt;tmux 是什么?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-的任务会话机制&quot; id=&quot;markdown-toc-tmux-的任务会话机制&quot;&gt;tmux 的任务会话机制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#安装-tmux&quot; id=&quot;markdown-toc-安装-tmux&quot;&gt;安装 tmux&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-session&quot; id=&quot;markdown-toc-tmux-session&quot;&gt;tmux session&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-window&quot; id=&quot;markdown-toc-tmux-window&quot;&gt;tmux window&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#创建-window&quot; id=&quot;markdown-toc-创建-window&quot;&gt;创建 window&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#切换-window&quot; id=&quot;markdown-toc-切换-window&quot;&gt;切换 window&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#重命名当前窗口&quot; id=&quot;markdown-toc-重命名当前窗口&quot;&gt;重命名当前窗口&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-pane&quot; id=&quot;markdown-toc-tmux-pane&quot;&gt;tmux pane&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-的复制&quot; id=&quot;markdown-toc-tmux-的复制&quot;&gt;tmux 的复制&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#copy-模式下的复制&quot; id=&quot;markdown-toc-copy-模式下的复制&quot;&gt;Copy 模式下的复制&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#推荐使用-copy-模式&quot; id=&quot;markdown-toc-推荐使用-copy-模式&quot;&gt;推荐使用 Copy 模式&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-的配置文件&quot; id=&quot;markdown-toc-tmux-的配置文件&quot;&gt;tmux 的配置文件&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#配置文件生效&quot; id=&quot;markdown-toc-配置文件生效&quot;&gt;配置文件生效&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#一个简单的-tmux-配置文件&quot; id=&quot;markdown-toc-一个简单的-tmux-配置文件&quot;&gt;一个简单的 tmux 配置文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#自动生成布局&quot; id=&quot;markdown-toc-自动生成布局&quot;&gt;自动生成布局&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-在远程服务器中的表现&quot; id=&quot;markdown-toc-tmux-在远程服务器中的表现&quot;&gt;tmux 在远程服务器中的表现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#结对编程&quot; id=&quot;markdown-toc-结对编程&quot;&gt;结对编程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-小技巧&quot; id=&quot;markdown-toc-tmux-小技巧&quot;&gt;tmux 小技巧&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux-的-command-prompt&quot; id=&quot;markdown-toc-tmux-的-command-prompt&quot;&gt;tmux 的 command-prompt&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux-快捷键帮助&quot; id=&quot;markdown-toc-tmux-快捷键帮助&quot;&gt;tmux 快捷键帮助&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#重新绑定-send-prefix&quot; id=&quot;markdown-toc-重新绑定-send-prefix&quot;&gt;重新绑定 send-prefix&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux-底部状态栏&quot; id=&quot;markdown-toc-tmux-底部状态栏&quot;&gt;tmux 底部状态栏&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#显示钟表&quot; id=&quot;markdown-toc-显示钟表&quot;&gt;显示钟表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#为-pane-显示编号快速切换&quot; id=&quot;markdown-toc-为-pane-显示编号快速切换&quot;&gt;为 pane 显示编号—快速切换&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#使用tmux的一些问题&quot; id=&quot;markdown-toc-使用tmux的一些问题&quot;&gt;使用tmux的一些问题&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux-和-vim的powerline插件&quot; id=&quot;markdown-toc-tmux-和-vim的powerline插件&quot;&gt;tmux 和 vim的powerline插件&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#一些自言自语&quot; id=&quot;markdown-toc-一些自言自语&quot;&gt;一些自言自语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tmux-是什么&quot;&gt;tmux 是什么?&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tmux&lt;/code&gt; 是一款非常好用的终端复用器&lt;/p&gt;

&lt;p&gt;可以认为是终端分屏软件，但远远不止…  &lt;br /&gt;
可以认为是 &lt;code class=&quot;highlighter-rouge&quot;&gt;nohup&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 的结合体，但远远不止…  &lt;br /&gt;
可以认为是一款结对编程 ( Pair Programming ) 的软件，但远远不止…&lt;/p&gt;

&lt;p&gt;是的，远远不止…&lt;/p&gt;

&lt;p&gt;不知道怎么去描述，且跟随使用去体会吧&lt;/p&gt;

&lt;h2 id=&quot;tmux-的任务会话机制&quot;&gt;tmux 的任务会话机制&lt;/h2&gt;

&lt;p&gt;当你运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;tmux&lt;/code&gt; 之后，会启动一个 tmux server 来管理 tmux 的 sessions&lt;/p&gt;

&lt;p&gt;tmux server 有且仅有一个，并且在第一个 session 创建时启动， 当最后一个 session 销毁时销毁&lt;/p&gt;

&lt;p&gt;然后有以下几条规则:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个 tmux server 可以有多个 sessions&lt;/li&gt;
  &lt;li&gt;一个 session 可以有多个 window ， 类似终端有多个标签页&lt;/li&gt;
  &lt;li&gt;一个 window 可以有多个 pane, 即分屏&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;session&lt;/code&gt; 可译作 &lt;code class=&quot;highlighter-rouge&quot;&gt;会话&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; 可译作 &lt;code class=&quot;highlighter-rouge&quot;&gt;窗口&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;pane&lt;/code&gt; 可译作 &lt;code class=&quot;highlighter-rouge&quot;&gt;窗格&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;安装-tmux&quot;&gt;安装 tmux&lt;/h2&gt;

&lt;p&gt;Ubuntu 下安装 : &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get install tmux&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Centos 下安装 : &lt;a href=&quot;https://www.zybuluo.com/mwumli/note/149542&quot;&gt;CentOS 下安装 tmux&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;tmux-session&quot;&gt;tmux session&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;快速创建: &lt;code class=&quot;highlighter-rouge&quot;&gt;tmux&lt;/code&gt;  &lt;br /&gt;
这样创建的 session 被自动用数字命名&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个命名的 session : &lt;code class=&quot;highlighter-rouge&quot;&gt;tmux new-session -s session-name&lt;/code&gt;  或 &lt;code class=&quot;highlighter-rouge&quot;&gt;tmux new -s session-name&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看当前所有的 sessions : &lt;code class=&quot;highlighter-rouge&quot;&gt;tmux list-sessions&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;tmux ls&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;脱离当前 session : &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + d&lt;/code&gt;  &lt;br /&gt;
脱离当前 session , 你的工作状态依然保留&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果想重新进入之前的 session , 只需: &lt;code class=&quot;highlighter-rouge&quot;&gt;tmux attach-session -t session-name&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;tmux a -t session-name&lt;/code&gt;  &lt;br /&gt;
这样你又回看到你之前的工作进度了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当你想退出当前 session : 在终端中输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;exit&lt;/code&gt;, 直到所有的 window 和 pane 被关闭  &lt;br /&gt;
这时，你的 session 也被销毁了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;杀死指定的 session : &lt;code class=&quot;highlighter-rouge&quot;&gt;tmux kill-session -t session-name&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重命名 session : &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + $&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;杀死所有的 session : &lt;code class=&quot;highlighter-rouge&quot;&gt;tmux kill-server&lt;/code&gt;  &lt;br /&gt;
因为所有的 sessions 跑在一个 server 上  &lt;br /&gt;
所以只要关掉 tmux server 即可&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;tmux-window&quot;&gt;tmux window&lt;/h2&gt;

&lt;h3 id=&quot;创建-window&quot;&gt;创建 window&lt;/h3&gt;

&lt;p&gt;当你创建一个 session 时，也自动创建一个 window , window 中也会自动创建一个 pane&lt;/p&gt;

&lt;p&gt;在 session 中创建 window :  按下&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b +c&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;切换-window&quot;&gt;切换 window&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;切换到下一个窗口 : &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + n&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切换到上一个窗口 : &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + p&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切换到num窗口，num为窗口编号，底部状态栏可看到 : &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + num&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示当前会话的所有窗口 : &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + w&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭当前窗口 : &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + &amp;amp;&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;exit&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl + d&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;重命名当前窗口&quot;&gt;重命名当前窗口&lt;/h3&gt;

&lt;p&gt;按下 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + ,&lt;/code&gt;  &lt;br /&gt;
然后输入 window-name 即可&lt;/p&gt;

&lt;h2 id=&quot;tmux-pane&quot;&gt;tmux pane&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;分割一个垂直的窗格 : &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + &quot;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分割一个水平的窗格 : &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + %&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;移动到其他窗格 : &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + Arrow-Up/Down/Left/Right&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭所有窗格 : &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + !&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tmux-的复制&quot;&gt;tmux 的复制&lt;/h2&gt;

&lt;p&gt;在没有启动鼠标滚轮时， tmux 可以通过鼠标选中，并复制&lt;/p&gt;

&lt;p&gt;当你用了上面配置文件中的鼠标滚轮启用，那么一般的鼠标选中就不可能了:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;按下 shift, 然后使用鼠标去选中想要copy的内容进行复制操作  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;copy-模式下的复制&quot;&gt;Copy 模式下的复制&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Copy 模式下的复制, 然后粘贴&lt;br /&gt;
tmux 提供了一种 copy 模式,类似于 vim 的(Esc-v)模式 : 按下 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + [&lt;/code&gt; 进入 copy 模式  &lt;br /&gt;
tmux 的 copy 模式下有两种快捷键模式: vim 和 Emacs  &lt;br /&gt;
当你在配置文件中启用 vim 模式: &lt;code class=&quot;highlighter-rouge&quot;&gt;setw -g mode-keys vi&lt;/code&gt;  &lt;br /&gt;
在 copy 模式下， 我们就可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;j/k/h/l&lt;/code&gt; 来移动光标了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;复制  &lt;br /&gt;
在 Copy 模式下，我们这样复制:
    &lt;ol&gt;
      &lt;li&gt;移动光标到复制开始位置&lt;/li&gt;
      &lt;li&gt;按下 &lt;code class=&quot;highlighter-rouge&quot;&gt;Space&lt;/code&gt; 键进入复制模式&lt;/li&gt;
      &lt;li&gt;移动光标选择要复制的内容&lt;/li&gt;
      &lt;li&gt;按下 &lt;code class=&quot;highlighter-rouge&quot;&gt;Enter&lt;/code&gt; 键完成复制&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;粘贴  &lt;br /&gt;
到你要粘贴内容的位置， 使用快捷键 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + ]&lt;/code&gt;  &lt;br /&gt;
刚才复制的内容已经被完美粘贴了&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;推荐使用-copy-模式&quot;&gt;推荐使用 Copy 模式&lt;/h3&gt;

&lt;p&gt;如果你只是想复制不超过一行文字，那么这两种方式均可，甚至第一种方式更有效率&lt;/p&gt;

&lt;p&gt;如果你想复制多行文本，那么还是使用Copy 模式&lt;/p&gt;

&lt;p&gt;这和 tmux 的实现方式有关,具体请自行探讨&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tmux-的配置文件&quot;&gt;tmux 的配置文件&lt;/h2&gt;

&lt;h3 id=&quot;配置文件生效&quot;&gt;配置文件生效&lt;/h3&gt;

&lt;p&gt;配置文件生效有两种方式:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;新建一个 session, &lt;code class=&quot;highlighter-rouge&quot;&gt;.tmux.conf&lt;/code&gt; 中的设置就在此 session 中生效了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在当前 session 中，按下 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + :&lt;/code&gt;,然后:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; : source-file ~/.tmux.conf
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.tmux.conf&lt;/code&gt;是 tmux 配置文件的命名，默认位于你的用户主目录下&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;一个简单的-tmux-配置文件&quot;&gt;一个简单的 tmux 配置文件&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# This is a tmux configure file
# 取消默认Ctrl+b的前缀绑定，绑定Ctrl+s为新的快捷发送前缀方式
unbind C-o
set -g prefix C-s

# Copy模式下使用vim快捷操作方式
setw -g mode-keys vi

# split window with p/v after C-s
bind p split-window -h
bind v split-window -v

# move into left/Down/Up/Right panes with h/j/k/l after C-s
bind h select-pane -L
bind j select-pane -D
bind k select-pane -U
bind l select-pane -R

# resize panes forward left/right/Down/Up with &amp;lt;/&amp;gt;/-/+ after C-s
bind &amp;lt; resize-pane -L 10
bind &amp;gt; resize-pane -R 10
bind - resize-pane -D 10
bind + resize-pane -U 10

# bind : to command-prompt like vim
# this is the defalut in tmux already
bind : command-prompt

# 鼠标可以选中窗格
set-option -g mouse-select-pane on  
# 鼠标滚轮可以使用
set-window-option -g mode-mouse on  

# 分屏后如何保留先前窗格的路径
bind c new-window -c &quot;#{pane_current_path}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;自动生成布局&quot;&gt;自动生成布局&lt;/h3&gt;

&lt;p&gt;新建一个文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.tmux/mylayout&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;selectp -t 0 #选中第0个窗格
splitw -h -p 50 #将其分成左右两个
selectp -t 1 #选中第一个，也就是右边那个
splitw -v -p 50 #将右边那个分成上下两个
selectp -t 0 #选中第一个
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在 &lt;code class=&quot;highlighter-rouge&quot;&gt;.tmux.conf&lt;/code&gt;	后面添加:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bind D source-file ~/.tmux/mylayout
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，每次当我们启动 tmux 后， 可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + D&lt;/code&gt; 来生成布局&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tmux-在远程服务器中的表现&quot;&gt;tmux 在远程服务器中的表现&lt;/h2&gt;

&lt;p&gt;如果通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh&lt;/code&gt; 远程登录到服务器，恰好要进行一个很耗时的任务&lt;/p&gt;

&lt;p&gt;我们不可能等待这个任务执行完毕，再去做其他工作&lt;/p&gt;

&lt;p&gt;因此，我们选择了启用一个新的终端来完成其他工作&lt;/p&gt;

&lt;p&gt;但是网络可能很不稳定，你那个耗时任务在执行过程，突然网络掉线，然后，你的 ssh 断掉，然后你的任务挂掉了&lt;/p&gt;

&lt;p&gt;但是我们的任务已经进行了80%，功亏一篑&lt;/p&gt;

&lt;p&gt;是的，你可以选择执行任务时，采用 &lt;code class=&quot;highlighter-rouge&quot;&gt;nohup&lt;/code&gt; ，那样，网络断掉，也不会影响你的任务&lt;/p&gt;

&lt;p&gt;但是你永远也回不到 &lt;em&gt;案发现场&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;案发现场&lt;/em&gt; 在某些情况下很重要&lt;/p&gt;

&lt;p&gt;而且费那么多心思在保证任务完成，现场保留上，实在太浪费了&lt;/p&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;tmux&lt;/code&gt; 完全可以解决这个问题，除非远程服务器挂了&lt;/p&gt;

&lt;p&gt;因此，远程工作的正确方式:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ssh pi@192.168.199.114 
...
Last login: Tue May  5 02:37:14 2015 from 192.168.199.104
pi@raspberrypi ~ $ tmux new-session -s code
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，你可在 session 中进行分屏来完成其他工作  &lt;br /&gt;
或者你可以脱离终端， 继续其他操作  &lt;br /&gt;
再或者网络中断，当你重新连接上服务器:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
Last login: Tue May  5 02:37:14 2015 from 192.168.199.104
pi@raspberrypi ~ $ tmux a -t code
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你会发现，哦，我的工作现场依旧完整无缺…&lt;/p&gt;

&lt;h2 id=&quot;结对编程&quot;&gt;结对编程&lt;/h2&gt;

&lt;p&gt;关于结对编程的概念，可以查看维基百科:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://zh.wikipedia.org/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;tmux 利用服务器上的同一账户的同一 tmux session 实现的&lt;/p&gt;

&lt;p&gt;两个人打开同一个 tmux session, 一个人所做的改变，会即时的反映到另一个人的终端上&lt;/p&gt;

&lt;p&gt;tmux 基于文本， 所以即使网速慢点也无妨&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tmux-小技巧&quot;&gt;tmux 小技巧&lt;/h2&gt;

&lt;h3 id=&quot;tmux-的-command-prompt&quot;&gt;tmux 的 command-prompt&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;command-prompt&lt;/code&gt; 是用来输入 tmux 命令的&lt;/p&gt;

&lt;p&gt;tmux 的所有快捷键的功能都是通过命令来实现的&lt;/p&gt;

&lt;p&gt;因此，我们也通过键入命令来实现某种功能&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;按下 ctrl-b + : 即可打开 command-prompt  
然后，你输入相应命令即可  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;tmux-快捷键帮助&quot;&gt;tmux 快捷键帮助&lt;/h3&gt;

&lt;p&gt;tmux 的快捷键由 send-prefix 和 bind-key 组成&lt;/p&gt;

&lt;p&gt;按下 send-prefix 的同时，按下 bind-key 才唤醒相应的快捷功能&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;send-prefix&lt;/code&gt; 是固定的，默认是 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bind-key&lt;/code&gt; 对应不同的功能绑定了不同的 key, 可以通过以下方式查看:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;按下 `ctrl-b + ?`  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;重新绑定-send-prefix&quot;&gt;重新绑定 send-prefix&lt;/h3&gt;

&lt;p&gt;更换 send-prefix 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-a&lt;/code&gt; ,在 tmux 的配置文件(&lt;code class=&quot;highlighter-rouge&quot;&gt;.tmux.conf&lt;/code&gt;)中这样写:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unbind C-b
set -g prefix C-a
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;tmux-底部状态栏&quot;&gt;tmux 底部状态栏&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;tmux 窗口底部就是状态栏&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;状态栏左边显示 session-name ,并且列出当前所有 window-name ,以及所有 window 当前运行的 process-name&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当前所在 window 旁边会有 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 提示&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;右边会显示主机名和时间&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;显示钟表&quot;&gt;显示钟表&lt;/h3&gt;

&lt;p&gt;按下 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + t&lt;/code&gt;, 会在当前 window 的当前 pane 显示当前时间&lt;/p&gt;

&lt;h3 id=&quot;为-pane-显示编号快速切换&quot;&gt;为 pane 显示编号—快速切换&lt;/h3&gt;

&lt;p&gt;按下 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl-b + q&lt;/code&gt;, 每一个 pane 都会出现一个数字  &lt;br /&gt;
按下想要切换的 pane 显示的数字， 就可以切换到那个 pane&lt;/p&gt;

&lt;h2 id=&quot;使用tmux的一些问题&quot;&gt;使用tmux的一些问题&lt;/h2&gt;

&lt;h3 id=&quot;tmux-和-vim的powerline插件&quot;&gt;tmux 和 vim的powerline插件&lt;/h3&gt;

&lt;p&gt;默认情况下，启动vim, 如果使用了 powerline 插件， 那么会发现颜色显示不正常&lt;/p&gt;

&lt;p&gt;此时，只要你在每次打开 tmux 时启动256色即可，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;tmux -2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们可以在 &lt;code class=&quot;highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt; 末尾添加:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;alias tmux='tmux -2'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，每次使用 tmux 就会很方便啦&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一些自言自语&quot;&gt;一些自言自语&lt;/h2&gt;

&lt;p&gt;任何时候不要太过迷信一件东西&lt;/p&gt;

&lt;p&gt;你知道的, 服务器也会有重启的时候&lt;/p&gt;

&lt;p&gt;及时保存你的编辑，及时提交你的修改，及时备份你的收藏，永远是明智的做法&lt;/p&gt;

</description>
                <link>/%E8%BD%AF%E4%BB%B6/2015/05/05/tmux/</link>
                <guid>/%E8%BD%AF%E4%BB%B6/2015/05/05/tmux</guid>
                <pubDate>Tue, 05 May 2015 00:00:00 -0500</pubDate>
        </item>

        <item>
                <title>离去</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#实习&quot; id=&quot;markdown-toc-实习&quot;&gt;实习&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#前端的进步&quot; id=&quot;markdown-toc-前端的进步&quot;&gt;前端的进步&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#离去&quot; id=&quot;markdown-toc-离去&quot;&gt;离去&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#回家&quot; id=&quot;markdown-toc-回家&quot;&gt;回家&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;离职咯，嘿嘿，不要误会，只是实习期结束了…&lt;/p&gt;

&lt;h2 id=&quot;实习&quot;&gt;实习&lt;/h2&gt;

&lt;p&gt;实习这段时间，我的工作主要是前端方面的(喂，是不是搞错了，我面的是后台呀…)&lt;/p&gt;

&lt;p&gt;对于此，我郁闷好一会儿。  &lt;br /&gt;
不过，未来的学习计划安排有前端，所以也就提前让它生长发芽吧&lt;/p&gt;

&lt;h3 id=&quot;前端的进步&quot;&gt;前端的进步&lt;/h3&gt;

&lt;p&gt;同事中有位大哥，前端很厉害，指导了我很多&lt;/p&gt;

&lt;p&gt;之前接触过一些前端 : 基础知识很简单( HTML/CSS/JS ),但是简单也意味着，在某些方面会比较麻烦，比如页面布局，比如网站框架设计&lt;/p&gt;

&lt;p&gt;前端学习阶梯:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;HTML/CSS/JS，基础知识，很必要&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JQuery 的使用 — 这是一门很流行的js框架，我想学习它，非常必要&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bootstrap 的使用 — 想要快速开发一个响应式网站，那么学习它&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;与后台数据交互和Ajax — 与后台进行数据交互，这是一个必备技能，使用Ajax，也是必备技能&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JS的原型链继承，很重要, 这对学习框架设计(如果你只想写些效果，按照已有的框架设计，那就…)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;看源码 — 研究一下比较流行的插件源码吧,仅仅看书学习,不仅枯燥，而且你的知识只会碎片化  &lt;br /&gt;
 看源码,永远是最有效的学习方式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写插件 — 你已经学会原型链继承，也吸收了高手们开发插件的经验，那么开始写吧(有想法的时候)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;寻找机会 — 等待一个合适机会，从一个最基本的网站进行构建&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;快速编写 — less,sass,coffeescript …&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nodejs…&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;应该还有很多，目前就只了解到这里  &lt;br /&gt;
以上这些，有些顺序可以提前，学习本无先后，有所需，就得学…&lt;br /&gt;
我也并没有完全掌握这些知识，但是要想成为一个真正的前端，这些步骤时必须的&lt;/p&gt;

&lt;h2 id=&quot;离去&quot;&gt;离去&lt;/h2&gt;

&lt;p&gt;下雨了，没想到离去的时候，竟然会下雨&lt;/p&gt;

&lt;p&gt;长安也下雨了&lt;/p&gt;

&lt;p&gt;“青山一道同云雨，明月何曾是两乡”&lt;/p&gt;

&lt;p&gt;最后，再见，帝都…&lt;/p&gt;

&lt;h2 id=&quot;回家&quot;&gt;回家&lt;/h2&gt;

&lt;p&gt;我要回来了&lt;/p&gt;

</description>
                <link>/%E6%83%85%E7%BB%AA/2015/05/01/leave-beijing/</link>
                <guid>/%E6%83%85%E7%BB%AA/2015/05/01/leave-beijing</guid>
                <pubDate>Fri, 01 May 2015 00:00:00 -0500</pubDate>
        </item>

        <item>
                <title>Linux 下 php 扩展安装</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#碎碎念&quot; id=&quot;markdown-toc-碎碎念&quot;&gt;碎碎念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#extension_dir-和-extension&quot; id=&quot;markdown-toc-extension_dir-和-extension&quot;&gt;extension_dir 和 extension&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#extension_dir-实际生效值&quot; id=&quot;markdown-toc-extension_dir-实际生效值&quot;&gt;extension_dir 实际生效值&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#检验扩展是否应用&quot; id=&quot;markdown-toc-检验扩展是否应用&quot;&gt;检验扩展是否应用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#安装并添加php扩展&quot; id=&quot;markdown-toc-安装并添加php扩展&quot;&gt;安装并添加php扩展&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#phpize-的安装&quot; id=&quot;markdown-toc-phpize-的安装&quot;&gt;phpize 的安装&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#几个扩展常用扩展安装&quot; id=&quot;markdown-toc-几个扩展常用扩展安装&quot;&gt;几个扩展常用扩展安装&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#mccrypt-扩展的安装&quot; id=&quot;markdown-toc-mccrypt-扩展的安装&quot;&gt;MCcrypt 扩展的安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#igbinary-扩展的安装&quot; id=&quot;markdown-toc-igbinary-扩展的安装&quot;&gt;igbinary 扩展的安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#redis-扩展的安装&quot; id=&quot;markdown-toc-redis-扩展的安装&quot;&gt;redis 扩展的安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#mongo-扩展的安装&quot; id=&quot;markdown-toc-mongo-扩展的安装&quot;&gt;mongo 扩展的安装&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;碎碎念&quot;&gt;碎碎念&lt;/h2&gt;

&lt;p&gt;通过搭建 &lt;a href=&quot;/lamp-build&quot;&gt;LAMP 环境&lt;/a&gt;, 就可以使用 php 进行动态网站开发&lt;/p&gt;

&lt;p&gt;但有的时候增强 php 对某些特殊功能, 比如对 mongodb 的操纵, redis 的访问等&lt;/p&gt;

&lt;p&gt;这时候, 你就需要为 php 安装并配置相应扩展, 即 extension&lt;/p&gt;

&lt;h2 id=&quot;extension_dir-和-extension&quot;&gt;extension_dir 和 extension&lt;/h2&gt;

&lt;p&gt;php 有一个变量定义了 extension 在你的系统中的存放位置, 那就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;extension_dir&lt;/code&gt;  &lt;br /&gt;
只有 extension 存放到 &lt;code class=&quot;highlighter-rouge&quot;&gt;extension_dir&lt;/code&gt; 的指定路径, 那么 php 才能正确读取&lt;/p&gt;

&lt;p&gt;关于 &lt;code class=&quot;highlighter-rouge&quot;&gt;extension_dir&lt;/code&gt; :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;默认值 : &lt;code class=&quot;highlighter-rouge&quot;&gt;php -i | grep extension_dir&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重新指定  &lt;br /&gt;
在  &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/php5/apache2/php.ini&lt;/code&gt; 进行指定, 比如 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension_dir=&quot;/usr/share/php_extension&quot;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;extension_dir-实际生效值&quot;&gt;extension_dir 实际生效值&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在你的 Apache 目录下新建文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;phpinfo.php&lt;/code&gt;, 内容如下 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;?php
     phpinfo();
 ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;phpinfo.php&lt;/code&gt;, 搜索 &lt;code class=&quot;highlighter-rouge&quot;&gt;extension_dir&lt;/code&gt;, 可以看到当前 php 寻找 extension 的路径&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;检验扩展是否应用&quot;&gt;检验扩展是否应用&lt;/h3&gt;

&lt;p&gt;访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;phpinfo.php&lt;/code&gt;，搜索你的扩展，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果你的扩展放到 &lt;code class=&quot;highlighter-rouge&quot;&gt;extension_dir&lt;/code&gt; 并且已经添加到 php 的 apache 配置文件，那么就会搜索到  &lt;br /&gt;
如果没有搜索到 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;查看 &lt;code class=&quot;highlighter-rouge&quot;&gt;extension_dir&lt;/code&gt; 下有没有你的 extension&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;确认是否在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/php5/apache2/php.ini&lt;/code&gt; 中添加此 extension, 比如 redis :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [redis]
 extension=redis.so
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;重启服务器 : &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo service apache2 restart&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;可以留言共同讨论或者谷歌&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;安装并添加php扩展&quot;&gt;安装并添加php扩展&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载并安装下载相应扩展(请自行搜索)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; http://php.net/manual/zh/extensions.php  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加扩展到配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/php5/apache2/php.ini&lt;/code&gt;  &lt;br /&gt;
 (以&lt;code class=&quot;highlighter-rouge&quot;&gt;redis&lt;/code&gt;为例)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [redis]
 extension=redis.so
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;添加文件末尾即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; sudo service apache2 restart
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;phpize-的安装&quot;&gt;phpize 的安装&lt;/h2&gt;

&lt;p&gt;用 C 开发的 PHP 扩展使用动态链接库的方式编译扩展模块，需要用到 &lt;code class=&quot;highlighter-rouge&quot;&gt;phpize&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个工具在使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get install php5&lt;/code&gt; 默认情况也是没安装的&lt;/p&gt;

&lt;p&gt;执行以下命令去安装 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install php5-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;几个扩展常用扩展安装&quot;&gt;几个扩展常用扩展安装&lt;/h2&gt;

&lt;h3 id=&quot;mccrypt-扩展的安装&quot;&gt;MCcrypt 扩展的安装&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装 : &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get install php5-mcrypt&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加配置 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/php5/apache2/php.ini&lt;/code&gt;:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [mcrypt]
 extension=mcrypt.so
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;igbinary-扩展的安装&quot;&gt;igbinary 扩展的安装&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装 : &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo pecl install igbinary&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加配置 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/php5/apache2/php.ini&lt;/code&gt;:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[igbinary]
extension=igbinary.so
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;redis-扩展的安装&quot;&gt;redis 扩展的安装&lt;/h3&gt;

&lt;p&gt;官方文档 : &lt;a href=&quot;https://github.com/phpredis/phpredis#installingconfiguring&quot;&gt;https://github.com/phpredis/phpredis#installingconfiguring&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载, 编辑, 安装 :&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ git clone https://github.com/phpredis/phpredis.git
 $ phpize
 $ ./configure [--enable-redis-igbinary]
 $ make &amp;amp;&amp;amp; sudo make install
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;这样 redis 就被安装在合适的位置  &lt;br /&gt;
如果需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;--enable-redis-igbinary&lt;/code&gt;, 请先进行 &lt;code class=&quot;highlighter-rouge&quot;&gt;igbinary 扩展的安装&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加扩展到配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/php5/apache2/php.ini&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [redis]                            
 extension=redis.so
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;mongo-扩展的安装&quot;&gt;mongo 扩展的安装&lt;/h3&gt;

&lt;p&gt;官方文档: &lt;a href=&quot;http://php.net/manual/zh/mongo.installation.php&quot;&gt;http://php.net/manual/zh/mongo.installation.php&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载，编译，安装:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ git clone https://github.com/mongodb/mongo-php-driver-legacy.git
 $ cd mongo-php-driver-legacy
 $ phpize
 $ ./configure
 $ make all &amp;amp;&amp;amp; sudo make install
 ...
 Installing shared extensions:     
 /usr/lib/php5/20121212+lfs/
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加配置 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/php5/apache2/php.ini&lt;/code&gt;:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [mongo.so]
 extension=mongo.so
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>/%E8%AE%B0%E5%BD%95/2015/04/24/php-extension-install/</link>
                <guid>/%E8%AE%B0%E5%BD%95/2015/04/24/php-extension-install</guid>
                <pubDate>Fri, 24 Apr 2015 00:00:00 -0500</pubDate>
        </item>

        <item>
                <title>Raspberry Pi安装Debian Wheezy系统</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#碎碎念&quot; id=&quot;markdown-toc-碎碎念&quot;&gt;碎碎念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#系统安装&quot; id=&quot;markdown-toc-系统安装&quot;&gt;系统安装&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#不同平台下的镜像写入&quot; id=&quot;markdown-toc-不同平台下的镜像写入&quot;&gt;不同平台下的镜像写入&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#访问&quot; id=&quot;markdown-toc-访问&quot;&gt;访问&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#和正常计算机一样访问&quot; id=&quot;markdown-toc-和正常计算机一样访问&quot;&gt;和正常计算机一样访问&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#通过ssh远程访问&quot; id=&quot;markdown-toc-通过ssh远程访问&quot;&gt;通过ssh远程访问&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#使用vnc远程图形化访问&quot; id=&quot;markdown-toc-使用vnc远程图形化访问&quot;&gt;使用VNC远程图形化访问&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#配置&quot; id=&quot;markdown-toc-配置&quot;&gt;配置&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#更换软件源&quot; id=&quot;markdown-toc-更换软件源&quot;&gt;更换软件源&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#配置自动连接你的局域网&quot; id=&quot;markdown-toc-配置自动连接你的局域网&quot;&gt;配置自动连接你的局域网&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#后记&quot; id=&quot;markdown-toc-后记&quot;&gt;后记&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;碎碎念&quot;&gt;碎碎念&lt;/h3&gt;

&lt;p&gt;Raspberry Pi，是一款基于Linux系统的、信用卡大小的单板机电脑  &lt;br /&gt;
它的出现源于一个想&lt;strong&gt;制作一套启发孩子的电脑&lt;/strong&gt;的想法  &lt;br /&gt;
看来一切美好的事情背后总是有一颗让人心动的理念，而这个理念往往才是他们获得流行的动力&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/imgs/640px-RaspberryPi.jpg&quot; alt=&quot;树莓派B2.0简图&quot; title=&quot;树莓派B2.0简图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;系统安装&quot;&gt;系统安装&lt;/h3&gt;
&lt;p&gt;可以用于Raspberry Pi的系统很多，有我们即将安装的Debian Wheezy,还有Arch Linux ARM, RISC OS等等  &lt;br /&gt;
对咯，Debian Wheezy更为常见的称呼是Raspbian,但是为了避免与Raspberry Pix形似，我特意称其为Debian Wheezy,也喜欢这样称呼(嘿嘿…)  &lt;br /&gt;
这些资源都可以送网络上获取，感谢互联网&lt;/p&gt;

&lt;p&gt;为树莓派安装系统很简单，开始咯&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先从&lt;a href=&quot;http://www.raspberrypi.org/downloads/&quot; title=&quot;RaspberryPi OS下载页&quot;&gt;树莓派官网下载页&lt;/a&gt;选择下载Debian Wheezy系统(第一个应该就是),这是树莓派专用系统&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;因为Raspberry Pi是从SD卡启动的(&lt;strong&gt;没有BIOS和其他内部存储设备，只有一个SD卡槽&lt;/strong&gt;)，所以我们需要准备一张SD卡,8G大小(&lt;strong&gt;更大更好，不过it depends&lt;/strong&gt;),把SD卡使用卡托或者读卡器接入你的计算机&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;不同平台下的镜像写入&quot;&gt;不同平台下的镜像写入&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Windows
    &lt;ol&gt;
      &lt;li&gt;请下载官方推荐工具&lt;a href=&quot;http://sourceforge.net/projects/win32diskimager/&quot; title=&quot;一个Windows下把原始数据写入可移动设备的工具&quot;&gt;Win32 Disk Imager&lt;/a&gt;，它是一款绿色软件，点击即可使用&lt;/li&gt;
      &lt;li&gt;运行软件，选择我们SD卡盘符，加载我们的Debian Wheezy镜像(&lt;strong&gt;像2014-09-09-wheezy-raspbian.img&lt;/strong&gt;)，最后点击”Write”,等待几分钟写入完成&lt;/li&gt;
      &lt;li&gt;哦，对了，在写入镜像前，你也可以校验镜像的完整性，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;fciv&lt;/code&gt;命令生成SHA1校验码与网上公布的码值对比，如果一样，okay，没问题。不过假如你从官网下载镜像与软件以及网络环境没问题，那么应该不会有太大问题问题(&lt;strong&gt;可忽略&lt;/strong&gt;)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Linux
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;校验镜像，使用sha1sum生成SHA1校验码&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sha1sum 2014-09-09-wheezy-raspbian.img 
 57a73544fab3f1163a14903647e55c3998bf9dc9  2014-09-09-wheezy-raspbian.img  
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;查看你的SD卡的准确位置，并确定是否挂载分区&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ df -h
 Filesystem      Size  Used Avail Use% Mounted on
 /dev/sda1       103G   37G   61G  38% /
 none            4.0K     0  4.0K   0% /sys/fs/cgroup
 udev            2.0G   12K  2.0G   1% /dev
 tmpfs           393M  1.3M  392M   1% /run
 none            5.0M     0  5.0M   0% /run/lock
 none            2.0G   58M  1.9G   3% /run/shm
 none            100M   40K  100M   1% /run/user
 /dev/sde2       3.6G  1.2G  2.4G  30% /media/mwumli/12C-3244-2342
 /dev/sde1		4.2G	0G	0G	   0% /media/mwumli/43C-2334-4354
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如果挂载，请先卸载所有分区，以免发生错误&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ umount /dev/sde1
 $ umount /dev/sde2
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;dd&lt;/code&gt;写入镜像&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo dd bs=1M if=2014-09-09-wheezy-raspbian.img of=/dev/sde 
 [sudo] password for mwumli:
 3125+0 records in
 3125+0 records out
 3276800000 bytes (3.3 GB) copied, 406.802 s, 8.1 MB/s
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;访问&quot;&gt;访问&lt;/h3&gt;
&lt;p&gt;把写好的SD卡插入树莓派卡槽，连接上电源&lt;/p&gt;

&lt;h4 id=&quot;和正常计算机一样访问&quot;&gt;和正常计算机一样访问&lt;/h4&gt;
&lt;p&gt;为树莓派配上显示器和键盘，鼠标，这样就和正常的计算机一样访问了   &lt;br /&gt;
但要注意的是USB接口在B2.0上只有两个，就算B+也只有4个  &lt;br /&gt;
同时还要注意电压不足的问题，这个问题好解决，买一个可以接入外接电源的USB集线器&lt;/p&gt;

&lt;h4 id=&quot;通过ssh远程访问&quot;&gt;通过ssh远程访问&lt;/h4&gt;
&lt;p&gt;Debian Wheezy系统默认已经开启ssh服务，所以我们可以通过ssh进行远程访问，对于很多操作，那已足够&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ssh pi@192.168.199.244
pi@192.168.199.244's password: 
Linux raspberrypi 3.12.28+ #709 PREEMPT Mon Sep 8 15:28:00 BST 2014 armv6l

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Sat Dec  6 23:08:25 2014 from mwumli-k43sa.lan
pi@raspberrypi ~ $ whoami
pi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;一些必要的小贴士&quot;&gt;一些必要的小贴士&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;用户名为&lt;code class=&quot;highlighter-rouge&quot;&gt;pi&lt;/code&gt;,密码为&lt;code class=&quot;highlighter-rouge&quot;&gt;raspberry&lt;/code&gt;  &lt;br /&gt;
Debian Wheezy提供一个默认的用户名&lt;code class=&quot;highlighter-rouge&quot;&gt;pi&lt;/code&gt;和密码&lt;code class=&quot;highlighter-rouge&quot;&gt;raspberry&lt;/code&gt;(据说很久之前密码是&lt;code class=&quot;highlighter-rouge&quot;&gt;suse&lt;/code&gt;,假如你足够幸运)  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;raspberry&lt;/code&gt;不是一个很好的密码，因为很多地区的键盘布局并没有设置&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;(德国)，假如你是在国外，那么你可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;raspberrz&lt;/code&gt;来登录&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取你的Raspberry Pi的IP   &lt;br /&gt;
请保证树莓派连接上网络，然后&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;你可以在路由器后台中查看你的树莓派的IP&lt;/li&gt;
      &lt;li&gt;你可以在Windows下使用&lt;a href=&quot;http://abel.oss.aliyuncs.com/file/PortScan.zip&quot; title=&quot;一款Windows下的端口扫描工具&quot;&gt;PortScan&lt;/a&gt;去查看,它会列出当前局域网内所有主机&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;你可以在Linux下使用&lt;code class=&quot;highlighter-rouge&quot;&gt;nmap&lt;/code&gt;&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ nmap -sP 192.168.199.0/24  
  Starting Nmap 6.40 ( http://nmap.org ) at 2014-12-07 08:51 CST
  Nmap scan report for Hiwifi.lan (192.168.199.1)
  Host is up (0.39s latency).
  Nmap scan report for mwumli-K43SA.lan (192.168.199.104)
  Host is up (0.00036s latency).
  Nmap scan report for MI2A-xiaomishouji.lan (192.168.199.137)
  Host is up (0.64s latency).
  Nmap scan report for android-e54569f466270a09.lan (192.168.199.226)
  Host is up (0.34s latency).
  Nmap scan report for raspberrypi.lan (192.168.199.244)
  Host is up (0.016s latency).
  Nmap done: 256 IP addresses (5 hosts up) scanned in 14.32 seconds
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体可参考&lt;a href=&quot;http://www.jbxue.com/LINUXjishu/10514.html&quot; title=&quot;Linux 查看局域网内所有主机IP和MAC的方法&quot;&gt;Linux 查看局域网内所有主机IP和MAC的方法&lt;/a&gt;  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;nmap&lt;/code&gt;的介绍可以参考&lt;a href=&quot;http://nmap.org/man/zh/&quot; title=&quot;Nmap的Man手册&quot;&gt;Nmap参考指南&lt;/a&gt;  &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;nmap&lt;/code&gt;的使用介绍可以参考&lt;a href=&quot;http://netsecurity.51cto.com/art/200801/63660.htm&quot; title=&quot;端口扫描工具nmap使用介绍&quot;&gt;端口扫描工具namp的使用介绍&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;使用vnc远程图形化访问&quot;&gt;使用VNC远程图形化访问&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Raspberry Pi安装VNC Server&lt;code class=&quot;highlighter-rouge&quot;&gt;tightvncserver&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo apt-get install tightvncserver  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;vncpasswd&lt;/code&gt;设置登录密码和一个view-only密码&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ vncpasswd
 You will require a password to access your desktops.

 Password: 
 Verify:   
 Would you like to enter a view-only password (y/n)? n view-only密码仅仅用来查看，所以可以不设置  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启用VNC Server&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ tightvncserver
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在初次启动时，会提示步骤2的过程，之后就不会再提示  &lt;br /&gt;
每启动一次，就会建立一个虚拟屏幕，那个&lt;code class=&quot;highlighter-rouge&quot;&gt;:n&lt;/code&gt;后面的数字n就是虚拟屏幕ID，我们使用VNC Client连接时需要&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在你的计算机中使用VNC Client,客户端很多
    &lt;ul&gt;
      &lt;li&gt;安装chrome浏览器，使用VNC Viewer for Google Chrome插件&lt;/li&gt;
      &lt;li&gt;在这里下在&lt;a href=&quot;https://www.realvnc.com/download/&quot; title=&quot;一个VNC Software站点&quot;&gt;https://www.realvnc.com/download/&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Linux下可以通过命令安装&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ sudo apt-get install vncviewer xtightvncviewer  
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用VNC客户端连接VNC服务端需要两个参数:&lt;code class=&quot;highlighter-rouge&quot;&gt;Pi的IP地址和屏幕的端口地址&lt;/code&gt;  &lt;br /&gt;
VNC端口地址：&lt;code class=&quot;highlighter-rouge&quot;&gt;基础端口(默认5900)+屏幕ID&lt;/code&gt;   &lt;br /&gt;
如果Pi的iP地址为:&lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.199.227&lt;/code&gt;，屏幕ID为:&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;  &lt;br /&gt;
那么在Linux下可以这样访问:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ xtightvncviewer 192.168.199.227:5901
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于基础端口一般默认为5901,所以我们直接通过屏幕ID访问&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ xtightvncviewer 192.168.199.227:1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其他客户端访问一样，在输入地址区域输入:&lt;code class=&quot;highlighter-rouge&quot;&gt;Pi's IP:[base port]+Screen ID&lt;/code&gt;   &lt;br /&gt;
然后选择连接即可&lt;/p&gt;

&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;
&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;raspi-config&lt;/code&gt;进行一些重要的系统配置  &lt;br /&gt;
主要是设置合适的区域以及扩展其可用存储空间&lt;/p&gt;

&lt;p&gt;&lt;em&gt;扩展文件系统到SD卡所有空间&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo raspi-config 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;好了出现一个命令行设置界面，选择第一项&lt;code class=&quot;highlighter-rouge&quot;&gt;Expand Filesystem&lt;/code&gt;,设置完毕，然后重启即可生效&lt;/p&gt;

&lt;p&gt;Raspberry镜像在整个系统中只占用2G空间，即用户8G的SD卡，也只能被使用2G空间，那么一些大的软件将无法安装&lt;/p&gt;

&lt;p&gt;&lt;em&gt;设置区域&lt;/em&gt;   &lt;br /&gt;
每个地区的语言环境不一样，造成我们使用的键盘布局不一样，排序方法不一样，设置合适的区域，便于我们操作  &lt;br /&gt;
而且各个地方的时间并不一致，难道你想坐在大白天看的时间凌晨一点吗?&lt;/p&gt;

&lt;p&gt;当然，假如你有此癖好，就请忽略&lt;/p&gt;

&lt;p&gt;&lt;em&gt;其他设置&lt;/em&gt;  &lt;br /&gt;
按你的需求吧&lt;/p&gt;

&lt;h3 id=&quot;更换软件源&quot;&gt;更换软件源&lt;/h3&gt;
&lt;p&gt;树莓派的服务器在国外，在国内访问可能有点慢，额，应该很慢，还有些东西可能因为土啬的原因还下载不了  &lt;br /&gt;
还好Raspberry Pi官方提供了一个镜像列表:&lt;a href=&quot;http://www.raspbian.org/RaspbianMirrors&quot; title=&quot;树莓派软件源列表&quot;&gt;http://www.raspbian.org/RaspbianMirrors&lt;/a&gt;  &lt;br /&gt;
就近原则选择更换吧&lt;/p&gt;

&lt;p&gt;编辑&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/apt/sources.list&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#deb http://mirrordirector.raspbian.org/raspbian/ wheezy main contrib non-free rpi
deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ wheezy main contrib non-free rpi 
deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ wheezy main non-free contrib rpi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;保存，更新软件源&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我注释了旧的软件源，添加一个中国的软件源&lt;/p&gt;

&lt;p&gt;对咯，使用上面地址打开的是一个目录，然后我们需要进入当前目录的&lt;code class=&quot;highlighter-rouge&quot;&gt;dists&lt;/code&gt;,然后可以看到&lt;code class=&quot;highlighter-rouge&quot;&gt;wheezy&lt;/code&gt;目录,进入&lt;code class=&quot;highlighter-rouge&quot;&gt;wheezy&lt;/code&gt;就可以看到&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;contrib&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;non-free&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;rpi&lt;/code&gt;目录,每一个软件源的目录结构都是这样的，所以其他软件源的添加都这样办即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deb http-address wheezy main contrib non-free rpi 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;配置自动连接你的局域网&quot;&gt;配置自动连接你的局域网&lt;/h3&gt;
&lt;p&gt;修改/etc/network/interfaces,原内容如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auto lo 

iface lo inet loopback
iface eth0 inet dhcp

allow-hotplug wlan0
iface wlan0 inet manual
wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf
iface default inet dhcp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改如下:&lt;/p&gt;

&lt;p&gt;#使用localhost&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auto lo

iface lo inet loopback
iface eth0 inet dhcp

allow-hotplug wlan0 #表示wlan0设备可以热插拔
iface wlan0 inet dhcp
wpa-ssid your-wifi-ssid
wpa-psk your-wifi-passwd

iface default inet dhcp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;OKay，以后就会自动连接上你的wifi，假如存在&lt;/p&gt;

&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;p&gt;刚看到树莓派的时候，就一块布满电路的板子，瞬间有点懵，天生对电路过敏&lt;/p&gt;

&lt;p&gt;但事实上，关于电路的部分，人家已经为你封装好了(&lt;strong&gt;多好的思想,感谢面向对象&lt;/strong&gt;),你只需要会一点软件的知识，痛快的玩就可以了&lt;/p&gt;

&lt;p&gt;文章很长，但还是觉得不够，很多东西还没讲到，但这些应该已经足够&lt;/p&gt;

&lt;p&gt;装系统其实只花费了一小会儿，而写文章却用了4个小时&lt;/p&gt;

&lt;p&gt;希望玩的愉快!…&lt;/p&gt;

</description>
                <link>/%E8%AE%B0%E5%BD%95/2014/12/06/raspberrypi-install/</link>
                <guid>/%E8%AE%B0%E5%BD%95/2014/12/06/raspberrypi-install</guid>
                <pubDate>Sat, 06 Dec 2014 00:00:00 -0600</pubDate>
        </item>


</channel>
</rss>
