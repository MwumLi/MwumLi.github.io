<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>微尘</title>
        <description>微尘 - Liluo</description>
        <link>http://mwumli.github.io</link>
        <link>http://mwumli.github.io</link>
        <lastBuildDate>2015-08-17T09:18:46+00:00</lastBuildDate>
        <pubDate>2015-08-17T09:18:46+00:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>用tmux保存工作现场</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-&quot; id=&quot;markdown-toc-tmux-&quot;&gt;tmux 是什么?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux--1&quot; id=&quot;markdown-toc-tmux--1&quot;&gt;tmux 的任务会话机制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux&quot; id=&quot;markdown-toc-tmux&quot;&gt;安装 tmux&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-session&quot; id=&quot;markdown-toc-tmux-session&quot;&gt;tmux session&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-window&quot; id=&quot;markdown-toc-tmux-window&quot;&gt;tmux window&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#window&quot; id=&quot;markdown-toc-window&quot;&gt;创建 window&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#window-1&quot; id=&quot;markdown-toc-window-1&quot;&gt;切换 window&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;重命名当前窗口&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-pane&quot; id=&quot;markdown-toc-tmux-pane&quot;&gt;tmux pane&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux--2&quot; id=&quot;markdown-toc-tmux--2&quot;&gt;tmux 的复制&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#copy--&quot; id=&quot;markdown-toc-copy--&quot;&gt;Copy 模式下的复制, 然后粘贴&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;复制&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;粘贴&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#copy-&quot; id=&quot;markdown-toc-copy-&quot;&gt;推荐使用 Copy 模式&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux--3&quot; id=&quot;markdown-toc-tmux--3&quot;&gt;tmux 的配置文件&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;配置文件生效&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux--4&quot; id=&quot;markdown-toc-tmux--4&quot;&gt;一个简单的 tmux 配置文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;自动生成布局&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux--5&quot; id=&quot;markdown-toc-tmux--5&quot;&gt;tmux 在远程服务器中的表现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;结对编程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux--6&quot; id=&quot;markdown-toc-tmux--6&quot;&gt;tmux 小技巧&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux--command-prompt&quot; id=&quot;markdown-toc-tmux--command-prompt&quot;&gt;tmux 的 command-prompt&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux--7&quot; id=&quot;markdown-toc-tmux--7&quot;&gt;tmux 快捷键帮助&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#send-prefix&quot; id=&quot;markdown-toc-send-prefix&quot;&gt;重新绑定 send-prefix&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux--8&quot; id=&quot;markdown-toc-tmux--8&quot;&gt;tmux 底部状态栏&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;显示钟表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#pane----&quot; id=&quot;markdown-toc-pane----&quot;&gt;为 pane 显示编号—快速切换&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-1&quot; id=&quot;markdown-toc-tmux-1&quot;&gt;使用tmux的一些问题&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux--vimpowerline&quot; id=&quot;markdown-toc-tmux--vimpowerline&quot;&gt;tmux 和 vim的powerline插件&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;一些自言自语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tmux-&quot;&gt;tmux 是什么?&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;tmux&lt;/code&gt; 是一款非常好用的终端复用器&lt;/p&gt;

&lt;p&gt;可以认为是终端分屏软件，但远远不止…&lt;br /&gt;
可以认为是 &lt;code&gt;nohup&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 的结合体，但远远不止…&lt;br /&gt;
可以认为是一款结对编程 ( Pair Programming ) 的软件，但远远不止…&lt;/p&gt;

&lt;p&gt;是的，远远不止…&lt;/p&gt;

&lt;p&gt;不知道怎么去描述，且跟随使用去体会吧&lt;/p&gt;

&lt;h2 id=&quot;tmux--1&quot;&gt;tmux 的任务会话机制&lt;/h2&gt;

&lt;p&gt;当你运行 &lt;code&gt;tmux&lt;/code&gt; 之后，会启动一个 tmux server 来管理 tmux 的 sessions&lt;/p&gt;

&lt;p&gt;tmux server 有且仅有一个，并且在第一个 session 创建时启动， 当最后一个 session 销毁时销毁&lt;/p&gt;

&lt;p&gt;然后有以下几条规则:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个 tmux server 可以有多个 sessions&lt;/li&gt;
  &lt;li&gt;一个 session 可以有多个 window ， 类似终端有多个标签页&lt;/li&gt;
  &lt;li&gt;一个 window 可以有多个 pane, 即分屏&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;session&lt;/code&gt; 可译作 &lt;code&gt;会话&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;window&lt;/code&gt; 可译作 &lt;code&gt;窗口&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;pane&lt;/code&gt; 可译作 &lt;code&gt;窗格&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;tmux&quot;&gt;安装 tmux&lt;/h2&gt;

&lt;p&gt;Ubuntu下安装:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install tmux
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;tmux-session&quot;&gt;tmux session&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;快速创建:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;这样创建的 session 被自动用数字命名&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个命名的 session :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux new-session -s session-name
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看当前所有的 sessions :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux list-sessions
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;脱离当前 session : &lt;code&gt;ctrl-b + d&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;脱离当前 session , 你的工作状态依然保留&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果想重新进入之前的 session , 只需:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux attach-session -t session-name
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;这样你又回看到你之前的工作进度了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当你想退出当前 session :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 在终端中输入 `exit`, 直到所有的 window 和 pane 被关闭  
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;这时，你的 session 也被销毁了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;杀死指定的 session :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux kill-session -t session-name
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重命名 session : &lt;code&gt;ctrl-b + $&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;杀死所有的 session :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux kill-server
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;因为所有的 sessions 跑在一个 server 上&lt;br /&gt;
所以只要关掉 tmux server 即可&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;tmux-window&quot;&gt;tmux window&lt;/h2&gt;

&lt;h3 id=&quot;window&quot;&gt;创建 window&lt;/h3&gt;

&lt;p&gt;当你创建一个 session 时，也自动创建一个 window , window 中也会自动创建一个 pane&lt;/p&gt;

&lt;p&gt;在 session 中创建 window :  按下&lt;code&gt;ctrl-b +c&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;window-1&quot;&gt;切换 window&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;切换到下一个窗口 : &lt;code&gt;ctrl-b + n&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切换到上一个窗口 : &lt;code&gt;ctrl-b + p&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切换到num窗口，num为窗口编号，底部状态栏可看到 : &lt;code&gt;ctrl-b + num&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示当前会话的所有窗口 : &lt;code&gt;ctrl-b + w&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭当前窗口 : &lt;code&gt;ctrl-b + &amp;amp;&lt;/code&gt; 或者 &lt;code&gt;exit&lt;/code&gt; 或者 &lt;code&gt;ctrl + d&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section&quot;&gt;重命名当前窗口&lt;/h3&gt;

&lt;p&gt;按下 &lt;code&gt;ctrl-b + ,&lt;/code&gt;&lt;br /&gt;
然后输入 window-name 即可&lt;/p&gt;

&lt;h2 id=&quot;tmux-pane&quot;&gt;tmux pane&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;分割一个垂直的窗格 : &lt;code&gt;ctrl-b + &quot;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分割一个水平的窗格 : &lt;code&gt;ctrl-b + %&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;移动到其他窗格 : &lt;code&gt;ctrl-b + Arrow-Up/Down/Left/Right&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭所有窗格 : &lt;code&gt;ctrl-b + !&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tmux--2&quot;&gt;tmux 的复制&lt;/h2&gt;

&lt;p&gt;在没有启动鼠标滚轮时， tmux 可以通过鼠标选中，并复制&lt;/p&gt;

&lt;p&gt;当你用了上面配置文件中的鼠标滚轮启用，那么一般的鼠标选中就不可能了:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;按下 shift, 然后使用鼠标去选中想要copy的内容进行复制操作  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;copy--&quot;&gt;Copy 模式下的复制, 然后粘贴&lt;/h3&gt;

&lt;p&gt;tmux 提供了一种 copy 模式,类似于 vim 的(Esc-v)模式&lt;/p&gt;

&lt;p&gt;按下 &lt;code&gt;ctrl-b + [&lt;/code&gt; 进入 copy 模式&lt;/p&gt;

&lt;p&gt;tmux 的 copy 模式下有两种快捷键模式: vim 和 Emacs&lt;br /&gt;
当你在配置文件中启用 vim 模式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setw -g mode-keys vi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 copy 模式下， 我们就可以使用 &lt;code&gt;j/k/h/l&lt;/code&gt; 来移动光标了&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;复制&lt;/h4&gt;

&lt;p&gt;在 Copy 模式下，我们这样复制:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;移动光标到复制开始位置&lt;/li&gt;
  &lt;li&gt;按下 &lt;code&gt;Space&lt;/code&gt; 键进入复制模式&lt;/li&gt;
  &lt;li&gt;移动光标选择要复制的内容&lt;/li&gt;
  &lt;li&gt;按下 &lt;code&gt;Enter&lt;/code&gt; 键完成复制&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-2&quot;&gt;粘贴&lt;/h4&gt;

&lt;p&gt;到你要粘贴内容的位置， 使用快捷键 &lt;code&gt;ctrl-b + ]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;刚才复制的内容已经被完美粘贴了&lt;/p&gt;

&lt;h3 id=&quot;copy-&quot;&gt;推荐使用 Copy 模式&lt;/h3&gt;

&lt;p&gt;如果你只是想复制不超过一行文字，那么这两种方式均可，甚至第一种方式更有效率&lt;/p&gt;

&lt;p&gt;如果你想复制多行文本，那么还是使用Copy 模式&lt;/p&gt;

&lt;p&gt;这和 tmux 的实现方式有关,具体请自行探讨&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tmux--3&quot;&gt;tmux 的配置文件&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;配置文件生效&lt;/h3&gt;

&lt;p&gt;配置文件生效有两种方式:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;新建一个 session, &lt;code&gt;.tmux.conf&lt;/code&gt; 中的设置就在此 session 中生效了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在当前 session 中，按下 &lt;code&gt;ctrl-b + :&lt;/code&gt;,然后:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; : source-file ~/.tmux.conf
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;code&gt;.tmux.conf&lt;/code&gt;是 tmux 配置文件的命名，默认位于你的用户主目录下&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;tmux--4&quot;&gt;一个简单的 tmux 配置文件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# This is a tmux configure file
# 取消默认Ctrl+b的前缀绑定，绑定Ctrl+a为新的快捷发送前缀方式
unbind C-o
set -g prefix C-a

# Copy模式下使用vim快捷操作方式
setw -g mode-keys vi

# split window with s/v after C-a
bind s split-window -h
bind v split-window -v

# move into left/Down/Up/Right panes with h/j/k/l after C-a
bind h select-pane -L
bind j select-pane -D
bind k select-pane -U
bind l select-pane -R

# resize panes forward left/right/Down/Up with &amp;lt;/&amp;gt;/-/+ after C-a
bind &amp;lt; resize-pane -L 10
bind &amp;gt; resize-pane -R 10
bind - resize-pane -D 10
bind + resize-pane -U 10

# bind : to command-prompt like vim
# this is the defalut in tmux already
bind : command-prompt

#鼠标可以选中窗格
set-option -g mouse-select-pane on  
#鼠标滚轮可以使用
set-window-option -g mode-mouse on  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;自动生成布局&lt;/h3&gt;

&lt;p&gt;新建一个文件 &lt;code&gt;~/.tmux/mylayout&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;selectp -t 0 #选中第0个窗格
splitw -h -p 50 #将其分成左右两个
selectp -t 1 #选中第一个，也就是右边那个
splitw -v -p 50 #将右边那个分成上下两个
selectp -t 0 #选中第一个
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在 &lt;code&gt;.tmux.conf&lt;/code&gt;	后面添加:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind D source-file ~/.tmux/mylayout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，每次当我们启动 tmux 后， 可以使用 &lt;code&gt;ctrl-b + D&lt;/code&gt; 来生成布局&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tmux--5&quot;&gt;tmux 在远程服务器中的表现&lt;/h2&gt;

&lt;p&gt;如果通过 &lt;code&gt;ssh&lt;/code&gt; 远程登录到服务器，恰好要进行一个很耗时的任务&lt;/p&gt;

&lt;p&gt;我们不可能等待这个任务执行完毕，再去做其他工作&lt;/p&gt;

&lt;p&gt;因此，我们选择了启用一个新的终端来完成其他工作&lt;/p&gt;

&lt;p&gt;但是网络可能很不稳定，你那个耗时任务在执行过程，突然网络掉线，然后，你的 ssh 断掉，然后你的任务挂掉了&lt;/p&gt;

&lt;p&gt;但是我们的任务已经进行了80%，功亏一篑&lt;/p&gt;

&lt;p&gt;是的，你可以选择执行任务时，采用 &lt;code&gt;nohup&lt;/code&gt; ，那样，网络断掉，也不会影响你的任务&lt;/p&gt;

&lt;p&gt;但是你永远也回不到 &lt;em&gt;案发现场&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;案发现场&lt;/em&gt; 在某些情况下很重要&lt;/p&gt;

&lt;p&gt;而且费那么多心思在保证任务完成，现场保留上，实在太浪费了&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;tmux&lt;/code&gt; 完全可以解决这个问题，除非远程服务器挂了&lt;/p&gt;

&lt;p&gt;因此，远程工作的正确方式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh pi@192.168.199.114 
...
Last login: Tue May  5 02:37:14 2015 from 192.168.199.104
pi@raspberrypi ~ $ tmux new-session -s code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，你可在 session 中进行分屏来完成其他工作&lt;br /&gt;
或者你可以脱离终端， 继续其他操作&lt;br /&gt;
再或者网络中断，当你重新连接上服务器:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
Last login: Tue May  5 02:37:14 2015 from 192.168.199.104
pi@raspberrypi ~ $ tmux a -t code
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你会发现，哦，我的工作现场依旧完整无缺…&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;结对编程&lt;/h2&gt;

&lt;p&gt;关于结对编程的概念，可以查看维基百科:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://zh.wikipedia.org/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tmux 利用服务器上的同一账户的同一 tmux session 实现的&lt;/p&gt;

&lt;p&gt;两个人打开同一个 tmux session, 一个人所做的改变，会即时的反映到另一个人的终端上&lt;/p&gt;

&lt;p&gt;tmux 基于文本， 所以即使网速慢点也无妨&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tmux--6&quot;&gt;tmux 小技巧&lt;/h2&gt;

&lt;h3 id=&quot;tmux--command-prompt&quot;&gt;tmux 的 command-prompt&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;command-prompt&lt;/code&gt; 是用来输入 tmux 命令的&lt;/p&gt;

&lt;p&gt;tmux 的所有快捷键的功能都是通过命令来实现的&lt;/p&gt;

&lt;p&gt;因此，我们也通过键入命令来实现某种功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;按下 ctrl-b + : 即可打开 command-prompt  
然后，你输入相应命令即可  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;tmux--7&quot;&gt;tmux 快捷键帮助&lt;/h3&gt;

&lt;p&gt;tmux 的快捷键由 send-prefix 和 bind-key 组成&lt;/p&gt;

&lt;p&gt;按下 send-prefix 的同时，按下 bind-key 才唤醒相应的快捷功能&lt;/p&gt;

&lt;p&gt;&lt;code&gt;send-prefix&lt;/code&gt; 是固定的，默认是 &lt;code&gt;ctrl-b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bind-key&lt;/code&gt; 对应不同的功能绑定了不同的 key, 可以通过以下方式查看:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;按下 `ctrl-b + ?`  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;send-prefix&quot;&gt;重新绑定 send-prefix&lt;/h3&gt;

&lt;p&gt;更换 send-prefix 为 &lt;code&gt;ctrl-a&lt;/code&gt; ,在 tmux 的配置文件(&lt;code&gt;.tmux.conf&lt;/code&gt;)中这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unbind C-b
set -g prefix C-a
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;tmux--8&quot;&gt;tmux 底部状态栏&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;tmux 窗口底部就是状态栏&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;状态栏左边显示 session-name ,并且列出当前所有 window-name ,以及所有 window 当前运行的 process-name&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当前所在 window 旁边会有 &lt;code&gt;*&lt;/code&gt; 提示&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;右边会显示主机名和时间&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;显示钟表&lt;/h3&gt;

&lt;p&gt;按下 &lt;code&gt;ctrl-b + t&lt;/code&gt;, 会在当前 window 的当前 pane 显示当前时间&lt;/p&gt;

&lt;h3 id=&quot;pane----&quot;&gt;为 pane 显示编号—快速切换&lt;/h3&gt;

&lt;p&gt;按下 &lt;code&gt;ctrl-b + q&lt;/code&gt;, 每一个 pane 都会出现一个数字&lt;br /&gt;
按下想要切换的 pane 显示的数字， 就可以切换到那个 pane&lt;/p&gt;

&lt;h2 id=&quot;tmux-1&quot;&gt;使用tmux的一些问题&lt;/h2&gt;

&lt;h3 id=&quot;tmux--vimpowerline&quot;&gt;tmux 和 vim的powerline插件&lt;/h3&gt;

&lt;p&gt;默认情况下，启动vim, 如果使用了 powerline 插件， 那么会发现颜色显示不正常&lt;/p&gt;

&lt;p&gt;此时，只要你在每次打开 tmux 时启动256色即可，即 &lt;code&gt;tmux -2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们可以在 &lt;code&gt;.bashrc&lt;/code&gt; 末尾添加:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias tmux=&#39;tmux -2&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，每次使用 tmux 就会很方便啦&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-7&quot;&gt;一些自言自语&lt;/h2&gt;

&lt;p&gt;任何时候不要太过迷信一件东西&lt;/p&gt;

&lt;p&gt;你知道的, 服务器也会有重启的时候&lt;/p&gt;

&lt;p&gt;及时保存你的编辑，及时提交你的修改，即使备份你的收藏，永远是明智的做法&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/%E8%BD%AF%E4%BB%B6/2015/05/05/tmux</link>
                <guid>http://mwumli.github.io/%E8%BD%AF%E4%BB%B6/2015/05/05/tmux</guid>
                <pubDate>2015-05-05T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>离去</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;实习&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;前端的进步&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;离去&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;回家&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;离职咯，嘿嘿，不要误会，只是实习期结束了…&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;实习&lt;/h2&gt;

&lt;p&gt;实习这段时间，我的工作主要是前端方面的(喂，是不是搞错了，我面的是后台呀…)&lt;/p&gt;

&lt;p&gt;对于此，我郁闷好一会儿。&lt;br /&gt;
不过，未来的学习计划安排有前端，所以也就提前让它生长发芽吧&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;前端的进步&lt;/h3&gt;

&lt;p&gt;同事中有位大哥，前端很厉害，指导了我很多&lt;/p&gt;

&lt;p&gt;之前接触过一些前端 : 基础知识很简单( HTML/CSS/JS ),但是简单也意味着，在某些方面会比较麻烦，比如页面布局，比如网站框架设计&lt;/p&gt;

&lt;p&gt;前端学习阶梯:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;HTML/CSS/JS，基础知识，很必要&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JQuery 的使用 — 这是一门很流行的js框架，我想学习它，非常必要&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bootstrap 的使用 — 想要快速开发一个响应式网站，那么学习它&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;与后台数据交互和Ajax — 与后台进行数据交互，这是一个必备技能，使用Ajax，也是必备技能&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JS的原型链继承，很重要, 这对学习框架设计(如果你只想写些效果，按照已有的框架设计，那就…)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;看源码 — 研究一下比较流行的插件源码吧,仅仅看书学习,不仅枯燥，而且你的知识只会碎片化&lt;br /&gt;
 看源码,永远是最有效的学习方式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写插件 — 你已经学会原型链继承，也吸收了高手们开发插件的经验，那么开始写吧(有想法的时候)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;寻找机会 — 等待一个合适机会，从一个最基本的网站进行构建&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;快速编写 — less,sass,coffeescript …&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nodejs…&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;应该还有很多，目前就只了解到这里&lt;br /&gt;
以上这些，有些顺序可以提前，学习本无先后，有所需，就得学…
我也并没有完全掌握这些知识，但是要想成为一个真正的前端，这些步骤时必须的&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;离去&lt;/h2&gt;

&lt;p&gt;下雨了，没想到离去的时候，竟然会下雨&lt;/p&gt;

&lt;p&gt;长安也下雨了&lt;/p&gt;

&lt;p&gt;“青山一道同云雨，明月何曾是两乡”&lt;/p&gt;

&lt;p&gt;最后，再见，帝都…&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;回家&lt;/h2&gt;

&lt;p&gt;我要回来了&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/%E6%83%85%E7%BB%AA/2015/05/01/leave-beijing</link>
                <guid>http://mwumli.github.io/%E6%83%85%E7%BB%AA/2015/05/01/leave-beijing</guid>
                <pubDate>2015-05-01T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>Linux下php扩展安装</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;碎碎念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#php&quot; id=&quot;markdown-toc-php&quot;&gt;检验php是否安装某个扩展&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;没有搜索到扩展&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#php-1&quot; id=&quot;markdown-toc-php-1&quot;&gt;安装并添加php扩展&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;几个扩展安装案例&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#redis-redis-github&quot; id=&quot;markdown-toc-redis-redis-github&quot;&gt;redis 扩展的安装&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#mongo-&quot; id=&quot;markdown-toc-mongo-&quot;&gt;mongo 扩展的安装&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;待续…&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;安装需要&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#phpize-&quot; id=&quot;markdown-toc-phpize-&quot;&gt;phpize 的安装&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;碎碎念&lt;/h2&gt;

&lt;p&gt;进行简单的 web 动态网站开发，只需快速搭建一个 LAMP 环境即可&lt;/p&gt;

&lt;p&gt;但有的时候还需要一些特别的功能，这时候需要安装相应扩展&lt;sup id=&quot;fnref:extension&quot;&gt;&lt;a href=&quot;#fn:extension&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;这里以 LAMP&lt;sup id=&quot;fnref:LAMP&quot;&gt;&lt;a href=&quot;#fn:LAMP&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; 环境为例&lt;/p&gt;

&lt;h2 id=&quot;php&quot;&gt;检验php是否安装某个扩展&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;检验你某个扩展是否安装，可以在你的 Apache 目录下新建文件 &lt;code&gt;phpinfo.php&lt;/code&gt; :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;?php
     phpinfo();
 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;访问此网页，使用浏览器查找功能查找你的扩展，比如 &lt;code&gt;redis&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你的扩展已经安装成功，并添加到 php 的 apache 配置文件，那么就会搜索到&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-1&quot;&gt;没有搜索到扩展&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;重启了下服务器: &lt;code&gt;sudo service apache2 restart&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;检查配置文件 &lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt; 是否正确添加扩展&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可能没有安装成功，请检查网络，请百度，请谷歌…&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;php-1&quot;&gt;安装并添加php扩展&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载并安装下载相应扩展(请自行搜索)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; http://php.net/manual/zh/extensions.php  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加扩展到配置文件&lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt;&lt;br /&gt;
 (以&lt;code&gt;redis&lt;/code&gt;为例)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [redis]
 extension=redis.so
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;添加文件末尾即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo service apache2 restart
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;几个扩展安装案例&lt;/h3&gt;

&lt;h4 id=&quot;redis-redis-github&quot;&gt;redis 扩展的安装&lt;sup id=&quot;fnref:redis-github&quot;&gt;&lt;a href=&quot;#fn:redis-github&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用git下载&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ git clone https://github.com/phpredis/phpredis.git
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编译扩展模块,需要&lt;code&gt;phpize&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ phpize
 $ ./configure [--enable-redis-igbinary]
 $ make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样 redis 就被安装在合适的位置&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;添加扩展到配置文件&lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [redis]                            
 extension=redis.so
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;mongo-&quot;&gt;mongo 扩展的安装&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载，编译，安装，查看:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ git clone https://github.com/mongodb/mongo-php-driver.git
 $ cd mongo-php-driver
 $ phpize
 $ ./configure
 $ sudo make install
 ...
 Installing shared extensions:     
 /usr/lib/php5/20121212+lfs/
 $ ls /usr/lib/php5/20121212+lfs/
 json.so   mysqli.so  opcache.so    pdo.so       redis.so
 mongo.so  mysql.so   pdo_mysql.so  readline.so
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;可以看到&lt;code&gt;mongo.so&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加配置 &lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt;:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [mongo.so]
 extension=mongo.so
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-3&quot;&gt;待续…&lt;/h4&gt;

&lt;h3 id=&quot;section-4&quot;&gt;安装需要&lt;/h3&gt;

&lt;h4 id=&quot;phpize-&quot;&gt;phpize 的安装&lt;/h4&gt;

&lt;p&gt;用 C 开发 PHP 扩展的时候如果用动态链接库的方式编译扩展模块，需要用到 &lt;code&gt;phpize&lt;/code&gt;&lt;br /&gt;
这个工具在使用 &lt;code&gt;apt-get install php5&lt;/code&gt; 默认情况也是没安装的&lt;br /&gt;
可以执行以下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install php5-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:extension&quot;&gt;
      &lt;p&gt;php扩展列表:&lt;a href=&quot;http://php.net/manual/zh/extensions.php&quot;&gt;http://php.net/manual/zh/extensions.php&lt;/a&gt; &lt;a href=&quot;#fnref:extension&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:LAMP&quot;&gt;
      &lt;p&gt;Linux+Apache+Mysql+Php, 安装请参考&lt;a href=&quot;/记录/2014/06/14/lamp-build/ LAMP环境搭建&quot;&gt;LAMP环境搭建&lt;/a&gt; &lt;a href=&quot;#fnref:LAMP&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:redis-github&quot;&gt;
      &lt;p&gt;可参考&lt;a href=&quot;https://github.com/phpredis/phpredis#installation&quot;&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;一篇来自github的安装指南-redis&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; &lt;a href=&quot;#fnref:redis-github&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2015/04/24/php-extension-install</link>
                <guid>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2015/04/24/php-extension-install</guid>
                <pubDate>2015-04-24T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>Raspberry Pi安装Debian Wheezy系统</title>
                <description>
&lt;h3 id=&quot;section&quot;&gt;碎碎念&lt;/h3&gt;

&lt;p&gt;Raspberry Pi，是一款基于Linux系统的、信用卡大小的单板机电脑&lt;br /&gt;
它的出现源于一个想&lt;strong&gt;制作一套启发孩子的电脑&lt;/strong&gt;的想法&lt;br /&gt;
看来一切美好的事情背后总是有一颗让人心动的理念，而这个理念往往才是他们获得流行的动力&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/imgs/640px-RaspberryPi.jpg&quot; alt=&quot;树莓派B2.0简图&quot; title=&quot;树莓派B2.0简图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;系统安装&lt;/h3&gt;
&lt;p&gt;可以用于Raspberry Pi的系统很多，有我们即将安装的Debian Wheezy,还有Arch Linux ARM, RISC OS等等&lt;br /&gt;
对咯，Debian Wheezy更为常见的称呼是Raspbian,但是为了避免与Raspberry Pix形似，我特意称其为Debian Wheezy,也喜欢这样称呼(嘿嘿…)&lt;br /&gt;
这些资源都可以送网络上获取，感谢互联网&lt;/p&gt;

&lt;p&gt;为树莓派安装系统很简单，开始咯&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先从&lt;a href=&quot;http://www.raspberrypi.org/downloads/&quot; title=&quot;RaspberryPi OS下载页&quot;&gt;树莓派官网下载页&lt;/a&gt;选择下载Debian Wheezy系统(第一个应该就是),这是树莓派专用系统&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;因为Raspberry Pi是从SD卡启动的(&lt;strong&gt;没有BIOS和其他内部存储设备，只有一个SD卡槽&lt;/strong&gt;)，所以我们需要准备一张SD卡,8G大小(&lt;strong&gt;更大更好，不过it depends&lt;/strong&gt;),把SD卡使用卡托或者读卡器接入你的计算机&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-2&quot;&gt;不同平台下的镜像写入&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Windows
    &lt;ol&gt;
      &lt;li&gt;请下载官方推荐工具&lt;a href=&quot;http://sourceforge.net/projects/win32diskimager/&quot; title=&quot;一个Windows下把原始数据写入可移动设备的工具&quot;&gt;Win32 Disk Imager&lt;/a&gt;，它是一款绿色软件，点击即可使用&lt;/li&gt;
      &lt;li&gt;运行软件，选择我们SD卡盘符，加载我们的Debian Wheezy镜像(&lt;strong&gt;像2014-09-09-wheezy-raspbian.img&lt;/strong&gt;)，最后点击”Write”,等待几分钟写入完成&lt;/li&gt;
      &lt;li&gt;哦，对了，在写入镜像前，你也可以校验镜像的完整性，可以使用&lt;code&gt;fciv&lt;/code&gt;命令生成SHA1校验码与网上公布的码值对比，如果一样，okay，没问题。不过假如你从官网下载镜像与软件以及网络环境没问题，那么应该不会有太大问题问题(&lt;strong&gt;可忽略&lt;/strong&gt;)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Linux
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;校验镜像，使用sha1sum生成SHA1校验码&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; $ sha1sum 2014-09-09-wheezy-raspbian.img 
 57a73544fab3f1163a14903647e55c3998bf9dc9  2014-09-09-wheezy-raspbian.img  
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;查看你的SD卡的准确位置，并确定是否挂载分区&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; $ df -h
 Filesystem      Size  Used Avail Use% Mounted on
 /dev/sda1       103G   37G   61G  38% /
 none            4.0K     0  4.0K   0% /sys/fs/cgroup
 udev            2.0G   12K  2.0G   1% /dev
 tmpfs           393M  1.3M  392M   1% /run
 none            5.0M     0  5.0M   0% /run/lock
 none            2.0G   58M  1.9G   3% /run/shm
 none            100M   40K  100M   1% /run/user
 /dev/sde2       3.6G  1.2G  2.4G  30% /media/mwumli/12C-3244-2342
 /dev/sde1		4.2G	0G	0G	   0% /media/mwumli/43C-2334-4354
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如果挂载，请先卸载所有分区，以免发生错误&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; $ umount /dev/sde1
 $ umount /dev/sde2
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用&lt;code&gt;dd&lt;/code&gt;写入镜像&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; $ sudo dd bs=1M if=2014-09-09-wheezy-raspbian.img of=/dev/sde 
 [sudo] password for mwumli:
 3125+0 records in
 3125+0 records out
 3276800000 bytes (3.3 GB) copied, 406.802 s, 8.1 MB/s
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;访问&lt;/h3&gt;
&lt;p&gt;把写好的SD卡插入树莓派卡槽，连接上电源&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;和正常计算机一样访问&lt;/h4&gt;
&lt;p&gt;为树莓派配上显示器和键盘，鼠标，这样就和正常的计算机一样访问了 &lt;br /&gt;
但要注意的是USB接口在B2.0上只有两个，就算B+也只有4个&lt;br /&gt;
同时还要注意电压不足的问题，这个问题好解决，买一个可以接入外接电源的USB集线器&lt;/p&gt;

&lt;h4 id=&quot;ssh&quot;&gt;通过ssh远程访问&lt;/h4&gt;
&lt;p&gt;Debian Wheezy系统默认已经开启ssh服务，所以我们可以通过ssh进行远程访问，对于很多操作，那已足够&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh pi@192.168.199.244
pi@192.168.199.244&#39;s password: 
Linux raspberrypi 3.12.28+ #709 PREEMPT Mon Sep 8 15:28:00 BST 2014 armv6l

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Sat Dec  6 23:08:25 2014 from mwumli-k43sa.lan
pi@raspberrypi ~ $ whoami
pi
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-5&quot;&gt;一些必要的小贴士&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;用户名为&lt;code&gt;pi&lt;/code&gt;,密码为&lt;code&gt;raspberry&lt;/code&gt;&lt;br /&gt;
Debian Wheezy提供一个默认的用户名&lt;code&gt;pi&lt;/code&gt;和密码&lt;code&gt;raspberry&lt;/code&gt;(据说很久之前密码是&lt;code&gt;suse&lt;/code&gt;,假如你足够幸运)&lt;br /&gt;
&lt;code&gt;raspberry&lt;/code&gt;不是一个很好的密码，因为很多地区的键盘布局并没有设置&lt;code&gt;y&lt;/code&gt;(德国)，假如你是在国外，那么你可以使用&lt;code&gt;raspberrz&lt;/code&gt;来登录&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取你的Raspberry Pi的IP &lt;br /&gt;
请保证树莓派连接上网络，然后&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;你可以在路由器后台中查看你的树莓派的IP&lt;/li&gt;
      &lt;li&gt;你可以在Windows下使用&lt;a href=&quot;http://abel.oss.aliyuncs.com/file/PortScan.zip&quot; title=&quot;一款Windows下的端口扫描工具&quot;&gt;PortScan&lt;/a&gt;去查看,它会列出当前局域网内所有主机&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;你可以在Linux下使用&lt;code&gt;nmap&lt;/code&gt;&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  $ nmap -sP 192.168.199.0/24  
  Starting Nmap 6.40 ( http://nmap.org ) at 2014-12-07 08:51 CST
  Nmap scan report for Hiwifi.lan (192.168.199.1)
  Host is up (0.39s latency).
  Nmap scan report for mwumli-K43SA.lan (192.168.199.104)
  Host is up (0.00036s latency).
  Nmap scan report for MI2A-xiaomishouji.lan (192.168.199.137)
  Host is up (0.64s latency).
  Nmap scan report for android-e54569f466270a09.lan (192.168.199.226)
  Host is up (0.34s latency).
  Nmap scan report for raspberrypi.lan (192.168.199.244)
  Host is up (0.016s latency).
  Nmap done: 256 IP addresses (5 hosts up) scanned in 14.32 seconds
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体可参考&lt;a href=&quot;http://www.jbxue.com/LINUXjishu/10514.html&quot; title=&quot;Linux 查看局域网内所有主机IP和MAC的方法&quot;&gt;Linux 查看局域网内所有主机IP和MAC的方法&lt;/a&gt;&lt;br /&gt;
&lt;code&gt;nmap&lt;/code&gt;的介绍可以参考&lt;a href=&quot;http://nmap.org/man/zh/&quot; title=&quot;Nmap的Man手册&quot;&gt;Nmap参考指南&lt;/a&gt;&lt;br /&gt;
&lt;code&gt;nmap&lt;/code&gt;的使用介绍可以参考&lt;a href=&quot;http://netsecurity.51cto.com/art/200801/63660.htm&quot; title=&quot;端口扫描工具nmap使用介绍&quot;&gt;端口扫描工具namp的使用介绍&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;vnc&quot;&gt;使用VNC远程图形化访问&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Raspberry Pi安装VNC Server&lt;code&gt;tightvncserver&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo apt-get install tightvncserver  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code&gt;vncpasswd&lt;/code&gt;设置登录密码和一个view-only密码&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ vncpasswd
 You will require a password to access your desktops.

 Password: 
 Verify:   
 Would you like to enter a view-only password (y/n)? n view-only密码仅仅用来查看，所以可以不设置  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启用VNC Server&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tightvncserver
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在初次启动时，会提示步骤2的过程，之后就不会再提示&lt;br /&gt;
每启动一次，就会建立一个虚拟屏幕，那个&lt;code&gt;:n&lt;/code&gt;后面的数字n就是虚拟屏幕ID，我们使用VNC Client连接时需要&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在你的计算机中使用VNC Client,客户端很多
    &lt;ul&gt;
      &lt;li&gt;安装chrome浏览器，使用VNC Viewer for Google Chrome插件&lt;/li&gt;
      &lt;li&gt;在这里下在&lt;a href=&quot;https://www.realvnc.com/download/&quot; title=&quot;一个VNC Software站点&quot;&gt;https://www.realvnc.com/download/&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Linux下可以通过命令安装&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  $ sudo apt-get install vncviewer xtightvncviewer  
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用VNC客户端连接VNC服务端需要两个参数:&lt;code&gt;Pi的IP地址和屏幕的端口地址&lt;/code&gt;&lt;br /&gt;
VNC端口地址：&lt;code&gt;基础端口(默认5900)+屏幕ID&lt;/code&gt; &lt;br /&gt;
如果Pi的iP地址为:&lt;code&gt;192.168.199.227&lt;/code&gt;，屏幕ID为:&lt;code&gt;1&lt;/code&gt;&lt;br /&gt;
那么在Linux下可以这样访问:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ xtightvncviewer 192.168.199.227:5901
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于基础端口一般默认为5901,所以我们直接通过屏幕ID访问&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ xtightvncviewer 192.168.199.227:1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他客户端访问一样，在输入地址区域输入:&lt;code&gt;Pi&#39;s IP:[base port]+Screen ID&lt;/code&gt; &lt;br /&gt;
然后选择连接即可&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;配置&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;raspi-config&lt;/code&gt;进行一些重要的系统配置&lt;br /&gt;
主要是设置合适的区域以及扩展其可用存储空间&lt;/p&gt;

&lt;p&gt;&lt;em&gt;扩展文件系统到SD卡所有空间&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo raspi-config 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了出现一个命令行设置界面，选择第一项&lt;code&gt;Expand Filesystem&lt;/code&gt;,设置完毕，然后重启即可生效&lt;/p&gt;

&lt;p&gt;Raspberry镜像在整个系统中只占用2G空间，即用户8G的SD卡，也只能被使用2G空间，那么一些大的软件将无法安装&lt;/p&gt;

&lt;p&gt;&lt;em&gt;设置区域&lt;/em&gt; &lt;br /&gt;
每个地区的语言环境不一样，造成我们使用的键盘布局不一样，排序方法不一样，设置合适的区域，便于我们操作&lt;br /&gt;
而且各个地方的时间并不一致，难道你想坐在大白天看的时间凌晨一点吗?&lt;/p&gt;

&lt;p&gt;当然，假如你有此癖好，就请忽略&lt;/p&gt;

&lt;p&gt;&lt;em&gt;其他设置&lt;/em&gt;&lt;br /&gt;
按你的需求吧&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;更换软件源&lt;/h3&gt;
&lt;p&gt;树莓派的服务器在国外，在国内访问可能有点慢，额，应该很慢，还有些东西可能因为土啬的原因还下载不了&lt;br /&gt;
还好Raspberry Pi官方提供了一个镜像列表:&lt;a href=&quot;http://www.raspbian.org/RaspbianMirrors&quot; title=&quot;树莓派软件源列表&quot;&gt;http://www.raspbian.org/RaspbianMirrors&lt;/a&gt;&lt;br /&gt;
就近原则选择更换吧&lt;/p&gt;

&lt;p&gt;编辑&lt;code&gt;/etc/apt/sources.list&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#deb http://mirrordirector.raspbian.org/raspbian/ wheezy main contrib non-free rpi
deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ wheezy main contrib non-free rpi 
deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ wheezy main non-free contrib rpi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存，更新软件源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我注释了旧的软件源，添加一个中国的软件源&lt;/p&gt;

&lt;p&gt;对咯，使用上面地址打开的是一个目录，然后我们需要进入当前目录的&lt;code&gt;dists&lt;/code&gt;,然后可以看到&lt;code&gt;wheezy&lt;/code&gt;目录,进入&lt;code&gt;wheezy&lt;/code&gt;就可以看到&lt;code&gt;main&lt;/code&gt;,&lt;code&gt;contrib&lt;/code&gt;,&lt;code&gt;non-free&lt;/code&gt;,&lt;code&gt;rpi&lt;/code&gt;目录,每一个软件源的目录结构都是这样的，所以其他软件源的添加都这样办即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http-address wheezy main contrib non-free rpi 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-8&quot;&gt;配置自动连接你的局域网&lt;/h3&gt;
&lt;p&gt;修改/etc/network/interfaces,原内容如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;auto lo 

iface lo inet loopback
iface eth0 inet dhcp

allow-hotplug wlan0
iface wlan0 inet manual
wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf
iface default inet dhcp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改如下:&lt;/p&gt;

&lt;h1 id=&quot;localhost&quot;&gt;使用localhost&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;auto lo

iface lo inet loopback
iface eth0 inet dhcp

allow-hotplug wlan0 #表示wlan0设备可以热插拔
iface wlan0 inet dhcp
wpa-ssid your-wifi-ssid
wpa-psk your-wifi-passwd

iface default inet dhcp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OKay，以后就会自动连接上你的wifi，假如存在&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;后记&lt;/h3&gt;
&lt;p&gt;刚看到树莓派的时候，就一块布满电路的板子，瞬间有点懵，天生对电路过敏&lt;/p&gt;

&lt;p&gt;但事实上，关于电路的部分，人家已经为你封装好了(&lt;strong&gt;多好的思想,感谢面向对象&lt;/strong&gt;),你只需要会一点软件的知识，痛快的玩就可以了&lt;/p&gt;

&lt;p&gt;文章很长，但还是觉得不够，很多东西还没讲到，但这些应该已经足够&lt;/p&gt;

&lt;p&gt;装系统其实只花费了一小会儿，而写文章却用了4个小时&lt;/p&gt;

&lt;p&gt;希望玩的愉快!…&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/12/06/raspberrypi-install</link>
                <guid>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/12/06/raspberrypi-install</guid>
                <pubDate>2014-12-06T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>Linux下MASM汇编环境搭建</title>
                <description>
&lt;h3 id=&quot;section&quot;&gt;碎碎念&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;MASM&lt;/code&gt;是Microsoft Macro Assembler的缩写，它是微软为x86微处理器家族缩写的一套宏编译器&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dosbox&lt;/code&gt;是一款x86/DOS环境模拟器，可以很好模拟DOS环境,方便我们运行DOS程序&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.asm&lt;/code&gt;是汇编代码的后缀&lt;/p&gt;

&lt;p&gt;好了，现在开始吧！&lt;/p&gt;

&lt;h3 id=&quot;dosbox&quot;&gt;安装dosbox&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install dosbox  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;masm&quot;&gt;下载MASM软件包&lt;/h3&gt;

&lt;p&gt;从这里下载&lt;a href=&quot;http://yun.baidu.com/share/link?shareid=507770005&amp;amp;uk=388194121&quot; title=&quot;masm.tar.bz2&quot;&gt;masm.tar.bz2&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~
$ mkdir -p masm/tools
$ tar xjf Download/masm.tar.bz2 -C masm/tools 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载的文件，解压到新建的文件夹masm/tools下&lt;br /&gt;
masm即将作为dosbox的C盘&lt;/p&gt;

&lt;h3 id=&quot;dosbox-1&quot;&gt;启动dosbox&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ dosbox -c &quot;mount C: ~/masm/tools&quot; -c &quot;path %path%;C:\tools\&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，dosbox应该出现了，你可以使用&lt;code&gt;debug.exe&lt;/code&gt;,&lt;code&gt;masm.exe&lt;/code&gt;了&lt;br /&gt;
&lt;code&gt;-c&lt;/code&gt;: 指定dosbox的启动参数&lt;br /&gt;
&lt;code&gt;mount C: ~/masm/tools&lt;/code&gt;: 把我们用户主目录下的masm/tools作为dosbox的C盘&lt;br /&gt;
&lt;code&gt;path %path%;C:\tools&lt;/code&gt; : 给path(&lt;em&gt;可执行文件搜索路径&lt;/em&gt;)环境变量添加值，这样，我们无论在哪个目录都可以使用masm软件包的工具了&lt;/p&gt;

&lt;h3 id=&quot;dosbox-2&quot;&gt;使用脚本启动dosbox&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;dosbox_setup.sh&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
dosbox -c &quot;mount C: ~masm&quot; -c &quot;path %path%;C:\tools\&quot; &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为dosbox_setup.sh添加执行权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod a+x dosbox_setup.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，你可以通过运行此脚本打开dosbox,而且路径已经配置好了&lt;/p&gt;

&lt;h3 id=&quot;helloworld&quot;&gt;写个汇编版的HelloWorld&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;hello.asm&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assume cs:codes, ds:datas
datas segment
		str db &#39;hello,world&#39;,13,10,&#39;$&#39;
datas ends
codes segment
	start:
		mov ax, datas
		mov ds, ax
		lea dx, str
		mov ah, 9
		int 21h
		mov ah, 4ch
		int 21h
codes ends
	end start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用vim写代码(当然如果你嫌影响你的心情的话，可以使用&lt;code&gt;EDIT.COM&lt;/code&gt;)&lt;/p&gt;

&lt;h4 id=&quot;dosbox-3&quot;&gt;在dosbox中编译连接&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;C:\&amp;gt; masm hello.asm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译生成hello.obj的连接文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\&amp;gt; link hello.obj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连接生成hello.exe的可执行文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\&amp;gt; hello.exe
hello,world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此结束&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;一些自言自语&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;为什么选择MASM呢？&lt;/em&gt;&lt;br /&gt;
事实上，各大高校的汇编语言学习都是使用MASM的语法，而Linux下的NASM的语法和其还是有些差异的&lt;br /&gt;
(不要问我为何在Linux下使用MASM，我能告诉你这是我的偏执吗?嘿嘿…)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;为什么还要学习汇编?&lt;/em&gt;  &lt;br /&gt;
这个各人有个人的理由吧，而我只是单纯想了解一下底层程序的运行机制&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;推荐&lt;/h3&gt;

&lt;p&gt;对于汇编学习，推荐王爽先生的《汇编语言》&lt;br /&gt;
对于dosbox的其他用法，请使用Linux下的&lt;code&gt;man dosbox&lt;/code&gt;&lt;br /&gt;
对于其它问题，请留言或者google&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/%E8%BD%AF%E4%BB%B6/2014/12/05/linux-masm-built</link>
                <guid>http://mwumli.github.io/%E8%BD%AF%E4%BB%B6/2014/12/05/linux-masm-built</guid>
                <pubDate>2014-12-05T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>简单的DNS讲解</title>
                <description>
&lt;h3 id=&quot;dns&quot;&gt;DNS是什么&lt;/h3&gt;
&lt;p&gt;DNS，可以看作Domain Name Service，Domain Name Server, Domain Name System的缩写，网上也没有统一的解释,说明是哪一种的缩写,我们暂且先不管它&lt;/p&gt;

&lt;p&gt;早期互联网的时代，我们使用IP地址访问网站&lt;br /&gt;
由于IPV4(IPv6)地址的难以记忆，人们用了一种转换的思想:&lt;code&gt;使用人类容易记忆的名字来代替IP地址,然后通过某种服务把域名转化成IP&lt;/code&gt;，这样，就可以实现精确的定位&lt;br /&gt;
而这个名字就是域名,例如耳熟能详的百度首页&lt;code&gt;www.baidu.com&lt;/code&gt;,我们学校的论坛&lt;code&gt;www.xiyoubbs.com&lt;/code&gt;&lt;br /&gt;
这种服务就是域名解析服务，我们用来提供服务的服务器就被称作域名解析服务器&lt;/p&gt;

&lt;p&gt;事实上,我们通常把域名服务，域名服务器都可以称作DNS，理解了域名解析服务的工作原理，就很容易明白我们交流，或者其他文献中简称DNS时，它所代表的真实含义&lt;br /&gt;
#### DNS的两种查询方式&lt;br /&gt;
分别是递归查询和迭代查询&lt;/p&gt;

&lt;p&gt;所谓&lt;em&gt;递归查询&lt;/em&gt;：如果目标DNS服务器无法解析某个主机名,则它将向其他DNS服务器继续查询，如此递归，知道获得结果并把结果返回给客户&lt;/p&gt;

&lt;p&gt;所谓&lt;em&gt;迭代查询&lt;/em&gt;：如果目标DNS服务器无法解析某个主机名，则它将已知道的其他DNS服务器的IP地址返回给客户端，以供客户端参考&lt;/p&gt;

&lt;p&gt;一般默认都是递归查询&lt;/p&gt;

&lt;h3 id=&quot;linuxdns&quot;&gt;Linux下的一些用于DNS查询的命令&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ping命令，不仅可以判断网络是否畅通，还可以用域名ping外网时，查看域名对应的主机IP&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ ping www.baidu.com
  PING www.a.shifen.com (61.135.169.125) 56(84) bytes of data.
  64 bytes from 61.135.169.125: icmp_seq=1 ttl=53 time=19.7 ms
  64 bytes from 61.135.169.125: icmp_seq=2 ttl=53 time=21.1 ms
  64 bytes from 61.135.169.125: icmp_seq=3 ttl=53 time=20.0 ms
  ...
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host命令,一个DNS查询工具&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ host -t A www.baidu.com  
  www.baidu.com is an alias for www.a.shifen.com.
  www.a.shifen.com has address 61.135.169.121
  www.a.shifen.com has address 61.135.169.125  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tcpdumpdns&quot;&gt;使用tcpdump观察DNS通信过程&lt;/h3&gt;
&lt;p&gt;tcpdump是Linux下的一个抓包工具&lt;br /&gt;
(Linux下各种服务所对应的端口，可以在&lt;code&gt;/etc/services&lt;/code&gt;看到)&lt;br /&gt;
在一个终端A输入一下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo tcpdump -i wlan0 -nt port domain 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后开启另一个终端B,输入一下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ host -t -A www.baidu.com  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以在终端A下看到:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IP 172.24.243.3.21645 &amp;gt; 172.24.243.1.53: 18340+ A? www.baidu.com. (31)
IP 172.24.243.1.53 &amp;gt; 172.24.243.3.21645: 18340 3/0/0 CNAME www.a.shifen.com., A 115.239.211.110, A 115.239.210.27 (138)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cpdump以“IP地址.端口号”的形式来描述通信的某一端；以“&amp;gt;”表示数据传输的方向，“&amp;gt;”前面是源端，后面是目的端。&lt;/p&gt;

&lt;p&gt;目标端口53是DNS服务使用的端口&lt;/p&gt;

&lt;p&gt;第一个数据包是我的机器(172.24.243.3)发送的DNS查询报文&lt;br /&gt;
第二个数据包是服务器反馈的DNS应答报文&lt;/p&gt;

&lt;p&gt;第一个数据包中，数值18340是DNS查询报文的标识值，因此该值也出现在DNS应答报文中。&lt;br /&gt;
“+”表示启用递归查询标志。&lt;br /&gt;
“A”表示使用A类型的查询方式。&lt;br /&gt;
“www.baidu.com”则是DNS查询问题中的查询名。&lt;br /&gt;
括号中的数值31是DNS查询报文的长度（以字节为单位）。&lt;/p&gt;

&lt;p&gt;第二个数据包中，“3/0/0”表示该报文中包含3个应答资源记录、0个授权资源记录和0个额外信息记录。&lt;br /&gt;
“CNAME www.a.shifen.com., A 115.239.211.110, A 115.239.210.27 (138)”则表示3个应答资源记录的内容。&lt;br /&gt;
其中CNAME表示紧随其后的记录是机器的别名，A表示紧随其后的记录是IP地址。&lt;br /&gt;
该应答报文的长度为138字节。&lt;/p&gt;

&lt;h3 id=&quot;dns-1&quot;&gt;修改DNS&lt;/h3&gt;
&lt;p&gt;我记得以前碰到过这样一见很诡异的事情：qq可以登录聊天，邮件客户端也可以正常工作，就唯独浏览器打不开网站页面&lt;/p&gt;

&lt;p&gt;当时遇到的时候，感觉可诡异，后来才知道，原来是DNS挂了&lt;/p&gt;

&lt;p&gt;我们通常上网都是直接通过网络运营商(电信，网通等)提供的网络，所以DNS也是自动获取，一定运行上的域名服务器出现了问题，那么我们也就不能正常访问网站&lt;/p&gt;

&lt;p&gt;此时，我们就得修改DNS，著名的DNS有谷歌的:&lt;code&gt;8.8.8.8&lt;/code&gt; 和 &lt;code&gt;8.8.4.4&lt;/code&gt;   &lt;br /&gt;
还有114DNS:&lt;code&gt;114.114.114.114&lt;/code&gt;和&lt;code&gt;114.114.115.115&lt;/code&gt;  &lt;br /&gt;
这两个算是比较好记的&lt;/p&gt;

&lt;p&gt;还有其他的请参考&lt;a href=&quot;www.ip.cn/dns.html&quot;&gt;公共DNS服务器&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/11/05/dns</link>
                <guid>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/11/05/dns</guid>
                <pubDate>2014-11-05T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>编译和连接</title>
                <description>&lt;h2 id=&quot;section&quot;&gt;编译和连接&lt;/h2&gt;
&lt;p&gt;对于平常的应用程序开发，我们很少关注编译和连接的过程，因为通常的开发环境都是流行的集成开发环境(IDE)&lt;/p&gt;

&lt;p&gt;而IDE往往将编译和连接的过程“一气呵成”,通常编译和连接合并到一块被称为”build”,也就是构建.&lt;/p&gt;

&lt;p&gt;即使是命令行来编译一个&lt;code&gt;hello.c&lt;/code&gt;，简单一句&lt;code&gt;gcc hello.c&lt;/code&gt;，然后你就可以&lt;code&gt;./a.out&lt;/code&gt;来得到富有盛名的&lt;code&gt;Hello,World!&lt;/code&gt;了&lt;/p&gt;

&lt;p&gt;正所谓“有一得必有一失”，我们享受与这种一键执行的快感，却忽略很多系统软件背后的运行机制和机理，程序中很多莫名其妙的错误常常令我们无所适从，面对程序运行时种种性能瓶颈我们束手无策，而为了解决这些问题，我们往往需要追根溯源&lt;/p&gt;

&lt;p&gt;因此，了解编译和连接的过程，有助于我们对软件运行的机理的了解以及对出现的各种问题能有更高效的解决途径&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;从最简单最熟悉开始&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Hello,World&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//hello.c&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样的程序，闭着眼睛，用心作笔，估计一秒钟都可以写几万次了吧&lt;br /&gt;
在Linux下，当我们使用GCC来编译hello.c,这样做:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls 
hello.c
$ gcc hello.c
$ ls
a.out hello.c
$ ./a.out
Hello,World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，我们使用gcc编译处理hello.c之后，生成了一个a.out的文件&lt;br /&gt;
这个文件正是我们可执行程序，运行之后，输出&lt;code&gt;Hello,World&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;整个过程很简单，但这只是表面上的，事实上，上述过程可以分解为4个步骤，分别是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;预处理(Prepressing)[.c]-&amp;gt;编译(Compilation)[.i]-&amp;gt;汇编(Assembly)[.o]-&amp;gt;链接(Linking)[可执行文件]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;c-i-using-cpp&quot;&gt;预处理(.c-&amp;gt;.i using cpp)&lt;/h3&gt;
&lt;p&gt;Linux下对c文件进行预处理，可以使用预编译器&lt;code&gt;cpp&lt;/code&gt;&lt;br /&gt;
进行预处理之后，生成的预处理文件为&lt;code&gt;.i&lt;/code&gt;,对于C++程序而言，预编译后的文件为&lt;code&gt;.ii&lt;/code&gt;&lt;br /&gt;
以下是预编译的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cpp hello.c &amp;gt; hello.i  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -E hello.c -o hello.i  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无论是&lt;code&gt;cpp&lt;/code&gt;还是&lt;code&gt;gcc -E&lt;/code&gt;,他们的结果(在不指定目标文件的情况下)会输出到&lt;code&gt;stdout&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;预编译的过程主要处理那些源码中以”#”开始的预编译指令，比如&lt;code&gt;#include&lt;/code&gt;，&lt;code&gt;#define&lt;/code&gt;&lt;br /&gt;
主要做了一下处理:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;将所有&lt;code&gt;#define&lt;/code&gt;处删除，展开所有宏定义&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 在include和main之间添加“#define HELLO &quot;hello,world\n&quot; ”,
 然后把printf()中的内容改为HELLO,接着如上预处理生成目标文件hello_micro.i
 使用diff hello.i hello_micro.i,发现两个文件完全一致 
 由此证明删除定义宏，展开所有宏  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;处理所有条件预编译指令，比如&lt;code&gt;#if&lt;/code&gt;,&lt;code&gt;#ifdef&lt;/code&gt;,&lt;code&gt;#elif&lt;/code&gt;,&lt;code&gt;#else&lt;/code&gt;,&lt;code&gt;#endif&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;处理&lt;code&gt;#include&lt;/code&gt;预编译指令，将被包含的文件插入到该预编译指令的位置。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。
 因此，在多文件程序中要注意同一文件被多次包含引起的错误  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;删除所有的注释&lt;code&gt;//&lt;/code&gt;和&lt;code&gt;/**/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;添加行号和文件名标识，比如&lt;code&gt;#2 &quot;hello.c&quot; 2&lt;/code&gt;,以便于编译时产生调试用的行号信息及用于编译时产生编译错误或警告时都能显示行号&lt;/li&gt;
  &lt;li&gt;保留所有的&lt;code&gt;#pragma&lt;/code&gt;编译器指令，因为编译器需要使用它们&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;经过预编译后的&lt;code&gt;.i&lt;/code&gt;文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中。&lt;br /&gt;
所以当我们&lt;em&gt;无法判断宏定义是否正确&lt;/em&gt;或者&lt;em&gt;头文件是否正确引入&lt;/em&gt;的时候，可以查看预编译后的&lt;code&gt;.i&lt;/code&gt;文件来确定问题&lt;/p&gt;

&lt;h3 id=&quot;i-s-using-cc1&quot;&gt;编译(.i-&amp;gt;.s using cc1)&lt;/h3&gt;
&lt;p&gt;编译过程就是把&lt;code&gt;.i&lt;/code&gt;文件进行一系列的词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件&lt;code&gt;.s&lt;/code&gt;&lt;br /&gt;
这个过程整个程序构建的核心部分,也是最复杂的部分，涉及到编译原理的一些内容&lt;br /&gt;
Linux命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -S hello.i -o hello.s  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;据说，现在的gcc已经将预编译和编译两个步骤合并成一个步骤，使用一个叫做&lt;code&gt;cc1&lt;/code&gt;的程序&lt;br /&gt;
&lt;code&gt;cc1&lt;/code&gt;在我的机器(Ubuntu 14.04 LTS)上的路径&lt;code&gt;/usr/lib/gcc/x86_64-linux-gnu/4.8/cc1&lt;/code&gt; &lt;br /&gt;
因此，我这样编译：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/lib/gcc/x86_64-linux-gnu/4.8/cc1 hello.i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和上面的命令效果等同&lt;br /&gt;
但是根据资料显示，&lt;code&gt;cc1&lt;/code&gt;把预编译和编译融合，因此我使用&lt;code&gt;/usr/lib/gcc/x86_64-linux-gnu/4.8/cc1 hello.c&lt;/code&gt;,结果出错&lt;/p&gt;

&lt;p&gt;为了研究其原因，我使用&lt;code&gt;gcc -v hello.c 2&amp;gt;cp.txt&lt;/code&gt;打印gcc对其编译过程做了那些操作&lt;br /&gt;
因为比较长，只截取有用的部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/lib/gcc/x86_64-linux-gnu/4.8/cc1 -quiet -v -imultiarch x86_64-linux-gnu hello.c -quiet -dumpbase hello.c -mtune=generic -march=x86-64 -auxbase hello -version -fstack-protector -Wformat -Wformat-security -o /tmp/cckHwTs6.s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到cc1携带了大量的参数，最终生成汇编文件保存在&lt;code&gt;/tmp/cckHwTs6.s&lt;/code&gt;&lt;br /&gt;
我在命令行进行了验证，确实如此&lt;br /&gt;
这里又一次证明了：IDE掩盖很多已有的参数。不过，这么多参数确实让人心烦，既然常用，默认是一个好的办法，不过，你应该了解有这么个过程&lt;/p&gt;

&lt;h3 id=&quot;s-o-using-as&quot;&gt;汇编(.s-&amp;gt;.o using as)&lt;/h3&gt;
&lt;p&gt;汇编器就是将汇编代码转变成机器可以执行的指令，每一个汇编语句都对应一条机器指令,所以汇编器的汇编过程相对于编译过程就显得简单多了。&lt;/p&gt;

&lt;p&gt;汇编过程在linux下我们调用汇编器as来完成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ as hello.s -o hello.o  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -c hello.s -o hello.o  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者使用gcc从.c文件开始，经过预编译、编译、汇编直接输出&lt;em&gt;目标文件&lt;/em&gt;(Object File)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -c hello.s -o hello.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样，我们可以在cp.txt文件中看到下面一段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;COLLECT_GCC_OPTIONS=&#39;-v&#39; &#39;-mtune=generic&#39; &#39;-march=x86-64&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;链接通常是一个让人费解的过程：&lt;br /&gt;
为什么汇编器不直接输出可执行文件而是一个目标文件呢？&lt;br /&gt;
链接过程到底包含了什么内容？&lt;br /&gt;
为什么要链接?&lt;br /&gt;
…&lt;br /&gt;
我们通常使用ld来链接目标文件&lt;br /&gt;
我们来看看cp.txt中的相应描述：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/lib/gcc/x86_64-linux-gnu/4.8/collect2 --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -z relro /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.8/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.8 -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../.. /tmp/ccfb7d3z.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/4.8/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crtn.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;额，好长啊，不过貌似没有&lt;code&gt;ld&lt;/code&gt;的字眼，看来gcc并没有如同我们想象的那样直接调用ld进行链接。而是调用&lt;code&gt;collect2&lt;/code&gt;进行链接&lt;/p&gt;

&lt;p&gt;实际上，&lt;code&gt;collect2&lt;/code&gt;只是一个辅助程序最终它仍调用&lt;code&gt;ld&lt;/code&gt;进行链接&lt;/p&gt;

&lt;p&gt;举个例子：对于C++程序来说，在执行main函数前，全局静态对象必须构造完成。
也就是说，在main之前程序需要进行一些必要的初始化，gcc就是使用collect2安排初始化过程中如何调用各个初始化函数的。根据链接过程可见，除了hello.c对应的目标文件ccfb7d3z.o外，ld也链接了libc、libgcc等库，以及所谓的包含启动代码（start code）的启动文件（start/startup file），包括crt1.o、crti.o、crtbegin.o、crtend.o和crtn.o&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;《程序员的自我修养》&lt;/li&gt;
  &lt;li&gt;《深度探索Linux操作系统：系统构建和原理解析》&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/09/28/compile-link</link>
                <guid>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/09/28/compile-link</guid>
                <pubDate>2014-09-28T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>Linux内核链表的分析</title>
                <description>&lt;h3 id=&quot;listhead&quot;&gt;内核中list_head的定义&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;struct list_head {
	struct list_head *next, *prev;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仅仅只有两个指针，prev指向前一个节点,next指向后一个节点&lt;br /&gt;
但是为什么没有data域呢？&lt;br /&gt;
内核出错了，显然不可能，别急，慢慢来&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;栈，队列，链表…..&lt;/h4&gt;
&lt;p&gt;我们可以用这个结构定义一个新的结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;strutc my_list_node {
	int	data;
	strutc list_head list;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;假如我们禁用了list中的prev,它就是一个&lt;em&gt;单链表&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如(单链表的基础上)我们启用list中的prev，它就是一个&lt;em&gt;双链表&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如(单链表基础上)我们让最后一个节点next指向第一个节点，那么它就是一个&lt;em&gt;单向循环链表&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如(单向循环链表基础上)我们启用list中的prev域，那么它就是一个&lt;em&gt;双向循环链表&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如(单链表的基础上)，我们有方法可以从头部插入，头部删除，那么它就是一个&lt;em&gt;栈&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如(单链表的基础上)，我们有方法可以头部删除，尾部插入那么它就是一个&lt;em&gt;队列&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如…,它就是一个…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好了,我想也不用多说了，大家应该思维澎湃了&lt;br /&gt;
这正体现了一点：链表是其他数据结构的根本形式&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;为什么没有数据域？&lt;/h4&gt;
&lt;p&gt;怎么可能？链表没有数据，这还有什么意义&lt;br /&gt;
是啊，没有数据域，我们该怎储存信息呢？&lt;br /&gt;
事实上，上面我们定义的这个&lt;em&gt;struct my_list_node&lt;/em&gt;就解释了为什么没有数据域&lt;br /&gt;
没有数据正是为了可以容纳更多的，不同的数据类型(通过自定义)&lt;/p&gt;

&lt;p&gt;这就是抽象的艺术，说起抽象，谈谈面向对象也不不错&lt;/p&gt;

&lt;p&gt;我们常说，C++是面向对象的语言，其实面向对象并不只是说一种语言，而是一种思想：我们把具体的东西通过对其共性的分析，抽象出来，从而形成一种结构，这种结构或许单独来说么有实际意义，但是通过我们增添不同的功能，从而就有了不同的意义新的结构，那么此时，其意义得以体现，这就是我理解的面向对象&lt;/p&gt;

&lt;p&gt;可以看到我们抛弃了那所谓的数据，只留下了两个指针，正因为抛弃了数据域(也不能说抛弃，应该是还未迎娶),我们才可以通过自定义添加不同的数据类型(int,char等),更多的数据成员(1,2,3…)&lt;/p&gt;

&lt;p&gt;所有有的时候，所谓的舍弃，只是为了更好的扩展&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;内核链表的初始化&lt;/h3&gt;
&lt;p&gt;两个宏，一个函数&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;两个宏&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#define LIST_HEAD_INIT(name) { &amp;amp;(name), &amp;amp;(name) }

#define LIST_HEAD(name) strutc list_head name = LIST_HEAD_INIT(name)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;一个函数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;static inline void INIT_LIST_HEAD(struct list_head *list) 
{
	list-&amp;gt;next = list;
	list-&amp;gt;prev = list;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些有什么不同呢？&lt;br /&gt;
我看了有看，也确实有点不同&lt;br /&gt;
&lt;em&gt;LIST_HEAD&lt;/em&gt;和&lt;em&gt;LIST_HEAD_INIT&lt;/em&gt;是相辅相成的，如果单独使用的话，那么&lt;em&gt;LIST_HEAD_INIT&lt;/em&gt;需要用在结构体变量定义初始化的时候，而&lt;em&gt;LIST_HEAD&lt;/em&gt;只需要提供一个变量名即可完成定义兼初始化：&lt;br /&gt;
&lt;strong&gt;LIST_HEAD_INIT&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct list_head lp = LIST_HEAD_INIT(lp);	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;LIST_HEAD&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LIST_HEAD(lp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两段代码看起来不一样，其实本质是一样的：定义了一个名为lp的struct list_head变量，同时用其自己的地址对其初始化&lt;/p&gt;

&lt;h4 id=&quot;static-inline&quot;&gt;static inline&lt;/h4&gt;
&lt;p&gt;当你看过&lt;em&gt;list.h&lt;/em&gt;后，我相信你对static inline已经熟的不能在熟&lt;br /&gt;
但是有有点困惑，为什么这么频繁的使用呢？&lt;br /&gt;
真是熟悉的陌生人!…呵呵&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;static&lt;/strong&gt;&lt;br /&gt;
被static修饰的函数，作用域将限于本文件，也就是其他文件看不见&lt;/p&gt;

&lt;p&gt;可能你觉的这样说起来很模糊，而且假如我们在.h文件中定义，然后被其他.c文件&lt;em&gt;include&lt;/em&gt;,那么根据&lt;em&gt;include&lt;/em&gt;的定义：当预处理器具发现include的时候，就会寻找inlucde之后的文件,并把这个文件包含到当前文件,即替换include指令&lt;/p&gt;

&lt;p&gt;所以这样的话，.h文件也是.c文件的一部分了，那么.h文件中被static修饰的函数必然也能在.c文件中使用了，那么，static的意义不存了&lt;/p&gt;

&lt;p&gt;嗯哼，当然不是这样的，我们试着这样做一做吧:&lt;br /&gt;
&lt;em&gt;test_static.h&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void func1(){ }
void func2(){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还有两个文件，一个是main.c, 一个是test_static.c，这两文件我们都引用了&lt;strong&gt;test_static.h&lt;/strong&gt;,然后我们执行下面指令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -o main main.c test_static.c test_static.h
/tmp/ccSrEpb2.o: In function `func2&#39;:
test_static.c:(.text+0x6): multiple definition of `func2&#39;
/tmp/cc54UVtA.o:main.c:(.text+0x6): first defined here
collect2: error: ld returned 1 exit status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是的报错了：func2多重定义,对就是那个没有定义为static的家伙&lt;/p&gt;

&lt;p&gt;好了，我们给func2加上static,在编译一次(自己操作)，啊哈，编译成功&lt;br /&gt;
是的，static让错误消失了&lt;/p&gt;

&lt;p&gt;怎么回事儿呢？&lt;br /&gt;
添加了static ,虽然每个.c文件中都定义了static函数，但是经过编译，所有的static隐藏在自己的目的文件(.o)中，连接器(linker)在找寻symbol的过程中，是会被忽略的&lt;/p&gt;

&lt;p&gt;所以，我们加上static是为了避免多重定义连接错误&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;inline&lt;/strong&gt;&lt;br /&gt;
inline是内联的意思，即当定义了inline,就会暗示编译器，我有”倒插门”的倾向，然后，编译器愿不愿意接受，那就得看具体编译器的不同配置了;如果我被接受了，那么在编译的时候，我会每个call我的地方”赤身裸体”(即展开代码)&lt;/p&gt;

&lt;p&gt;因为代码被插入到被调用的地方，所以效率肯定提高了(相比函数调用的上下文切换)&lt;br /&gt;
这也就是函数前使用inline的意义：提高效率(现在存储技术发展很快，相比之下，效率尤为重要)&lt;/p&gt;

&lt;p&gt;现在，关键的来了，我们同时使用了static inline：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When an inline function is not static, then the compiler must assume that there may be calls from other source files; since a global symbol can be defined only once in any program, the function must not be defined in the other source files, so the calls therein cannot be integrated. Therefore, a non-static inline function is always compiled on its own in the usual fashion.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这段话来自&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Inline.html&quot;&gt;gcc的官方文档&lt;/a&gt;&lt;br /&gt;
我的理解：在.h文件中定义inline,如果没有static,那么编译器(至少gcc是这样)就会认为你可能被其他文件多次调用，因为一个全局符号在任何一个程序中仅能出现一次，这个函数一定不能定义在其他源文件中，因此这此调用不能inline函数代码不能被集成到被调用处&lt;/p&gt;

&lt;p&gt;所以，我想应该是基于这个原因，所以内核代码中多次使用&lt;em&gt;static inline&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;内核链表的插入&lt;/h3&gt;
&lt;p&gt;将new插入head之后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void list_add(struct isr_head *new , struct list_head *head) 
{
	__list_add(new, head, head-&amp;gt;next);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码注释里有句话：This is good for implementing stacks.&lt;/p&gt;

&lt;p&gt;将new插入到head之前，即尾部&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void list_add_tail(struct list_head *new, struct list_head *head)  
{
	__list_add(new, head-&amp;gt;prev, head);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码注释里有句话：This is good for implementing queues.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;__list_add&lt;/strong&gt;到底是何方人士，竟引得list_add和list_add_tail竞相使用?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void __list_add(struct list_head *new,
				struct list_head *prev;
				struct list_head *next;)
{
	next-&amp;gt;prev = new;
	new-&amp;gt;next = next;
	prev-&amp;gt;next = new;
	new-&amp;gt;prev = prev;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到代码，才知道：哦，原来只是把一个node插入到两个node之间的函数&lt;br /&gt;
不用多说了，这里很简单，但是重要的是这种抽象的思想&lt;br /&gt;
对了，看来那两句注释，感觉如何？&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;内核链表之删除&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;static inline void __list_del(struct list_head * prev, 
				struct list_head * next)
{
	next-&amp;gt;prev = prev;
	prev-&amp;gt;next = next;
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry-&amp;gt;prev, entry-&amp;gt;next);  
	entry-&amp;gt;next = LIST_POISON1;        
	entry-&amp;gt;prev = LIST_POISON2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码很简单，LIST_POISON1和LIST_POISON2是两个宏，被定义在poison.h中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define LIST_POISON1  ((void *) 0x00100100 + POISON_POINTER_DELTA)
#define LIST_POISON2  ((void *) 0x00200200 + POISON_POINTER_DELTA)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释说这两个非空指针在正常情况下会导致页错误，这是它的注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 *These are non-NULL pointers that will result in page faults¬
 * under normal circumstances, used to verify that nobody uses¬
 * non-initialized list entries.
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些都可以理解，但是为什么是0x00100100和0x00200200呢？&lt;br /&gt;
我查了很多资料，都没找到答案，恳请各位解惑&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;内核链表之遍历&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; #define list_for_each(pos, head) \
	for (pos = (head)-&amp;gt;next; pos != (head); pos = pos-&amp;gt;next)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个宏很简单，但是有个难点就是我们怎么根据pos找到node的位置，例如我上面定义的struct my_list_node这个结构&lt;br /&gt;
list.h给出了代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define list_entry(ptr, type, member) \
	container_of(ptr, type, member)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个container_of在kernel.h中有定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define container_of(ptr, type, member) ({       \
|	const typeof( ((type *)0)-&amp;gt;member ) *__mptr = (ptr);   \
|	 (type *)( (char *)__mptr - offsetof(type,member) );})  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码还真不好说，还是给出一段代码，试试就知道了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

struct list_head {
	struct list_head *self;
};
typedef struct Type_List {
	int a;
	struct list_head list;
}Type_List;

int main(int argc, const char *argv[])
{
	Type_List *tl=(Type_List *)malloc(sizeof(Type_List));
	//打印tl的地址
	printf(&quot;%x\n&quot;, tl);

	//获取tl的成员list的地址赋给ptr
	struct list_head *ptr=&amp;amp;(tl-&amp;gt;list);
	//使用ptr获取tl的地址
	Type_List *p=(Type_List *)((char *)ptr-(unsigned long)&amp;amp;(((Type_List *)0)-&amp;gt;list));
	printf(&quot;%x\n&quot;, p);

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简而言之，就是使用list的地址减去list成员距my_list_head的起始地址的偏移量&lt;br /&gt;
而offsetof就是求偏移量的宏&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;内核链表删除的不安全性&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#define list_for_each_safe(pos, n, head) \
    for (pos = (head)-&amp;gt;next, n = pos-&amp;gt;next; pos != (head); \
		pos = n, n = pos-&amp;gt;next)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是list.h中提供的用于安全删除链表的遍历宏&lt;br /&gt;
之前我们看到list_for_each这个宏&lt;br /&gt;
如果我们向下面这样用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list_for_each(ptr, head) {
	tmp = list_entry(ptr, struct my_list_head, list);
	list_del(ptr);
	free(tmp)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写的话，因为ptr已经被删除，但根据list_for_each内部实现却是在删除ptr之后，调用ptr=ptr-&amp;gt;next,因为地址已经被引入LIST_POISON1了，所以肯定报错&lt;/p&gt;

&lt;p&gt;而我们使用了list_for_each_safe,就不会这样，因为有一个临时的struct my_list_head类型变量n记录了ptr的下一个节点，所以就不会出现问题&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;结束&lt;/h3&gt;
&lt;p&gt;呵，松了口气，好长啊，不过，看了内核对list的实现，确实收获很多，尽管现在看到是”冰山一脚“，但是这一脚总算是才上去了&lt;br /&gt;
对于文章中出现的问题，希望作为读者的你能提出来，帮助我改进&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/09/22/kernel-list</link>
                <guid>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/09/22/kernel-list</guid>
                <pubDate>2014-09-22T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>静态博客系统-->JekyllBootstrap</title>
                <description>
&lt;h3 id=&quot;jekyllbootstrap&quot;&gt;上菜–JekyllBootstrap&lt;/h3&gt;
&lt;p&gt;在&lt;a href=&quot;/%E8%AE%B0%E5%BD%95/2014/08/14/static-website-by-jekyll/&quot; title=&quot;使用jekyll搭建静态站点&quot;&gt;使用jekyll搭建静态站点&lt;/a&gt;一文中， 我已经介绍了怎么创建最简单站点的例子(&lt;code&gt;jekyll new myblog&lt;/code&gt;),但看起来貌似难以起步(神马都没有),一切都需要start from scratch，真是愁啊&lt;/p&gt;

&lt;p&gt;不过，现在不用担心了，我们有技能–&amp;gt;JekyllBootstrap&lt;/p&gt;

&lt;p&gt;JekyllbBootstrap就像WordPress(动态博客系统）一样，但是，jekyllbootstrap用于静态网站&lt;/p&gt;

&lt;p&gt;好了，开始准备干活吧&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个新的仓库&lt;br /&gt;
去你的&lt;a href=&quot;https://github.com&quot; title=&quot;github首页&quot;&gt;https://github.com&lt;/a&gt;创建一个新的仓库，命名为&lt;code&gt;username.github.io&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装Jekyll-Bootstrap&lt;br /&gt;
打开终端，切换到你想放置站点的目录，输入一下命令：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ git clone https://github.com/plusjade/jekyll-bootstrap.git username.github.io
 $ cd username.github.io
 $ git remote set-url origin git@github.com:username/username.github.com.git
 $ git push origin master
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;等待与收获&lt;br /&gt;
等待大约10分钟，你就可以通过browser在&lt;code&gt;http://username.github.com&lt;/code&gt;看到你的站点&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;rakepost-or-page&quot;&gt;使用rake快速创建post or page&lt;/h3&gt;
&lt;p&gt;顺便说一句，&lt;code&gt;rake&lt;/code&gt;工具需要安装，Linux/Ubuntu请使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install rake  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rake&lt;/code&gt;使用之前需要有一个&lt;code&gt;Rakefile&lt;/code&gt;文件，如果你使用&lt;code&gt;JekyllBootstrap&lt;/code&gt;,那你就不用自己创建&lt;code&gt;Rakefile&lt;/code&gt;文件，已经内置;否则，你如果想使用&lt;code&gt;Rake&lt;/code&gt;，可以拷贝一下&lt;code&gt;JekyllBoostrap&lt;/code&gt;里的&lt;code&gt;Rakefile&lt;/code&gt;，或者，自己查阅相关资料按照规则编写（你可以的，嘿嘿）&lt;/p&gt;

&lt;h4 id=&quot;post&quot;&gt;创建一篇post&lt;/h4&gt;
&lt;p&gt;通过&lt;code&gt;rake&lt;/code&gt;很容易创建一篇post&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rake post title=&quot;Hello World&quot;  
Creating new post: ./_posts/2014-08-14-hello-world.md  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rake&lt;/code&gt;会帮你格式化名字并添加日期(当前时间) &lt;br /&gt;
并且post中自动添加YAML头信息，太方便了&lt;br /&gt;
&lt;code&gt;rake&lt;/code&gt;不会覆盖原有文件，除非你让它那么做&lt;/p&gt;

&lt;h4 id=&quot;page&quot;&gt;创建一个page&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在根目录创建&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ rake page name=&quot;about.md&quot;
  Creating new page: ./about.md  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个内嵌&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ rake page name=&quot;pages/about.md&quot;
  Creating new page: ./pages/about.md  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个”漂亮”的路径&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ rake page name=&quot;pages/about.md
  Creating new page: ./pages/about/index.html&quot;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三种方式的区别在于browser呈现的路径的不同,自己尝试吧&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;发布你的站点&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git add .
$ git commit -m &quot;add new content&quot;
$ git push origin master  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，新的内容已经在你的github项目，享受新的变化吧&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;自定义&lt;/h4&gt;
&lt;p&gt;Jekyll-Bootstrap可以根据喜好自我定义&lt;br /&gt;
主题可以更换，也可以自己写；配置根据喜好自己修改&lt;br /&gt;
具体请参考&lt;a href=&quot;http://jekyllbootstrap.com/usage/jekyll-quick-start.html&quot; title=&quot;Jekyll-Bootstrap快速开始&quot;&gt;Jekyll-Bootstrap快速开始&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;说些什么&lt;/h3&gt;
&lt;p&gt;其实这篇文章也算是一篇简单的译文吧&lt;br /&gt;
不管如何，看完基本能懂得怎么安装，使用Jekyll-Bootstrap就可以了&lt;br /&gt;
至于深入用法和配置，请参考&lt;a href=&quot;http://jekyllbootstrap.com&quot; title=&quot;Jekyll-Bootstrap官方网站&quot;&gt;Jekyll-Bootstrap官方网站&lt;/a&gt;&lt;br /&gt;
单词和句型都很简单(就连我四级都没过的人都看的懂)，你一定可以的，嘿嘿&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/08/14/website-by-using-jekyllboostrap</link>
                <guid>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/08/14/website-by-using-jekyllboostrap</guid>
                <pubDate>2014-08-14T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>使用jekyll搭建静态站点</title>
                <description>
&lt;h3 id=&quot;jekyll&quot;&gt;Jekyll的安装&lt;/h3&gt;

&lt;p&gt;假如系统未曾安装gem,请使用以下命令安装:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install ruby1.9.1-full
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装ruby(1.9.3)的时候，会同时安装gem1.8.23&lt;/p&gt;

&lt;p&gt;使用gem安装jekyll:&lt;code&gt; sudo gem install jekyll&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;假如报错的话，请安装ruby1.9.1的编译扩展组件的头文件:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install ruby1.9.1-dev    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本安装已经完成了，但是你执行&lt;code&gt;jekyll new myblog&lt;/code&gt;时，可能会报&lt;code&gt;Could not find a JavaScript runtime&lt;/code&gt;这样的错误，你需要使用一下命令解决：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install nodejs  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;jekyll-1&quot;&gt;Jekyll的使用&lt;/h3&gt;

&lt;p&gt;一个获取最简单 Jekyll 模板并生成静态站点的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll new myblog
New jekyll site installed in /home/temp/myblog.  
$ cd myblog
$ ls
about.md     css/      _includes/  _layouts/  _sass/
_config.yml  feed.xml  index.html  _posts/
$ jekyll serve
Configuration file: /home/temp/myblog/_config.yml
	    Source: /home/temp/myblog
       Destination: /home/temp/myblog/_site
      Generating... 
                	    done.
 Auto-regeneration: disabled. Use --watch to enable.
Configuration file: /home/temp/myblog/_config.yml
    Server address: http://0.0.0.0:4000/
  Server running... press ctrl-c to stop.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well,你可以browse to http://localhost:4000&lt;/p&gt;

&lt;p&gt;就是这么简单。从现在开始，你可以通过创建文章、改变头信息来控制模板和输出、修改 Jekyll 设置来使你的站点变得更有趣～&lt;/p&gt;

&lt;h4 id=&quot;jekyll-2&quot;&gt;运行jekyll开发服务器&lt;/h4&gt;

&lt;p&gt;jekyll使用一下命令，将会运行一个服务器，用来在本地查看你的静态站点&lt;br /&gt;
类似于在本地搭建的apache服务器，命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll serve  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个开发服务器将会在&lt;code&gt;http://localhost:4000&lt;/code&gt;运行&lt;/p&gt;

&lt;p&gt;假如你想脱离终端在后台运行,请使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll serve --detach
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想关闭服务器，可以使用&lt;code&gt;kill -9 PID&lt;/code&gt;命令&lt;br /&gt;
如果你找不到进程号，那么就用&lt;code&gt;ps aux | grep jekyll&lt;/code&gt;命令来查看，然后关闭服务器。&lt;/p&gt;

&lt;p&gt;如果你想查看变更并且自动再生成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll serve --watch 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;jekyll-3&quot;&gt;Jekyll的配置&lt;/h3&gt;

&lt;h4 id=&quot;rdiscountmd&quot;&gt;使用RDiscount来渲染md文档&lt;/h4&gt;

&lt;p&gt;如果你希望使用RDiscount来渲染markdown,而不是Maruku,只要确保RDiscount被正确的安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo gem install rdiscount  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行 Jekyll，并使用以下的参数选项：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll --rdiscount  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以在你的_config.yml中写入代码，从而不必指定参数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;markdown: rdiscount  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;pygments&quot;&gt;Pygments来实现代码高亮&lt;/h4&gt;

&lt;p&gt;如果你是一个程序员，那么你一定希望你的文章中代码高亮&lt;br /&gt;
不错，已经有好的解决办法了：通过 highlight 标签实现代码高亮&lt;br /&gt;
但在此之前，你需要首先安装 Pygments&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install python-pygments  
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;highlight&quot;&gt;在文章中引用highlight标签&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用pygmentize生成高亮CSS文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ pygmentize -f html -S default &amp;gt; pygments.css  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把生成的pygments.css移到你的css文件夹里，在post模板里引用一下&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改配置文件_config.xml,添加： &lt;code&gt;highlighter: pygments&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用格式如下:  &lt;br /&gt;
&lt;img src=&quot;/assets/imgs/heligher_demo.png&quot; alt=&quot;helighter_demo&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中&lt;code&gt;language&lt;/code&gt;可以从&lt;a href=&quot;http://pygments.org/docs/lexers/&quot; title=&quot;pygments语法高亮&quot;&gt;Syntax highlighter&lt;/a&gt;获取&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/%E8%BD%AF%E4%BB%B6/2014/08/14/static-website-by-jekyll</link>
                <guid>http://mwumli.github.io/%E8%BD%AF%E4%BB%B6/2014/08/14/static-website-by-jekyll</guid>
                <pubDate>2014-08-14T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>为你和你的项目建立一个站点--Github Pages</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#github-pages&quot; id=&quot;markdown-toc-github-pages&quot;&gt;什么是GitHub Pages?&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;两种站点服务&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;好处不言而喻&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;建站开始&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#user-or-organization-site&quot; id=&quot;markdown-toc-user-or-organization-site&quot;&gt;User or organization Site&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#githubrepository&quot; id=&quot;markdown-toc-githubrepository&quot;&gt;&lt;a href=&quot;https://github.com/new&quot; title=&quot;新建一个GitHub仓库&quot;&gt;创建一个仓库&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#git&quot; id=&quot;markdown-toc-git&quot;&gt;选择你正在使用的git客户端&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#terimal&quot; id=&quot;markdown-toc-terimal&quot;&gt;Terimal(终端)&lt;/a&gt;                &lt;ul&gt;
                  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;克隆刚创建的仓库&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#hello-world&quot; id=&quot;markdown-toc-hello-world&quot;&gt;Hello World&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#pushgithub&quot; id=&quot;markdown-toc-pushgithub&quot;&gt;push你的项目到github&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#github-for-windows-or-mac&quot; id=&quot;markdown-toc-github-for-windows-or-mac&quot;&gt;GitHub for Windows or Mac&lt;/a&gt;                &lt;ul&gt;
                  &lt;li&gt;&lt;a href=&quot;#clone&quot; id=&quot;markdown-toc-clone&quot;&gt;Clone仓库&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#createindexhtml&quot; id=&quot;markdown-toc-createindexhtml&quot;&gt;Create一个index.html文件&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#commit--sync&quot; id=&quot;markdown-toc-commit--sync&quot;&gt;commit &amp;amp;&amp;amp; Sync&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;未知区域&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;浏览你的网站吧&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#project-site&quot; id=&quot;markdown-toc-project-site&quot;&gt;project Site&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#generate-a-site&quot; id=&quot;markdown-toc-generate-a-site&quot;&gt;半路出家(Generate a Site)&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#repository-settings&quot; id=&quot;markdown-toc-repository-settings&quot;&gt;Repository Settings&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#automatic-generator&quot; id=&quot;markdown-toc-automatic-generator&quot;&gt;使用Automatic Generator&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;添加内容&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;选择一个主题&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#start-from-scratch&quot; id=&quot;markdown-toc-start-from-scratch&quot;&gt;白手起家(Start from scratch)&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#ph-pages&quot; id=&quot;markdown-toc-ph-pages&quot;&gt;创建一个ph-pages分支&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;使其成为默认分支&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#indexhtml&quot; id=&quot;markdown-toc-indexhtml&quot;&gt;创建一个index.html&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#hello-world-1&quot; id=&quot;markdown-toc-hello-world-1&quot;&gt;Hello World&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#commit&quot; id=&quot;markdown-toc-commit&quot;&gt;commit文件&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;查看你的项目站点&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;github-pages&quot;&gt;什么是GitHub Pages?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pages.github.com/&quot; title=&quot;GitHub Pages&quot;&gt;Github Pages&lt;/a&gt;是GitHub推出的一个新的服务&lt;br /&gt;
可以用来为你的&lt;a href=&quot;https://pages.github.com/&quot; title=&quot;GitHub 首页&quot;&gt;GitHub&lt;/a&gt;账户和你的每一个托管在&lt;a href=&quot;https://pages.github.com/&quot; title=&quot;GitHub 首页&quot;&gt;GitHub&lt;/a&gt;的项目建立一个web站点,show you and show your projects&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;两种站点服务&lt;/h3&gt;
&lt;p&gt;GitHub提供两种类型的站点服务:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;User or organization Site – 个人或组织站点&lt;/li&gt;
  &lt;li&gt;Project Site – 项目站点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每一个GitHub用户只可以创建一个个人站点，同时，你可以建立多个项目站点&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;好处不言而喻&lt;/h3&gt;
&lt;p&gt;建立个人或组织站点，让更多的人更好的认识你或你的组织&lt;br /&gt;
建立项目站点，你可以可视化的展示你的每一个项目，而不是让你的partner(或者更多喜欢这个项目的人)看着一堆源代码而手足无措&lt;/p&gt;

&lt;p&gt;你可以很轻松建立一个网站(尽管它是static),有专门的主机托管，还可以通过git进行版本控制，那不是很酷吗？&lt;/p&gt;

&lt;p&gt;好了，该做出你的选择了…&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;建站开始&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;user-or-organization-site&quot;&gt;User or organization Site&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;githubrepository&quot;&gt;&lt;a href=&quot;https://github.com/new&quot; title=&quot;新建一个GitHub仓库&quot;&gt;创建一个仓库&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;从&lt;a href=&quot;https://pages.github.com/&quot; title=&quot;GitHub 首页&quot;&gt;GitHub&lt;/a&gt;开始，&lt;a href=&quot;https://github.com/new&quot; title=&quot;新建一个GitHub仓库&quot;&gt;创建&lt;/a&gt;一个名为&lt;strong&gt;username.github.io&lt;/strong&gt;的仓库&lt;br /&gt;
其中,仓库名的第一部分&lt;em&gt;username&lt;/em&gt;是你在GitHub上的用户名(或组织名)&lt;br /&gt;
假如&lt;em&gt;username&lt;/em&gt;和你的用户名不匹配，站点将不能工作，因此，请确保它正确&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/user-repo@2x.png&quot; alt=&quot;在GirHub上新建一个仓库&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;git&quot;&gt;选择你正在使用的git客户端&lt;/h4&gt;

&lt;p&gt;这里讲述三种客户端：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Terimal – 这种经常用在Unix或类Unix系统下(Linux,mac当然也可以)&lt;/li&gt;
  &lt;li&gt;GitHub for Windows – 一看就知道，这是windows下的客户端&lt;/li&gt;
  &lt;li&gt;GitHub for Mac – 这个是Mac下的客户端&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好了，开始咯&lt;/p&gt;

&lt;h5 id=&quot;terimal&quot;&gt;Terimal(终端)&lt;/h5&gt;

&lt;h6 id=&quot;section-3&quot;&gt;克隆刚创建的仓库&lt;/h6&gt;

&lt;p&gt;在terimal下转到你想存放你项目的地方，然后clone这个新的仓库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/username/username.github.io  
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;hello-world&quot;&gt;Hello World&lt;/h6&gt;

&lt;p&gt;进入项目目录，新建一个&lt;em&gt;index.html&lt;/em&gt;,如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd username.github.io
$ echo &quot;Hello World&quot; &amp;gt; index.html  
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;pushgithub&quot;&gt;push你的项目到github&lt;/h6&gt;

&lt;p&gt;添加，提交，推送你对项目做出的改变&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add --all
$ git commit -m &quot;Initial commit&quot;
$ git push
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h5 id=&quot;github-for-windows-or-mac&quot;&gt;GitHub for Windows or Mac&lt;/h5&gt;

&lt;h6 id=&quot;clone&quot;&gt;Clone仓库&lt;/h6&gt;

&lt;p&gt;点击绿色的”Set up in Desktop”按钮&lt;br /&gt;
当GitHub桌面app打开，保存这个项目&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/setup-in-desktop@2x.png&quot; alt=&quot;从GitHub上启动桌面app&quot; /&gt;&lt;br /&gt;
假如app没有启动，那么双击的桌面app启动它，并且在app里克隆你的项目&lt;/p&gt;

&lt;h6 id=&quot;createindexhtml&quot;&gt;Create一个index.html文件&lt;/h6&gt;

&lt;p&gt;使用你最喜欢的编辑器，新建index.html,内容如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;I&#39;m hosted with GitHub Pages.&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，添加到你的项目&lt;/p&gt;

&lt;h6 id=&quot;commit--sync&quot;&gt;commit &amp;amp;&amp;amp; Sync&lt;/h6&gt;

&lt;p&gt;进入你的仓库(app里),commit你的变化，然后按下sync(同步)按钮&lt;br /&gt;
假如你在Windows下：&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/sync-windows@2x.png&quot; alt=&quot;windows提交并同步变化到项目&quot; /&gt;&lt;br /&gt;
假如你在Mac下：&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/sync-mac.png&quot; alt=&quot;Mac提交并同步变化到项目&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-4&quot;&gt;未知区域&lt;/h5&gt;

&lt;p&gt;假如你不知道你的平台，额，我无能为力了&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;浏览你的网站吧&lt;/h4&gt;

&lt;p&gt;启动你的浏览器，输入&lt;em&gt;http://username.github.io&lt;/em&gt;,然后，回车，接着，404，哈哈&lt;br /&gt;
等一下吧，新生成一个网站需要一段时间滴&lt;br /&gt;
时间也不是很长，大概10分钟吧&lt;br /&gt;
未来可能会做的更好，期待吧&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;project-site&quot;&gt;project Site&lt;/h3&gt;

&lt;p&gt;创建项目站点，有两种办法&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Generate a Site&lt;/li&gt;
  &lt;li&gt;Start from scratch&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实际上两者创建了分支gh-pages，只是第一种办法是在当前项目的主分支的当前状态开辟新的分支；第二种则是开辟一个没有父节点的分支&lt;br /&gt;
说的简单点，第一种的gh-pages分支有当前项目的主分支的内容,所以被称为&lt;em&gt;半路出家&lt;/em&gt;；而第二种则没有当前项目主分支的内容，完全像一个新的仓库,所以被称为&lt;em&gt;白手起家&lt;/em&gt;(Start from scratch)&lt;/p&gt;

&lt;h4 id=&quot;generate-a-site&quot;&gt;半路出家(Generate a Site)&lt;/h4&gt;

&lt;h5 id=&quot;repository-settings&quot;&gt;Repository Settings&lt;/h5&gt;

&lt;p&gt;访问&lt;a href=&quot;https://pages.github.com/&quot; title=&quot;GitHub 首页&quot;&gt;GirHub,com&lt;/a&gt;,创建一个新的仓库或者进入一个已存在的仓库&lt;br /&gt;
然后点击右手边的&lt;em&gt;Settings&lt;/em&gt;,进入项目设置页面&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/settings@2x.png&quot; alt=&quot;Repository settings&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;automatic-generator&quot;&gt;使用Automatic Generator&lt;/h5&gt;

&lt;p&gt;滑动settings页面到&lt;em&gt;GitHub Pages&lt;/em&gt;模块&lt;br /&gt;
按下&lt;em&gt;Automatic Page Generator&lt;/em&gt;按钮&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/automatic@2x.png&quot; alt=&quot;Automatic Pages Generator&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-6&quot;&gt;添加内容&lt;/h5&gt;

&lt;p&gt;使用内置编辑器添加内容给你的网站&lt;br /&gt;
假如你已经有了&lt;em&gt;README.md&lt;/em&gt;在你的项目，你可以点击右手边&lt;em&gt;Load README.md&lt;/em&gt;进行导入&lt;br /&gt;
当你做完这些，点击&lt;em&gt;Continue to Layouts&lt;/em&gt;&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/add-content@2x.png&quot; alt=&quot;add content to your project site&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-7&quot;&gt;选择一个主题&lt;/h5&gt;

&lt;p&gt;在顶部的提供主题里，选择一个你喜欢的主题&lt;br /&gt;
当你完成，点击右手边的&lt;em&gt;Publish page&lt;/em&gt;按钮&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/choose-layout@2x.png&quot; alt=&quot;choose a theme&quot; /&gt;&lt;/p&gt;

&lt;p&gt;半路出家搞定&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;start-from-scratch&quot;&gt;白手起家(Start from scratch)&lt;/h4&gt;

&lt;h5 id=&quot;ph-pages&quot;&gt;创建一个ph-pages分支&lt;/h5&gt;

&lt;p&gt;在你的项目页面，点击左手边分支下拉菜单，输入&lt;code&gt;gh-pages&lt;/code&gt;,然后按下enter进行创建&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/create-branch@2x.png&quot; alt=&quot;create gh-pages branch&quot; /&gt;&lt;br /&gt;
这个分支用于发布你的项目站点，你可以随时添加项目的进度等&lt;/p&gt;

&lt;h5 id=&quot;section-8&quot;&gt;使其成为默认分支&lt;/h5&gt;

&lt;p&gt;假如你已经为你的项目创建了新分支&lt;em&gt;gh-pages&lt;/em&gt;&lt;br /&gt;
进入仓库设置界面&lt;br /&gt;
在顶部的模块，改变默认分支为&lt;em&gt;gh-pages&lt;/em&gt;&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/default-branch@2x.png&quot; alt=&quot;change default branch&quot; /&gt;&lt;br /&gt;
这一步并不是必须的，因为此步的意义只是让其看起来更像一个web site project&lt;/p&gt;

&lt;h5 id=&quot;indexhtml&quot;&gt;创建一个index.html&lt;/h5&gt;

&lt;p&gt;返回仓库总览界面，点击紧邻仓库名旁边的plus图标创建一个名为index.html的文件  &lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/create-file@2x.png&quot; alt=&quot;create file&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;hello-world-1&quot;&gt;Hello World&lt;/h5&gt;

&lt;p&gt;为这个index.html文件添加内容&lt;em&gt;Hello world&lt;/em&gt;&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/hello-world@2x.png&quot; alt=&quot;hello-world&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;commit&quot;&gt;commit文件&lt;/h5&gt;

&lt;p&gt;滑动到页面底部，写上提交信息，提交这个新文件&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/commit-web@2x.png&quot; alt=&quot;commit-web&quot; /&gt;&lt;br /&gt;
呼，打完收工&lt;/p&gt;

&lt;p&gt;对咯，这种办法创建项目站点完全可以在Terimal,GitHub for Windows,还有GitHub for Mac下进行，请自行探索吧&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;查看你的项目站点&lt;/h4&gt;

&lt;p&gt;领年终奖了&lt;br /&gt;
启动你的浏览器，输入&lt;em&gt;http://username.github.io/repository&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;Repository&lt;/em&gt;是你的项目仓库名&lt;br /&gt;
然后，回车，接着，404，额，又被坑了&lt;br /&gt;
等10分钟吧，这么简单创建一个web站点，也不差这点时间对吧?&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/08/03/websites-by-github-pages</link>
                <guid>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/08/03/websites-by-github-pages</guid>
                <pubDate>2014-08-03T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>LAMP 环境搭建</title>
                <description>
&lt;h2 id=&quot;ubuntulamp&quot;&gt;Ubuntu下LAMP环境搭建&lt;/h2&gt;

&lt;h3 id=&quot;apache&quot;&gt;安装apache服务器&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install apache2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成，在浏览器中输入&lt;code&gt;http://localhost&lt;/code&gt;,出现&lt;code&gt;It works&lt;/code&gt;okay,安装完成&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;默认工作目录&lt;/h4&gt;
&lt;p&gt;不同版本的apache，工作目录有点差异&lt;br /&gt;
我的机器apache版本:&lt;code&gt;Server version: Apache/2.4.7 (Ubuntu)&lt;/code&gt;&lt;br /&gt;
所以默认工作目录是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/var/www/html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，你可以自定义虚拟主机目录:&lt;br /&gt;
1. 修改&lt;em&gt;/etc/apache2/sites-enabled/000-default.conf&lt;/em&gt;的&lt;code&gt;DocumentRoot /home/ya/LAMP&lt;/code&gt;为&lt;code&gt;DocumentRoot /home/ya/LAMP&lt;/code&gt;&lt;br /&gt;
2. 添加目录权限，需要添加下面这句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Directory /home/ya/LAMP/&amp;gt;
	Options Indexes FollowSymLinks
	AllowOverride None
	Require all granted
&amp;lt;/Directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加的地方有两处，任选一处即可：&lt;br /&gt;
 * 刚才修改的那句之后添加&lt;br /&gt;
 * 在&lt;em&gt;/etc/apache2/apache2.conf&lt;/em&gt;中寻找&lt;code&gt;Directory&lt;/code&gt;字眼，在这之后添加，其实也无所谓，只是放着之后，方便管理&lt;/p&gt;

&lt;h4 id=&quot;apache2&quot;&gt;apache2的配置布局&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;/etc/apache2/
|-- apache2.conf
|       `--  ports.conf
|-- mods-enabled
|       |-- *.load
|       `-- *.conf
|-- conf-enabled
|       `-- *.conf
|-- sites-enabled
|       `-- *.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;apache2.conf&lt;/code&gt; 主配置文件&lt;br /&gt;
当web服务器启动时，加载此文件，而此文件包含了其他配置文件&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ports.conf&lt;/code&gt; 定制监听端口  &lt;br /&gt;
被包含在&lt;code&gt;apache2.conf&lt;/code&gt;,并且可以随时修改&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;mods-enabled/*.conf&lt;/code&gt;, &lt;code&gt;conf-enabled/*.conf&lt;/code&gt;,&lt;code&gt;sites-enabled/*.conf&lt;/code&gt;下的配置文件分别是用来管理模块，全局配置片段，虚拟主机配置&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;apache2-1&quot;&gt;apache2的启动和停止&lt;/h4&gt;
&lt;p&gt;由于环境变量和加载配置的原因，我们不能直接使用&lt;code&gt;/usr/bin/apache2&lt;/code&gt;,需要使用&lt;code&gt;/etc/init.d/apache2&lt;/code&gt;,或者启用服务&lt;code&gt;service apache2&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;apache2-2&quot;&gt;apache2的启动&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;$ sudo /usr/bin/apache2 -k start	或者  	
$ sudo service apache2 start
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;apache2-3&quot;&gt;apache2的停止&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;$ sudo /usr/bin/apache2 -k stop	或者  	
$ sudo service apache2 stop  
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;apache2-4&quot;&gt;apache2的再启动&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;$ sudo /usr/bin/apache2 -k restart	或者  	
$ sudo service apache2 restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;apache2-5&quot;&gt;查看apache2的状态&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;$ service apache2 status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者， 直接访问&lt;code&gt;http://localhost&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;mysql&quot;&gt;安装MySQL数据库&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install mysql-server  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装mysql服务器的过程中，会自动安装mysql的命令行工具mysql-client，还有其他的一些工具&lt;br /&gt;
同时安装途中，需要为mysql设置root用户密码&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;测试&lt;/h4&gt;
&lt;p&gt;输入下面命令，按提示输入密码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mysql -uroot -p
Enter password: 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加入安装成功，出现下面画面:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 53
Server version: 5.5.37-0ubuntu0.14.04.1 (Ubuntu)

Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.

mysql&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;mysql-1&quot;&gt;配置MySQL&lt;/h4&gt;

&lt;h5 id=&quot;mysql-2&quot;&gt;MySQL常用命令&lt;/h5&gt;
&lt;p&gt;MySQL大部分命令是以&lt;code&gt;;&lt;/code&gt;结尾&lt;br /&gt;
1. 进入mysql&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ mysql -h [服务器地址] -u [用户名〕-p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是访问本地服务器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ mysql -h 127.0.0.1 -u [用户名〕 -p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如：&lt;code&gt;$ mysql -h 127.0.0.1 -u root -p&lt;/code&gt;
认证成功之后就进入mysql的命令控制台，以下都是在mysql的命令控制台的命令。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;显示已经存在的数据库&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql&amp;gt; SHOW DATABASES;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建数据库(linux下是区分大小写)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; CREATE DATABASE [数据库名];
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个受限用户 这个用户(testuser)只有一个数据库(这里是test库)的访问写入权限，这个数据库创建与删除表的权限，并且只能在本地登入，密码为userpasswd&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; grant select,insert,update,delete,create,alter on test.* to &#39;test&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;userpasswd&#39;;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;5.退出数据库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	quit 或者 \q
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;mysql-3&quot;&gt;MySQL配置文件（新手、无特殊要求勿动）&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;sudo vim /etc/mysql/my.cnf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有一个地方要注意 默认：是只允许本地访问数据库的这里不是说本机架设了网站，用户通过架设在的网页不能访问MySQL ,是指其它机子不能直接访问MySQL&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind-address 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解除限制只能本地访问mysql，如果需要其他机器访问，应使用如下语句，把这&lt;code&gt;bind-address 127.0.0.1&lt;/code&gt;句话用&lt;code&gt;#&lt;/code&gt;注释掉&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#bind-address 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;php&quot;&gt;安装PHP以及一些必要的模块&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install php5 libapache2-mod-php5 php5-mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;为什么安装&lt;code&gt;libapache2-mod-php5&lt;/code&gt;?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;安装这个软件包时，它会自动向&lt;code&gt;/etc/apache2/mods-available&lt;/code&gt;写入PHP的配置文件&lt;code&gt;php5.conf&lt;/code&gt;和 &lt;code&gt;php5.load&lt;/code&gt;，并把它们链接到了&lt;code&gt;/etc/apache2/mods-enabled&lt;/code&gt;目录。&lt;br /&gt;
安装的最后，软件包自动重新载入apache配置，php就可以在apache上跑了。无需手动的把Apache与PHP关联到一起。&lt;br /&gt;
没有它，会出现&lt;code&gt;无法解析php文件，浏览器提示下载所要打开的php文件&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo a2enmod php5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如没安装&lt;code&gt;libapache2-mod-php5&lt;/code&gt;,则提示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This module does not exist!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;a2enmod&lt;/code&gt;和 &lt;code&gt;a2dismod&lt;/code&gt;  enable or disable an apache2 module&lt;/p&gt;

&lt;p&gt;&lt;em&gt;为什么要安装&lt;code&gt;php5-mysql&lt;/code&gt;？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;因为该软件包会向&lt;code&gt;/etc/php5/conf.d&lt;/code&gt;目录写入配置文件，使得PHP能够支持mysql。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;测试&lt;/h4&gt;
&lt;p&gt;在apache的默认工作目录下(/var/www/html)中新建文件phpinfo.php,内容为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;? php phpinfo() ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在浏览器窗口输入&lt;code&gt;http://localhost/phpinfo.php&lt;/code&gt;,若出现php的相关信息，则安装成功&lt;/p&gt;

&lt;h3 id=&quot;phpmyadmin&quot;&gt;安装phpmyadmin&lt;/h3&gt;
&lt;p&gt;phpmyadmin是一个图形化的数据库管理软件&lt;br /&gt;
推荐从官网下载安装与配置&lt;br /&gt;
首先从&lt;a href=&quot;http://www.phpmyadmin.net/home_page/&quot; title=&quot;phpMyAdmin官网&quot;&gt;官网下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后解压缩到&lt;code&gt;apache&lt;/code&gt;工作目录(默认为/var/www/html)下的&lt;code&gt;phpMyAdmin&lt;/code&gt;(没有，自行创建)&lt;/p&gt;

&lt;p&gt;修改其配置文件(config.sample.inc.php)为&lt;code&gt;config.inc.php&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /var/www/html/phpMyAdmin
$ sudo cp config.sample.inc.php config.inc.php
$ vim config.inc.php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找到“blowfish_secret”在后面填上任意字母&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cfg[&#39;Servers&#39;][$i][&#39;auth_type&#39;]=&#39;cookie&#39;;
$cfg[&#39;Servers&#39;][$i][&#39;host&#39;]=&#39;localhost&#39;;
$cfg[&#39;Servers&#39;][$i][&#39;connect_type&#39;]=&#39;tcp&#39;;
$cfg[&#39;Servers&#39;][$i][&#39;compress&#39;]=&#39;false&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这四句基本都有，只需添加下面这句即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cfg[&#39;Servers&#39;][$i][&#39;extension&#39;]=&#39;mysql&#39;;	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存退出，继续安装php5-mcrypt&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install php5-mcrypt  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑php配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo vim etc/php5/apache2/php.ini
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;extension&lt;/code&gt;下面加上（任意独立一行）:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension=php_mcrypt.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存后，重启apache2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo service apache2 restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在浏览器里输入&lt;code&gt;http://localhost/phpMyAdmin&lt;/code&gt; &lt;br /&gt;
出现登陆数据库界面，嗯，成功了，终于不用面对那么冷淡的终端了&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;配置文件路径&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;apache 的配置文件路径 &lt;code&gt;/etc/apache2/apache2.conf&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;apache 网站字符编码配置路径 &lt;code&gt;/etc/apache2/conf-enabled/charset.conf&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;php.ini 路径 &lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mysql配置文件 路径 &lt;code&gt;/etc/mysql/my.cnf&lt;/code&gt;   一般不要使用，尤其是新手&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;默认网站根目录&lt;code&gt;/var/www/html&lt;/code&gt;(据说网站根目录应该是&lt;code&gt;/var/www&lt;/code&gt;，但我安装完之后，却不是这样的，难道改变了?)&lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/06/14/lamp-build</link>
                <guid>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/06/14/lamp-build</guid>
                <pubDate>2014-06-14T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>Linux文件系统的创建和挂载</title>
                <description>
&lt;h3 id=&quot;section&quot;&gt;如果您想&lt;/h3&gt;
&lt;p&gt;如果您想加载一个分区（文件系统）:&lt;br /&gt;
首先您得确认文件系统的类型，然后才能挂载使用&lt;br /&gt;
比如通过mount 加载，或者通过修改 /etc/fstab来开机自动加载&lt;/p&gt;

&lt;p&gt;如果您想添加一个新的分区或者增加一个新的硬盘:&lt;br /&gt;
您要通过分区工具(&lt;code&gt;fdisk&lt;/code&gt;)来添加分区&lt;br /&gt;
然后要创建分区的文件系统 (&lt;code&gt;mkfs&lt;/code&gt;) 
然后才是挂载文件系统(mount)&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;存储设备的分区&lt;/h3&gt;
&lt;p&gt;存储设备主要是本地硬盘、移动硬盘&lt;br /&gt;
由于磁盘很大并且为了满足我们各种需要，所以把硬盘分成若干个分区&lt;br /&gt;
比如我们可以用这个分区来安装Linux系统，那个分区用来 安装Windows系统…&lt;/p&gt;

&lt;p&gt;Linux中进行硬盘分区操作,可以使用fdisk&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;文件系统&lt;/h3&gt;
&lt;p&gt;对存储设备分区，这个新的分区还不能正常使用，我们需要对其格式化&lt;br /&gt;
即存储设备的格式化就是建立文件系统的过程&lt;/p&gt;

&lt;p&gt;Windows下的文件系统,熟知有NTFS, msdos …
Linux下的文件系统，熟知的有ext2、ext3、swap 交换分区… … &lt;br /&gt;
U盘的文件系统，有FAT32, fat16 … 
还有一些咱们不熟悉的操作系统的文件系统等&lt;/p&gt;

&lt;p&gt;我们通常使用文件系统格式化工具进行&lt;em&gt;文件系统的建立&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;文件系统的建立&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;mkfs&lt;/code&gt;就是Linux下常用的建立文件系统的工具&lt;br /&gt;
&lt;code&gt;mkfs.nefs&lt;/code&gt;, &lt;code&gt;mkfs.vfat&lt;/code&gt;, &lt;code&gt;mkfs.ext2&lt;/code&gt;, &lt;code&gt;mkfs.ext3&lt;/code&gt;, &lt;code&gt;mkfs.ext4&lt;/code&gt;等工具，也是Linux下建立文件系统常用工具&lt;br /&gt;
事实上，&lt;code&gt;mkfs&lt;/code&gt;也是更具提供的格式化文件系统类型参数，来调用这些工具实现指定文件系统的建立&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mkfs&lt;/code&gt;的命令格式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkfs -t 文件系统类型 存储设备 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，查看Linux下所有分区，确定分区的存储设备&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo fdsik -l
Disk /dev/sda: 120.0 GB, 120034123776 bytes
255 heads, 63 sectors/track, 14593 cylinders, total 234441648 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes
Disk identifier: &amp;lt;0x000d9852&amp;gt;	&amp;lt;/0x000d9852&amp;gt;

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1            2048    15624191     7811072   82  Linux swap / Solaris
/dev/sda2   *    15624192   234440703   109408256   83  &amp;lt;Linux&amp;gt;	&amp;lt;/Linux&amp;gt;

Disk /dev/sdb: 500.1 GB, 500107862016 bytes
255 heads, 63 sectors/track, 60801 cylinders, total 976773168 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes
Disk identifier: &amp;lt;0x5be4a3f9&amp;gt;	&amp;lt;/0x5be4a3f9&amp;gt;

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1   *        2048   409602047   204800000    7  HPFS/NTFS/exFAT
/dev/sdb2       409602048   593922047    92160000    7  HPFS/NTFS/exFAT
/dev/sdb3       593922048   778242047    92160000    7  HPFS/NTFS/exFAT
/dev/sdb4       778244094   976771071    99263489    5  Extended
Partition 4 does not start on physical sector boundary.
/dev/sdb5       778244096   797773823     9764864   82  Linux swap / Solaris
/dev/sdb6       797775872   976771071    89497600   83  &amp;lt;Linux&amp;gt;	&amp;lt;/Linux&amp;gt;

Disk /dev/sde: 16.4 GB, 16358768640 bytes
255 heads, 63 sectors/track, 1988 cylinders, total 31950720 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: &amp;lt;0xcad4ebea&amp;gt;	&amp;lt;/0xcad4ebea&amp;gt;

   Device Boot      Start         End      Blocks   Id  System
/dev/sde4   *          63    31950719    15975328+   c  W95 FAT32 (LBA)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/dev/sde4&lt;/code&gt;是我U盘，以此为实验&lt;br /&gt;
接着，为存储设备重新建立文件系统，即格式化一个新的文件系统&lt;br /&gt;
那么，建立ext4文件系统&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo mkfs -t ext4 /dev/sde4  
mke2fs 1.42.9 (4-Feb-2014)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
999424 inodes, 3993832 blocks
199691 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=4093640704
122 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks: 
	32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208
 
Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (32768 blocks): done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样，我们使用下面这条命令，也可以达到一样的效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo mkfs.ext4 /dev/sde4  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;swap&quot;&gt;关于swap分区&lt;/h4&gt;
&lt;p&gt;创建此分区为swap 交换分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkswap /dev/sda6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加载交换分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ swapon /dev/sda6 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭交换分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ swapoff /dev/sda6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看交换分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ swapon -s		或者  
$ cat /proc/swaps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以考虑下下面这种情况:内存不足，swap交换分区爆满,您的硬盘不能再分区&lt;br /&gt;
此时怎么办呢? 你可以创建一个swap文件,并把其当作格式化swap来使用&lt;/p&gt;

&lt;p&gt;创建一个大小为512M 的swap 文件，在/tmp目录中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dd if=/dev/zero of=/tmp/swap bs=1024 count=524288
$ mkswap /tmp/swap
$ swapon /tmp/swap
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;文件系统的挂载&lt;/h3&gt;
&lt;p&gt;当我们需要访问某个文件系统时，必须要进行文件系统的挂载&lt;br /&gt;
挂载文件系统，目前有两种方法:&lt;br /&gt;
1. 通过 mount 来挂载&lt;br /&gt;
2. 通过/etc/fstab文件来开机自动挂载&lt;/p&gt;

&lt;h4 id=&quot;mount-&quot;&gt;通过mount 来挂载磁盘分区（或存储设备）&lt;/h4&gt;
&lt;p&gt;mount的命令格式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mount -t type device dir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;参数说明:&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;-t&lt;/strong&gt; 指定文件系统的类型&lt;br /&gt;
一般的情况下不必指定有时也能识加 &lt;br /&gt;
&lt;code&gt;-t &lt;/code&gt;后面是&lt;code&gt;type&lt;/code&gt;,&lt;code&gt;type&lt;/code&gt;是文件系统类型( ext3 、ext2 、reiserfs、vfat 、ntfs 等)&lt;br /&gt;
如果你忘记了文件系统，&lt;code&gt;type&lt;/code&gt;就是 &lt;code&gt;auto&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;&lt;em&gt;需要注意的是:&lt;/em&gt; mount挂载文件系统,当挂载目录在挂载文件系统之前有文件存在,挂载之后文件消失(实际存在，只是看不见),只能看见当前挂载文件系统下的文件;当然，在卸载后，则会恢复&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;device&lt;/strong&gt; 指存储设备&lt;br /&gt;
比如/dev/hda1， /dev/sda1 ，cdrom 等… &lt;br /&gt;
你可以通过&lt;code&gt;fdisk -l&lt;/code&gt;查看存储设备&lt;br /&gt;
一般的情况下光驱设备是/dev/cdrom ；&lt;br /&gt;
软驱设备是/dev/fd0 ；&lt;br /&gt;
硬盘及移动硬盘以 fdisk -l 的输出为准；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;dir&lt;/strong&gt; 挂载点&lt;br /&gt;
一般是个目录,这个目录通常被使用&lt;code&gt;chmod&lt;/code&gt;改写权限为&lt;code&gt;777&lt;/code&gt;，这样任何用户都能写入了&lt;br /&gt;
假如&lt;code&gt;dir&lt;/code&gt;为空，那么会自动寻找挂载点&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;查看已挂载的分区&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用df&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ df -lh
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用mount&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ mount
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;你也可以通过显示/proc/mounts 或 /etc/mtab 来查看类似信息&lt;/p&gt;

&lt;h4 id=&quot;etcfstab&quot;&gt;通过/etc/fstab文件来开机自动挂载文件系统&lt;/h4&gt;
&lt;p&gt;这个文件中存在的文件系统，是开机自动挂载&lt;br /&gt;
因此，当我们需要开机挂载某些文件系统的话，就直接在此文件后面添加（当然，按照固定格式）&lt;/p&gt;

&lt;p&gt;此文件每条记录的格式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;file system&amp;gt;  &amp;lt;mount point&amp;gt; &amp;lt;type&amp;gt; &amp;lt;options&amp;gt; &amp;lt;dump&amp;gt;  &amp;lt;pass&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;一共6个字段:&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;file system&lt;/code&gt;: 设备名，即文件系统，例如/dev/sda1&lt;br /&gt;
&lt;code&gt;mount point&lt;/code&gt;: 文件系统挂载点&lt;br /&gt;
&lt;code&gt;type&lt;/code&gt;: 文件系统类型&lt;br /&gt;
&lt;code&gt;options&lt;/code&gt;: mount挂载文件时，使用-o指定的选项,具体查阅man手册&lt;br /&gt;
&lt;code&gt;dump&lt;/code&gt;: 文件系统是否需要dump 备份，1是需要，0 是不需要&lt;br /&gt;
&lt;code&gt;pass&lt;/code&gt;: 是否在系统启动时，通过fsck磁盘检测工具来检查文件系统，1是需要，0是不需要，2是跳过&lt;/p&gt;

&lt;p&gt;swap分区在fatab中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LABEL=SWAP-hda7 swap swap defaults 0 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文件系统为/dev/sdd4,文件系统挂载点为~/mnt,文件系统类型vfat:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/dev/sdd4 ~/mnt vfat defaults 0 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;文件系统的卸载&lt;/h3&gt;
&lt;p&gt;使用umount来卸载&lt;br /&gt;
卸载一个已有文件系统时，指出挂载点或者设备名其中一个就足够了，没有必要&amp;gt; 都指出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo umount device	或者  
$ sudo umount dir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;需要注意的是:&lt;/em&gt;&lt;br /&gt;
1. 当一个文件系统被卸载之后，作为挂载点的目录下的那些文件会再次出现&lt;br /&gt;
2. 如果您想卸载一个文件系统，而此时进程已打开了该文件系统上的文件，将会出现一个错误消息。&lt;br /&gt;
3. 卸载文件系统之前，您应当确认没有进程正在该文件系统的文件上运行(&lt;code&gt;lsof -w device&lt;/code&gt; 或者 &lt;code&gt;lsof -w dir&lt;/code&gt;再或者&lt;code&gt;lsof -w single_file&lt;/code&gt;)&lt;br /&gt;
4. &lt;code&gt;umount&lt;/code&gt;使用&lt;code&gt;-l&lt;/code&gt;参数进行懒卸载(直接从文件系统树分离文件系统，然后，在文件系统空闲时，清理文件系统附加项)&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;两个比较特殊的文件&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;/dev/null&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  它是空设备，也称为位桶（bit bucket）。
  任何写入它的输出都会被抛弃。
  如果不想让消息以标准输出显示或写入文件，那么可以将消息重定向到位桶。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般用于错误信息或者垃圾信息重定向&lt;br /&gt;
* /dev/zero&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	该设备无穷尽地提供0  
	它可以用于向设备或文件写入字符串0。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般用于初始化某个文件和分区,例如&lt;code&gt;dd if=/dev/zero of=/tmp/heihei&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-8&quot;&gt;相关链接&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://os.51cto.com/art/201012/239233_all.htm&quot; title=&quot;Linux文件系统的安装和卸载&quot;&gt;《Linux文件系统的安装和卸载》&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/l-lpic1-v3-104-1/&quot; title=&quot;学习 Linux，101: 创建分区和文件系统&quot;&gt;《学习 Linux，101: 创建分区和文件系统》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/06/10/linux-file-system</link>
                <guid>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/06/10/linux-file-system</guid>
                <pubDate>2014-06-10T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>Sublime Text 2的使用</title>
                <description>
&lt;p&gt;假如你还没安装ST2,那么去&lt;a href=&quot;/记录/2014/06/08/st2_install_config/&quot; title=&quot;Sublime Text 2的安装与配置&quot;&gt;安装它&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;多项选择，多项编辑&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;鼠标选中多行，按下 Ctrl+Shift+L (Command+Shift+L) 即可同时编辑这些行；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;鼠标选中文本，反复按 CTRL+D (Command+D) 即可继续向下同时选中下一个相同的文本进行同时编辑；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;鼠标选中文本，按下 Alt+	F3 (Win) 或 Ctrl+Command+G(Mac) 即可一次性选择全部的相同文本进行同时编辑；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Shift+鼠标右键 (Win) 或 Option+鼠标左键 (Mac) 或使用鼠标中键可以用鼠标进行竖向多行选择；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ctrl+鼠标左键(Win) 或 Command+鼠标左键(Mac) 可以手动选择同时要编辑的多处文本&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;command-palette&quot;&gt;命令行面板(Command Palette)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Ctrl+Shift+P&lt;/strong&gt;唤醒Command Palette　　　
输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sspy	---&amp;gt;set the syntax of the current file to Python
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，还有很多命令，使用过程中慢慢发现吧&lt;/p&gt;

&lt;h3 id=&quot;goto-anything&quot;&gt;快速导航面板(Goto Anything)&lt;/h3&gt;

&lt;h4 id=&quot;section-1&quot;&gt;快速切换文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Ctrl+p&lt;/strong&gt;唤醒&lt;em&gt;Goto Anything&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;输入文件名，面板下拉框将出现所有匹配的文件名(当然，在这之前必须线打开一个目录作为搜索根目录)&lt;/p&gt;

&lt;p&gt;可以试着在使用Up和Down滚动条目，会有意外的发现哦&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;在指定文件中快速查找函数，文本，跳转指定行&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;查找函数，或者id（HTML）&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  file@func
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查找文本&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  file#text
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;跳转指定行&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  file:num
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当&lt;em&gt;file&lt;/em&gt;省略时，默认当前编辑文件&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;打开一个项目&lt;/h3&gt;
&lt;p&gt;使用ST2可以打开一个项目，这样我们就可以很方便的对一个项目进行编辑，修改了&lt;br /&gt;
打开的项目文件会展示在左侧的&lt;code&gt;side bar&lt;/code&gt;&lt;br /&gt;
当我们编辑某文件时，希望&lt;code&gt;Side bar&lt;/code&gt;在我们需要时候展示，在我们不需要的时候消失，你可以这样做&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ctrl + k Ctrl + b   --&amp;gt;隐藏时显示，显示时隐藏 for Side bar 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，你也可以使用鼠标进行选择，但是那样不可避免降低你的速度&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;模糊匹配&lt;/h3&gt;
&lt;p&gt;无论是Command Palette还是Goto Anything,他们都采用模糊匹配，故不需要输入全命令和全文件名&lt;br /&gt;
例如:在文件shiluodechenai.c中查找func_word&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sldca@fw  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;甚至可能更短&lt;/p&gt;

&lt;h3 id=&quot;package-control&quot;&gt;Package Control(扩展包管理器)&lt;/h3&gt;
&lt;p&gt;用来管理（安装，卸载）插件，皮肤的管理器，和vim中Vundle差不多，不过看起来更简单&lt;br /&gt;
默认不含有此管理器，我们需要自己手动安装&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;安装&lt;/h4&gt;

&lt;h5 id=&quot;section-6&quot;&gt;手动版(复杂点)&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在 SublimeText2 的目录里面找到 &lt;code&gt;Data &amp;gt; Installed Packages&lt;/code&gt; 的文件夹 (如没有请手动新建)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在这里下载 &lt;a href=&quot;http://dl.iplaysoft.com/files/1774.html#download_list&quot;&gt;Package Control.sublime-package&lt;/a&gt; 文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将下载到的文件放进去 Installed Packages 里面&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重新启动 Sublime Text 即可&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;section-7&quot;&gt;自动版(保持网络，简单)&lt;/h5&gt;

&lt;p&gt;如果你按照上面的方法确实搞不定，&lt;br /&gt;
可以试试按键盘 Ctrl+~ （数字1左边的按键）调出控制台，&lt;br /&gt;
然后拷贝下面的代码进去并回车，  它会自动帮你新建文件夹并下载文件的，与上面的方法最终效果是一样的&lt;br /&gt;
代码如下：　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import urllib2,os; pf=&#39;Package Control.sublime-package&#39;; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),&#39;wb&#39;).write(urllib2.urlopen(&#39;http://sublime.wbond.net/&#39;+pf.replace(&#39; &#39;,&#39;%20&#39;)).read()); print &#39;Please restart Sublime Text to finish installation&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-8&quot;&gt;使用&lt;/h4&gt;

&lt;p&gt;如果 Package Control 已经安装成功，&lt;br /&gt;
那么 Ctrl+Shift+P 调用命令面板，我们就会找到一些以“Package Control:”开头的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Install Package	---&amp;gt;(安装扩展)
 List Packages 		---&amp;gt;(列出全部扩展)
 Remove Package		---&amp;gt;(移除扩展)
 Upgrade Package	---&amp;gt;(升级扩展)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在命令面板输入 “Package Control: Install Package“即会列出全部可以安装的扩展&lt;br /&gt;
从列表可以看到，4GL、AAAPackageDev 那些就是插件的名称  &lt;br /&gt;
选择它们就可以进行下载安装了&lt;/p&gt;

&lt;p&gt;此外，你还可以&lt;a href=&quot;https://sublime.wbond.net/&quot;&gt;在这里看到 Web 版的扩展列表和详细的说明&lt;/a&gt; （这俩列表的数据应该是同步的)&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;一些比较好的插件&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Emmet&lt;/strong&gt;: 以前被称作为Zen Coding,如果你从事Web前端开发的话，对该插件一定不会陌生。&lt;br /&gt;
它使用仿CSS选择器的语法来快速开发HTML和CSS,在一个扩展框中输入符合规范的表达式，它会动态生成相应的代码 ,或者直接在文本中使用表达式，按扩展键(Tab)进行扩展&lt;/p&gt;

&lt;p&gt;具体使用见:&lt;a href=&quot;http://www.w3cplus.com/tools/emmet-cheat-sheet.html&quot;&gt;表达式语法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Gits&lt;/strong&gt;： 可以轻松集成 GitHub&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SFTP&lt;/strong&gt;： 直接编辑 FTP 或 SFTP 服务器上的文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ConvertToUTF8&lt;/strong&gt;： ST2只支持utf8编码，该插件可以显示与编辑 GBK, BIG5, EUC-KR, EUC-JP, Shift_JIS 等编码的文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Clipboard History&lt;/strong&gt;： 剪切板历史&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WordPress&lt;/strong&gt;： 集成一些WordPress的函数，对于像我这种经常要写WP模版和插件的人特别有用！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HtmlTidy&lt;/strong&gt;： 清理与排版你的HTML代码&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PHPTidy&lt;/strong&gt;： 整理与排版PHP代码&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;YUI Compressor&lt;/strong&gt;： 压缩JS和CSS文件&lt;/p&gt;
</description>
                <link>http://mwumli.github.io/%E8%BD%AF%E4%BB%B6/2014/06/08/st2-some-usage</link>
                <guid>http://mwumli.github.io/%E8%BD%AF%E4%BB%B6/2014/06/08/st2-some-usage</guid>
                <pubDate>2014-06-08T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>Sublime Text 2的安装与配置</title>
                <description>
&lt;h3 id=&quot;section&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;Sublime Text 2是一个超强代码编辑器或者文本编辑器&lt;/p&gt;

&lt;p&gt;它小巧绿色且速度非常快，跨平台支持Win/Max/Linux,支持32位与64位&lt;/p&gt;

&lt;p&gt;它支持各种流行编程语言的语法高亮、代码补全&lt;/p&gt;

&lt;p&gt;它收费，而且很贵，但是它提供免费使用，当然无限期，无限制，只是偶尔提醒你木有购买，而且频率很低，这点让人觉得很赞&lt;/p&gt;

&lt;p&gt;它可以像vim一样安装插件，增强本身没有的功能，而且不需要你从特殊站点下载插件，然后费尽心思的放在某处(譬如安装目录)&lt;br /&gt;
只需要一两个命令，就可以方便下载，等待使用&lt;/p&gt;

&lt;p&gt;对咯，它有很大一个缺点，名字太长了，嘿嘿，更多的时候我们简称其为ST2&lt;/p&gt;

&lt;h3 id=&quot;ubuntu&quot;&gt;Ubuntu下的安装&lt;/h3&gt;

&lt;h4 id=&quot;section-1&quot;&gt;添加源安装(简单)&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ sudo add-apt-repository ppa:webupd8team/sublime-text-2  
$ sudo apt-get update  
$ sudo apt-get install sublime-text
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-2&quot;&gt;压缩包安装(还需要更多的配置)&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;解压安装包到/opt下(当然其他目录也可以)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; # tar -jxvf Sublime\ Text\ 2.0.2\ x64.tar.bz2 -C /opt/brackets/  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;建立软链接到/usr/bin下&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; # ln -s /opt/sublime_text_2/sublime_text /usr/bin/sublime-text
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样，我们就可以在命令行的任意工作目录下键入&lt;strong&gt;sublime-text&lt;/strong&gt;打开ST2咯&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;放到应用程序菜单&lt;/h3&gt;

&lt;p&gt;更多的时候我们更想把它放在应用程序菜单,方便打开使用&lt;br /&gt;
( 当你采用添加源安装,它已经放在应用程序菜单中了 )&lt;/p&gt;

&lt;p&gt;因此建立一个sublime-text-2.desktop文件，放入/usr/share/applications/下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	# touch /usr/share/applications/sublime-text-2.desktop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后copy一下内容到此文件中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	#!/usr/bin/env xdg-open	
	[Desktop Entry]
	Name=Sublime Text 2
	GenericName=Text Editor
	Comment=Sophisticated text editor for code, html and prose¬
	Exec=/usr/bin/subl %F
	Terminal=false
	Type=Application
	MimeType=text/plain;text/x-chdr;text/x-csrc;text/x-c++hdr;text/x-c++src;text/x-java;text/x-dsrc;text/x-pascal;text/x-perl;text/x-python;application/x-php;application/x-httpd-php3;application/x-httpd-php4;application/x-http d-php5;application/xml;text/html;text/css;text/x-sql;text/x-diff;x-directory/normal;inode/directory;
	Icon=sublime_text
	Categories=TextEditor;Development;Utility;
	StartupNotify=true
	Actions=Window;Document;
	
	X-Desktop-File-Install-Version=0.22
	
	[Desktop Action Window]
	Name=New Window
	Exec=/usr/bin/subl -n
	OnlyShowIn=Unity;
	
	[Desktop Action Document]
	Name=New File
	Exec=bash -c &#39;LD_PRELOAD=/usr/lib/libsublime-imfix.so /usr/bin/subl&#39; --com mand new_file
	OnlyShowIn=Unity
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;okay,可能你还要注销或者重启一下系统&lt;br /&gt;
然后按下Windows徽标键,这时候弹出搜索面板，随着你键入应用程序的名字(Sublime Text 2)，会逐渐确定你想打开的应用程序&lt;br /&gt;
点击应用程序图标，打开它&lt;/p&gt;

&lt;h3 id=&quot;dock&quot;&gt;固化在左侧的dock里（默认都在左侧）&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;当你通过命令行或者应用程序菜单启动ST2后&lt;/li&gt;
  &lt;li&gt;在dock里会出现ST2的图标,点击右键，选择&lt;code&gt;lock from Launcher&lt;/code&gt;,然后它就被锁定在dock中了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以后你就可以直接可以在dock中看到ST2咯&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;解决中文输入法的问题&lt;/h3&gt;

&lt;p&gt;安装完ST2后，发现竟然无法输入中文&lt;br /&gt;
但是，不用担心，网上已经给出解决办法&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;新建一个.c文件&lt;strong&gt;sublime-imfix.c&lt;/strong&gt;,内容如下:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; /*
	
  * sublime-imfix.c Use LD_PRELOAD to interpose some function to fix sublime
  * input method support for linux. By Cjacker Huang &amp;lt;jianzhong.huang at
  * i-soft.com.cn&amp;gt;
  * 
  * gcc -shared -o libsublime-imfix.so sublime_imfix.c `pkg-config --libs
  * --cflags gtk+-2.0` -fPIC LD_PRELOAD=./libsublime-imfix.so sublime_text 
	
  */
	
 #include &amp;lt;gtk/gtk.h&amp;gt;		
 #include &amp;lt;gdk/gdkx.h&amp;gt;
	
 typedef GdkSegment GdkRegionBox;		
	
	
 struct _GdkRegion {
     long            size;
     long            numRects;
     GdkRegionBox   *rects;
     GdkRegionBox    extents;
 };		
 GtkIMContext   *local_context;		
	
 void gdk_region_get_clipbox(const GdkRegion * region, GdkRectangle * rectangle)
 {
	
     g_return_if_fail(region != NULL);
     g_return_if_fail(rectangle != NULL);		
		

     rectangle-&amp;gt;x = region-&amp;gt;extents.x1;
     rectangle-&amp;gt;y = region-&amp;gt;extents.y1;
     rectangle-&amp;gt;width = region-&amp;gt;extents.x2 - region-&amp;gt;extents.x1;
     rectangle-&amp;gt;height = region-&amp;gt;extents.y2 - region-&amp;gt;extents.y1;
     GdkRectangle    rect;		
		

     rect.x = rectangle-&amp;gt;x;
     rect.y = rectangle-&amp;gt;y;
     rect.width = 0;
     rect.height = rectangle-&amp;gt;height;
	
     // The caret width is 2;
     // Maybe sometimes we will make a mistake, but for most of the time, it
     // should be the caret.
     if (rectangle-&amp;gt;width == 2 &amp;amp;&amp;amp; GTK_IS_IM_CONTEXT(local_context)) {
         gtk_im_context_set_cursor_location(local_context, rectangle);
     }
 }		
	
	
 // this is needed, for example, if you input something in file dialog and
 // return back the edit area
 // context will lost, so here we set it again.		
	
	
 static GdkFilterReturn event_filter(GdkXEvent * xevent, GdkEvent * event,
                                     gpointer im_context)
 {
     XEvent         *xev = (XEvent *) xevent;		

     if (xev-&amp;gt;type == KeyRelease &amp;amp;&amp;amp; GTK_IS_IM_CONTEXT(im_context)) {

         GdkWindow      *win = g_object_get_data(G_OBJECT(im_context), &quot;window&quot;);		
	
         if (GDK_IS_WINDOW(win))
             gtk_im_context_set_client_window(im_context, win);
	
     }
	
     return GDK_FILTER_CONTINUE;
 }		
	
	
 void gtk_im_context_set_client_window(GtkIMContext * context,
                                       GdkWindow * window)
 {
	
     GtkIMContextClass *klass;		
	
     g_return_if_fail(GTK_IS_IM_CONTEXT(context));
     klass = GTK_IM_CONTEXT_GET_CLASS(context);
	
     if (klass-&amp;gt;set_client_window)
         klass-&amp;gt;set_client_window(context, window);		
			
     if (!GDK_IS_WINDOW(window))
         return;
	
     g_object_set_data(G_OBJECT(context), &quot;window&quot;, window);

     int             width = gdk_window_get_width(window);
     int             height = gdk_window_get_height(window);		
	
     if (width != 0 &amp;amp;&amp;amp; height != 0) {
	
         gtk_im_context_focus_in(context);
         local_context = context;
     }
	
     gdk_window_add_filter(window, event_filter, context);
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装C/C++编译环境和libgtk2.0dev&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo apt-get install build-essential
 $ sudo apt-get install libgtk2.0-dev
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编译共享库&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ gcc -shared -o libsublime-imfix.so sublime-imfix.c  `pkg-config --libs --cflags gtk+-2.0` -fPIC
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;移动共享库到/usr/lib下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ sudo mv libsublime-imfix.so /usr/lib/
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;修改启动方式
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;命令行启动&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  $ LD_PRELOAD=./libsublime-imfix.so sublime-text
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;图形化启动&lt;br /&gt;
 修改/usr/share/applications/sublime-text-2.desktop:&lt;br /&gt;
 将&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  Exec=/usr/bin/subl %F  
&lt;/code&gt;&lt;/pre&gt;

        &lt;p&gt;修改为&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  Exec=bash -c &#39;LD_PRELOAD=/usr/lib/libsublime-imfix.so /usr/bin/subl %F&#39;
&lt;/code&gt;&lt;/pre&gt;

        &lt;p&gt;将&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  Exec=/usr/bin/subl -n
&lt;/code&gt;&lt;/pre&gt;

        &lt;p&gt;修改为&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  Exec=bash -c &#39;LD_PRELOAD=/usr/lib/libsublime-imfix.so /usr/bin/subl&#39; -n
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;st2&quot;&gt;设置ST2默认打开文档类型&lt;/h3&gt;
&lt;p&gt;ST2不仅仅是一个超级代码编辑器，更重要的是它也是一个文档编辑器&lt;br /&gt;
既然这样，我们为何还在使用gedit这个古老的东西呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim /usr/share/applications/defaults.list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用vim的替换功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1,$s/gedit.desktop/sublime-text-2.desktop/g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注销或者重启一下&lt;br /&gt;
这样，你右键文件，会出现使用&lt;code&gt;Open With Sublime Text 2&lt;/code&gt;
有时候，这样可能不会有效果(额，我也不太清楚为什么，如果您知道，请留言)&lt;br /&gt;
我们可以对单独每种类型设定:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;右键文件，选择&lt;code&gt;Propertites&lt;/code&gt;（属性）&lt;/li&gt;
  &lt;li&gt;点击&lt;code&gt;Open With&lt;/code&gt;,默认应用下选择&lt;code&gt;Sublime Text 2&lt;/code&gt;&lt;br /&gt;
这样，你双击打开每一个这种类型的文件，都会自动用&lt;code&gt;Sublime Text 2&lt;/code&gt;打开&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-5&quot;&gt;一枚注册码&lt;/h3&gt;
&lt;p&gt;虽然可以一直免费使用，但是弹出来的警告框总是令人很不爽&lt;br /&gt;
有幸在网络上搜集到一枚注册码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;----- BEGIN LICENSE -----
Andrew Weber
Single User License
EA7E-855605
813A03DD 5E4AD9E6 6C0EEB94 BC99798F
942194A6 02396E98 E62C9979 4BB979FE
91424C9D A45400BF F6747D88 2FB88078
90F5CC94 1CDC92DC 8457107A F151657B
1D22E383 A997F016 42397640 33F41CFC
E1D0AE85 A0BBD039 0E9C8D55 E1B89D5D
5CDB7036 E56DE1C0 EFCC0840 650CD3A6
B98FC99C 8FAC73EE D2B95564 DF450523
------ END LICENSE ------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过，若是大家手头方便的话，不妨支持一下正版，毕竟辛辛苦苦做一个软件不容易，何况还是这么好的软件(将来可能会更好)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;st2-1&quot;&gt;学学ST2的用法&lt;/h2&gt;

&lt;p&gt;假如你已经安装好了ST2,那么学学怎么&lt;a href=&quot;/记录/2014/06/08/st2-some-usage/&quot; title=&quot;Sublime Text 2的使用&quot;&gt;ST2的一些操作和插件管理&lt;/a&gt;吧&lt;/p&gt;
</description>
                <link>http://mwumli.github.io/%E8%BD%AF%E4%BB%B6/2014/06/08/st2-install-config</link>
                <guid>http://mwumli.github.io/%E8%BD%AF%E4%BB%B6/2014/06/08/st2-install-config</guid>
                <pubDate>2014-06-08T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>Vim下fancy的插件</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;简要声明&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#taglist&quot; id=&quot;markdown-toc-taglist&quot;&gt;TagList&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;简述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vundle&quot; id=&quot;markdown-toc-vundle&quot;&gt;添加到Vundle管理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vimrc&quot; id=&quot;markdown-toc-vimrc&quot;&gt;.vimrc中的一些配置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#echofunc&quot; id=&quot;markdown-toc-echofunc&quot;&gt;echofunc&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;简述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vundle-1&quot; id=&quot;markdown-toc-vundle-1&quot;&gt;添加到Vundle管理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#winmanager&quot; id=&quot;markdown-toc-winmanager&quot;&gt;WinManager&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;简述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vundle-2&quot; id=&quot;markdown-toc-vundle-2&quot;&gt;加入Vundle管理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vimrc-1&quot; id=&quot;markdown-toc-vimrc-1&quot;&gt;.vimrc中的一些配置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#minibufexpl&quot; id=&quot;markdown-toc-minibufexpl&quot;&gt;minibufexpl&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;简述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vundle-3&quot; id=&quot;markdown-toc-vundle-3&quot;&gt;加入Vundle管理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vimrc-2&quot; id=&quot;markdown-toc-vimrc-2&quot;&gt;.vimrc中的一些配置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#minibufexpl-1&quot; id=&quot;markdown-toc-minibufexpl-1&quot;&gt;minibufexpl引发的血案(窗口大小变化)&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#vimrc-3&quot; id=&quot;markdown-toc-vimrc-3&quot;&gt;在.vimrc进行设置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;设置快捷键&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tagsfiles&quot; id=&quot;markdown-toc-tagsfiles&quot;&gt;使用之前的分开显示tags和files的方式&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#powerline&quot; id=&quot;markdown-toc-powerline&quot;&gt;Powerline&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-10&quot; id=&quot;markdown-toc-section-10&quot;&gt;简述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vundle-4&quot; id=&quot;markdown-toc-vundle-4&quot;&gt;添加到Vundle管理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vimrc-4&quot; id=&quot;markdown-toc-vimrc-4&quot;&gt;.vimrc中的一些配置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#themes-and-colorschemes&quot; id=&quot;markdown-toc-themes-and-colorschemes&quot;&gt;Themes and ColorSchemes&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tmuxvim&quot; id=&quot;markdown-toc-tmuxvim&quot;&gt;在tmux中的vim状态栏不颜色并不那么好看？&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#markdown&quot; id=&quot;markdown-toc-markdown&quot;&gt;Markdown&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-11&quot; id=&quot;markdown-toc-section-11&quot;&gt;简述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vundle-5&quot; id=&quot;markdown-toc-vundle-5&quot;&gt;添加到Vundle管理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vimrc-5&quot; id=&quot;markdown-toc-vimrc-5&quot;&gt;.vimrc中的一些配置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-12&quot; id=&quot;markdown-toc-section-12&quot;&gt;一些默认快捷键&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#with-&quot; id=&quot;markdown-toc-with-&quot;&gt;生成目录 with ‘#’&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#fencview&quot; id=&quot;markdown-toc-fencview&quot;&gt;fencview&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-13&quot; id=&quot;markdown-toc-section-13&quot;&gt;简述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vundle-6&quot; id=&quot;markdown-toc-vundle-6&quot;&gt;添加到Vundle管理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-14&quot; id=&quot;markdown-toc-section-14&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tohtml&quot; id=&quot;markdown-toc-tohtml&quot;&gt;tohtml&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-15&quot; id=&quot;markdown-toc-section-15&quot;&gt;简述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ubuntu&quot; id=&quot;markdown-toc-ubuntu&quot;&gt;ubuntu下的位置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-16&quot; id=&quot;markdown-toc-section-16&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;简要声明&lt;/h3&gt;
&lt;p&gt;以下介绍的插件的安装，均使用&lt;code&gt;Vundle管理&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;taglist&quot;&gt;TagList&lt;/h3&gt;

&lt;h4 id=&quot;section-1&quot;&gt;简述&lt;/h4&gt;

&lt;p&gt;TagList是一个标签浏览器&lt;br /&gt;
所谓标签，就是那些具有表示意义的标示符，像变量，函数名，宏等&lt;br /&gt;
TagList通过一个简单窗口，展示了当前文件下的所有相关的标签&lt;br /&gt;
&lt;code&gt;PS&lt;/code&gt;: &lt;strong&gt;TagsList依赖于ctags产生的tags文件&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;vundle&quot;&gt;添加到Vundle管理&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Plugin &#39;vim-scripts/taglist.vim&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;vimrc&quot;&gt;.vimrc中的一些配置&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;let Tlist_Ctags_Cmd=&#39;ctags&#39;         &quot;taglist依赖于ctags,设置ctags位置
let Tlist_Use_Right_Window=0        &quot;窗口显示:1--右边，0--左边
let Tlist_Show_One_File=1           &quot;显示一个文件:1--是 0--否
let Tlist_File_Fold_Auto_Close=1    &quot;非当前文件，函数列表折叠隐藏
let Tlist_GainFocus_On_ToggleOpen = 1  &quot;打开taglist时，光标保留在taglist窗口
let Tlist_Exit_OnlyWindow=1         &quot;当taglist是最后一个分割窗口时，自动退出vim
let Tlist_Process_File_Always=1     &quot;实时更新tags 1--是　0--否
let Tlist_Inc_Winwidth=0
nmap &amp;lt;leader&amp;gt;tl :Tlist&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-2&quot;&gt;使用&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;打开Taglist窗口&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  :Tlist	或者 	使用定义的快捷键 &#39;\+t+l&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;跳跃到某一item定义处&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  选中item，点击&#39;Enter&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;仅仅查看item原型&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  选中要查看的item,点击&#39;Space&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原型结果会显示在Vim命令行&lt;/p&gt;

&lt;h3 id=&quot;echofunc&quot;&gt;echofunc&lt;/h3&gt;

&lt;h4 id=&quot;section-3&quot;&gt;简述&lt;/h4&gt;

&lt;p&gt;echofunc可以帮助我们在插入函数的时候,提示当前输入函数的原型&lt;br /&gt;
提示结果显示在command line里&lt;/p&gt;

&lt;h4 id=&quot;vundle-1&quot;&gt;添加到Vundle管理&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Plugin &#39;mbbill/echofunc&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;使用&lt;/h4&gt;

&lt;p&gt;需要tags文件的支持, 并且在创建tags文件的时候要加选项”–fields=+lS”（OmniCppComplete创建的tag文件也能用）&lt;br /&gt;
整个创建tags文件的命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ctags -R --fields=+lS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你在vim插入(insert)模式下紧接着函数名后输入一个”(“的时候, 这个函数的声明就会自动显示在命令行中。&lt;/p&gt;

&lt;p&gt;如果这个函数有多个声明, 则可以通过按键&lt;em&gt;Alt + -&lt;/em&gt;和&lt;em&gt;Alt + =&lt;/em&gt;向前和向后翻页&lt;br /&gt;
这个两个键可以通过设置&lt;code&gt;g:EchoFuncKeyNext&lt;/code&gt;和&lt;code&gt;g:EchoFuncKeyPrev&lt;/code&gt;参数来修改&lt;/p&gt;

&lt;p&gt;如果你在编译vim时加上了”+balloon_eval”特性&lt;br /&gt;
那么当你把鼠标放在函数名上的时候会有一个tip窗口弹出, 该窗口中也会有函数的声明&lt;/p&gt;

&lt;h3 id=&quot;winmanager&quot;&gt;WinManager&lt;/h3&gt;

&lt;h4 id=&quot;section-5&quot;&gt;简述&lt;/h4&gt;

&lt;p&gt;WinManager是一个窗口管理器 &lt;br /&gt;
在Vim中，通常使用其管理文件浏览器(netrw)和缓冲区(buffer)&lt;br /&gt;
2.0以上的版本还可以管理其他IDE类型插件,不过，需要我们在插件中增加一些辅助变量和hook来支持WinManager&lt;/p&gt;

&lt;p&gt;这里，我们就用WinManager来管理文件浏览器netrw和标签浏览器Taglist。&lt;br /&gt;
netrw是标准的vim插件, 已经随vim一起安装进系统里了, 不需要我们自行下载安装。&lt;br /&gt;
而Taglist我们刚刚已经安装完成了&lt;/p&gt;

&lt;h4 id=&quot;vundle-2&quot;&gt;加入Vundle管理&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Plugin &#39;MwumLi/WinManager&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;vimrc-1&quot;&gt;.vimrc中的一些配置&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&quot; 设置我们要管理的插件
let g:winManagerWindowLayout=&#39;FileExplorer|TagList&#39; 	&quot;FileExplorer和TagList同时在左边窗口显示
let g:winManagerWindowLayout=&#39;FileExplorer,TagList&#39; 	&quot;FileExplorer和TagList同时仅有一个在左边窗口显示,使用Ctrl+n/p切换
let g:persistentBehaviour=0 &quot; 如果所有编辑文件都关闭了，退出vim
nmap wm :WMToggle&amp;lt;cr&amp;gt; 	&quot; 打开/关闭WinManager
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;个人觉得&lt;code&gt;let g:winManagerWindowLayout=&#39;FileExplorer,TagList&#39;&lt;/code&gt;看起来比较好点,大气&lt;br /&gt;
虽然&lt;code&gt;let g:winManagerWindowLayout=&#39;FileExplorer|TagList&#39;&lt;/code&gt;可能看起来更像是一个IDE&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;使用&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;打开WinMananger&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  &#39;w + m&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;假如采用第二种分开显示tags和files，则按以下方式切换:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  &#39;Ctrl + n&#39; 	---&amp;gt;下一页
  &#39;Ctrl + p&#39; 	---&amp;gt;前一页
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;假如还没有安装minibufexpl(即将安装),则使用一下方式在不同窗口切换:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  &#39;Ctrl + w + w&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;假如安装了minibufexpl,则切换窗口变得很简单:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  &#39;Ctrl + h/j/k/l&#39;  ==  &#39;Ctrl + Arrow left/down/up/right&#39;  //左-下-上-右移动
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;minibufexpl&quot;&gt;minibufexpl&lt;/h3&gt;

&lt;h4 id=&quot;section-7&quot;&gt;简述&lt;/h4&gt;

&lt;p&gt;minibufexpl,一个缓冲区显示器，假如仅仅看它的效果，更像是浏览器的多个标签页&lt;br /&gt;
这个往往在编辑多个文件时显示&lt;/p&gt;

&lt;h4 id=&quot;vundle-3&quot;&gt;加入Vundle管理&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Plugin &#39;vim-scripts/minibufexpl.vim&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;vimrc-2&quot;&gt;.vimrc中的一些配置&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;let g:miniBufExplMapWindowNavVim = 1    &quot; 按下Ctrl+h/j/k/l，可以切换到当前窗口的上下左右窗口
let g:miniBufExplMapWindowNavArrows = 1 &quot; 按下Ctrl+箭头，可以切换到当前窗口的上下左右窗口
let g:miniBufExplMapCTabSwitchBufs = 1  &quot;Ubuntu不适用
let g:miniBufExplModSelTarget = 1   &quot; 不要在不可编辑内容的窗口（如TagList窗口）中打开选中的buffer
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-8&quot;&gt;使用&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&#39;Ctrl + h/j/k/l&#39;	---&amp;gt;左/下/上/右窗口切换
&#39;Ctrl + Arrow&#39;		---&amp;gt;same as &#39;Ctrl + h/j/k/l&#39;
&#39;Tab&#39;				---&amp;gt;缓冲区间切换
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;minibufexpl-1&quot;&gt;minibufexpl引发的血案(窗口大小变化)&lt;/h3&gt;

&lt;p&gt;在这之前，我们一切都感觉很好(真像一个IDE)&lt;br /&gt;
但是在安装了minibufexpl后，我们的美好感觉破灭了(毕竟还不是IDE)&lt;br /&gt;
文件浏览器的窗口显得异常小，在打开多个文件时，更小，哎，愁…&lt;br /&gt;
还好，有解决办法，不过都不是很完美  a&lt;/p&gt;

&lt;h4 id=&quot;vimrc-3&quot;&gt;在.vimrc进行设置&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;let g:bufExplorerMaxHeight=30
let g:miniBufExplorerMoreThanOne=0 这样倒是可以解决问题，但是也引来一些新的问题(至于什么，你试试呗),所以果断启用  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-9&quot;&gt;设置快捷键&lt;/h4&gt;

&lt;p&gt;对WinManager设置快捷键,比如&lt;code&gt;nmap wm :WMToggle&amp;lt;cr&amp;gt;&lt;/code&gt;&lt;br /&gt;
然后，我们只要在文件浏览器变小的时候，按动&lt;em&gt;两次wm&lt;/em&gt;即可(先关闭，在开启)&lt;br /&gt;
这个方法还是可以接收的&lt;/p&gt;

&lt;h4 id=&quot;tagsfiles&quot;&gt;使用之前的分开显示tags和files的方式&lt;/h4&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;powerline&quot;&gt;Powerline&lt;/h3&gt;

&lt;h4 id=&quot;section-10&quot;&gt;简述&lt;/h4&gt;

&lt;p&gt;Powerline,一个终极Vim状态栏工具&lt;/p&gt;

&lt;h4 id=&quot;vundle-4&quot;&gt;添加到Vundle管理&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Plugin &#39;Lokaltog/vim-powerline&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;vimrc-4&quot;&gt;.vimrc中的一些配置&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;$HOME/.vimrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set laststatus=2    &quot;一直展示两行状态
set t_Co=256        &quot;告诉vim这个终端支持256色
let g:Powerline_symbols = &#39;unicode&#39;
set encoding=utf8
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;themes-and-colorschemes&quot;&gt;Themes and ColorSchemes&lt;/h4&gt;

&lt;p&gt;主题在目录&lt;code&gt;autoload/Powerline/Themes&lt;/code&gt;下,配色在&lt;code&gt;autoload/Powerline/Colorschemes&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;tmuxvim&quot;&gt;在tmux中的vim状态栏不颜色并不那么好看？&lt;/h4&gt;

&lt;p&gt;确保你在.tmux.conf中启用了256color:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set -g default-terminal &quot;screen-256color&quot; 确保你在.vimrc中启用了终端256color:  

set t_Co=256  
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;markdown&quot;&gt;Markdown&lt;/h3&gt;

&lt;h4 id=&quot;section-11&quot;&gt;简述&lt;/h4&gt;

&lt;p&gt;为vim下.md文件设置语法高亮，规则匹配,方便md文档的撰写&lt;/p&gt;

&lt;h4 id=&quot;vundle-5&quot;&gt;添加到Vundle管理&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Plugin &#39;plasticboy/vim-markdown&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;vimrc-5&quot;&gt;.vimrc中的一些配置&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;let g:vim_markdown_folding_disabled=1  			&quot;禁用折叠
let g:vim_markdown_initial_foldlevel=1
&quot;let g:vim_markdown_no_default_key_mappings=1   &quot;禁用默认键
&quot;对文件名后缀为md,mdown,mkd,mkdn,markdown,mdwn的文件，使用markdown语法
au BufRead,BufNewFile *.{md,mdown,mkd,mkdn,markdown,mdwn} set filetype=mkd
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-12&quot;&gt;一些默认快捷键&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;]]&lt;/code&gt;: go to next header. &lt;code&gt;&amp;lt;Plug&amp;gt;(Markdown_MoveToNextHeader)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;[[&lt;/code&gt;: go to previous header. Contrast with &lt;code&gt;]c&lt;/code&gt;. &lt;code&gt;&amp;lt;Plug&amp;gt;(Markdown_MoveToPreviousHeader)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;][&lt;/code&gt;: go to next sibling header if any. &lt;code&gt;&amp;lt;Plug&amp;gt;(Markdown_MoveToNextSiblingHeader)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;[]&lt;/code&gt;: go to previous sibling header if any. &lt;code&gt;&amp;lt;Plug&amp;gt;(Markdown_MoveToPreviousSiblingHeader)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;]c&lt;/code&gt;: go to Current header. &lt;code&gt;&amp;lt;Plug&amp;gt;(Markdown_MoveToCurHeader)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;]u&lt;/code&gt;: go to parent header (Up). &lt;code&gt;&amp;lt;Plug&amp;gt;(Markdown_MoveToParentHeader)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;with-&quot;&gt;生成目录 with ‘#’&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;:Toc 	---&amp;gt;创建一个快速垂直窗口显示文档目录  
:Toch	---&amp;gt;创建一个快速水平窗口显示文档目录  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hit &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt; on a line to jump to the corresponding line of the markdown file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:Toch	---&amp;gt;Same as `:Toc` but in an horizontal window.
:Toct	---&amp;gt;Same as `:Toc` but in a new tab.
:Tocv	---&amp;gt;Same as `:Toc` for symmetry with `:Toch` and `Tocv`.   
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;fencview&quot;&gt;fencview&lt;/h3&gt;

&lt;h4 id=&quot;section-13&quot;&gt;简述&lt;/h4&gt;

&lt;p&gt;不同系统，不同平台下，文件编码往往不太一样&lt;br /&gt;
故在一个系统下为gb2312的文件，放在另一个系统下以utf-8的方式打开,往往会产生乱码&lt;br /&gt;
好了，我(fencview)来了,fencview应运而生&lt;/p&gt;

&lt;h4 id=&quot;vundle-6&quot;&gt;添加到Vundle管理&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Plugin `Mwumli/fencview`  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-14&quot;&gt;使用&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;自动探测文件编码，以合适的编码方式显示&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  :FencAutoDetect
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;打开编码列表窗口,选择合适编码，重新加载文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  :Fencview
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tohtml&quot;&gt;tohtml&lt;/h3&gt;

&lt;h4 id=&quot;section-15&quot;&gt;简述&lt;/h4&gt;

&lt;p&gt;我们往往需要把我们的代码展示给别人看，但是直接copy代码，可能查看效果并不如意&lt;br /&gt;
现在有这么一个插件，可以把你的代码转化成html,并且如在你的vim中格式那样显示(&lt;em&gt;代码高亮&lt;/em&gt;)&lt;br /&gt;
当然，此插件不仅仅可以转化代码，还可以转化其他文字&lt;br /&gt;
不过对于程序员来说，此功能就已足够&lt;/p&gt;

&lt;p&gt;此插件已经内置在vim的最新版本，故不需要手动安装&lt;/p&gt;

&lt;h4 id=&quot;ubuntu&quot;&gt;ubuntu下的位置&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;/usr/share/vim/vim74/autoload/tohtml.vim  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-16&quot;&gt;使用&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;转化整片文章成html&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  :TOhtml    工作目录下会生成以文件名为前缀，以html为后缀的文件  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;转化指定行成html&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  :num1,num2TOhtml   把此篇文章的num1到num2行的文本转化成html文件  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;**假如此前vim显示行号，生成的html文件中也显示行号 **&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/06/02/vim-some-plugins</link>
                <guid>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/06/02/vim-some-plugins</guid>
                <pubDate>2014-06-02T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>Vim的一些操作</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#vim&quot; id=&quot;markdown-toc-vim&quot;&gt;vim编程常用命令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;常用命令&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;快速查找单词&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;撤销和反撤销&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;相关帮助文档&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vim-1&quot; id=&quot;markdown-toc-vim-1&quot;&gt;Vim中文文档&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;缩进设置&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#vimrc&quot; id=&quot;markdown-toc-vimrc&quot;&gt;.vimrc选项&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tab&quot; id=&quot;markdown-toc-tab&quot;&gt;根据文件类型来设置 tab：&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tab-1&quot; id=&quot;markdown-toc-tab-1&quot;&gt;用特殊符号设置tab制表符&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;　折叠&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;6种方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;常见设置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;常用快捷键&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vim-2&quot; id=&quot;markdown-toc-vim-2&quot;&gt;vim加密文件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vim-3&quot; id=&quot;markdown-toc-vim-3&quot;&gt;Vim的多文件操作&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vim-4&quot; id=&quot;markdown-toc-vim-4&quot;&gt;vim的多窗口操作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;vim&quot;&gt;vim编程常用命令&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;常用命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;%  		| 	跳转到配对的括号去
[[ 		| 	跳转到代码块的开头去
gD 		| 	跳转到局部变量定义处  
gg 		| 	跳转到文件开始位置
G  		| 	跳转到文件结束位置  
mx 		| 	设置书签，x只能是[a---z]的26个字母
`x 		| 	跳转到书签处(`是１旁边的键)
&amp;gt;  		| 	增加缩进，&quot;x&amp;gt;&quot;表示增加以下x行的缩进
&amp;lt;  		| 	减少缩进，&quot;x&amp;gt;&quot;表示减少以下x行的缩进
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;快速查找单词&lt;/h3&gt;

&lt;p&gt;当光标移动到相应单词，按下 &lt;code&gt;shift + #&lt;/code&gt;, 就会在文件中快速查找改单词&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;撤销和反撤销&lt;/h3&gt;

&lt;p&gt;按下 &lt;code&gt;u&lt;/code&gt; 撤销上一步保存的操作&lt;/p&gt;

&lt;p&gt;按下 &lt;code&gt;ctrl + r&lt;/code&gt; 回退上一步撤销的操作&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;相关帮助文档&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;:help usr_29
:help usr_30
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;vim-1&quot;&gt;Vim中文文档&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;vim中文文档不会覆盖原英文文档，安装后vim默认使用中文文档。若想使用英文文档，可在vim中执行以下命令：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; set helplang=en
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;同理，使用以下命令可重新使用中文文档：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; set helplang=cn
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;帮助文件的文本是utf-8编码的, 如果想用vim直接查看, 需要在~/.vimrc中设置:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; set encoding=utf-8
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-4&quot;&gt;缩进设置&lt;/h2&gt;

&lt;h4 id=&quot;vimrc&quot;&gt;.vimrc选项&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;set tabstop=4
set softtabstop=4
set shiftwidth=4
set noexpandtab / expandtab
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;做一些说明&lt;/strong&gt;:&lt;br /&gt;
其中 &lt;code&gt;tabstop&lt;/code&gt; 表示一个 &lt;code&gt;tab&lt;/code&gt; 显示出来是多少个空格的长度，默认 8&lt;/p&gt;

&lt;p&gt;&lt;code&gt;softtabstop&lt;/code&gt; 表示在编辑模式的时候按退格键的时候退回缩进的长度，当使用 &lt;code&gt;expandtab&lt;/code&gt; 时特别有用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shiftwidth&lt;/code&gt; 表示每一级缩进的长度，一般设置成跟 &lt;code&gt;softtabstop&lt;/code&gt; 一样&lt;/p&gt;

&lt;p&gt;当设置成 &lt;code&gt;expandtab&lt;/code&gt; 时，缩进用空格来表示，&lt;code&gt;noexpandtab&lt;/code&gt; 则是用制表符表示一个缩进。&lt;/p&gt;

&lt;h4 id=&quot;tab&quot;&gt;根据文件类型来设置 tab：&lt;/h4&gt;

&lt;p&gt;有些时候想为某些类型的文件设置不同的 tab 表现&lt;br /&gt;
如 python 用四个空格来表示一个缩进，javascript 约定也是用四个空格来表示缩进&lt;br /&gt;
而 HTML 和 CSS 则喜欢用 tab 制表符来缩进，那么可以做如下设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if has(&quot;autocmd&quot;)
    autocmd FileType javascript setlocal ts=4 sts=4 sw=4 expandtab
	autocmd FileType python setlocal ts=4 sts=4 sw=4 expandtab
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样当开打的文件是 .js .py 的，都会用四个空格来缩进&lt;/p&gt;

&lt;h4 id=&quot;tab-1&quot;&gt;用特殊符号设置tab制表符&lt;/h4&gt;

&lt;p&gt;在 Vim 中可以用特殊的符号来表示一个 tab 制表符，这样 tab 制表符和空格就可以很容易的区分看来了&lt;br /&gt;
在.vimrc加入这些就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set list
set listchars=tab:▸\ ,eol:¬
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;　折叠&lt;/h2&gt;

&lt;h4 id=&quot;section-6&quot;&gt;6种方法&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;manual	---	手工定义折叠  
indent	---	更多的缩进表示更高级别的折叠
expr	---	用表达式来定义折叠
syntax	---	用语法高亮来定义折叠
diff	---	对没有更改的文本进行折叠
marker	---	对文中的标志折叠
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，每一种折叠方式不兼容，当前时刻，有且只能使用一种&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;常见设置&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;设置折叠方法&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; set foldmethod=syntax	//其他几种也可以
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置折叠级别&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; set foldlevel=num
 num为0时，所有的折叠关闭  
 num为正数时，一些折叠关闭
 num很大时，所有的折叠打开
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置折叠栏宽度&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; set foldcolumn=num
 num的取值[0----12]
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一个打开的折叠由一栏来表示，顶端是’-‘,其下方是’|’,这栏在折叠结束的地方结束&lt;br /&gt;
一个关闭的折叠由’+’表示&lt;br /&gt;
折叠栏太窄而不能显示所有折叠时，显示一数字来表示嵌套的级别&lt;br /&gt;
当设置&lt;code&gt;set mouse=a&lt;/code&gt;时,在折叠栏点击鼠标，可以打开和关闭折叠&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;光标所在，自动打开折叠&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; set foldopen=all  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;光标移开，自动关闭折叠&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; set foldclose=all
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-8&quot;&gt;常用快捷键&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;za  打开/关闭在光标下的折叠
zA  循环地打开/关闭光标下的折叠
zo  打开 (open) 在光标下的折叠
zO  循环打开 (Open) 光标下的折叠
zc  关闭 (close) 在光标下的折叠
zC  循环关闭 (Close) 在光标下的所有折叠
zM  关闭所有折叠
zR  打开所有的折叠
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;vim-2&quot;&gt;vim加密文件&lt;/h2&gt;

&lt;p&gt;Command mode下使用:X命令为文件设定一个密码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:X
Enter encryption key: ******
Enter same key again: ******
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要取消加密，可以设置密码为空&lt;br /&gt;
可以禁用交换文件，以免泄密&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim -x -n file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你已在经编辑这个文件了，那么交换文件可以用下面的命令禁止:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:setlocal noswapfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于没了交换文件，文件复原就不可能了。为了避免失去编辑的成果，要比平时更勤快地存盘你的文件&lt;/p&gt;

&lt;p&gt;现在你可以像平时一样编辑这个文件并把你所有的秘密放进去。当你编完文件要退出 Vim 时，这个文件就被加密存盘了&lt;br /&gt;
当你下次用 Vim 编辑这个文件时，它就会询问你密码&lt;/p&gt;

&lt;p&gt;如果你试图用另一个程序来阅读这个文件，你将读到一堆垃圾。如果你用 Vim 来编辑这个文件，但输入了错误的密码，你也只能得到垃圾.&lt;br /&gt;
Vim 并不具备检验密码正确性的机制 (这一点使得破译密码更为困难)&lt;/p&gt;

&lt;h2 id=&quot;vim-3&quot;&gt;Vim的多文件操作&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;打开file1, file2, file3 …&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ vim file1 file2 file3
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文件之间的跳转&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; :n	跳转到下一个文件
 :N	跳转到上一个文件
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;列出目前这个vim打开的所有文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; :files
 1 %a   &quot;a.v&quot;                          line 1
 2      &quot;cvim_use.md&quot;                  line 0
 3      &quot;test.md&quot;                      line 0
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一次退出，全部退出编辑&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; :q
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;vim-4&quot;&gt;vim的多窗口操作&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;分割窗口&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  :sp [file]
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;[ ]&lt;/code&gt;代表可选，file是可选的&lt;br /&gt;
若是不输入file，则分割后的创建窗口显示当前窗口文件&lt;br /&gt;
若是输入file,则分割后的窗口打开文件file&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;切换窗口&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  [Ctrl]+[w]+[j] == [Ctrl]+[w]+[ArrowDown]	跳转到当前窗口下方的窗口
  [Ctrl]+[w]+[k] == [Ctrl]+[w]+[ArrowUp]	跳转到当前窗口上方的窗口
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/06/02/vim-some-operations</link>
                <guid>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/06/02/vim-some-operations</guid>
                <pubDate>2014-06-02T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>ctags</title>
                <description>
&lt;h3 id=&quot;ctags&quot;&gt;Ctags&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;简述&lt;/h4&gt;

&lt;p&gt;Ctags,为源码建立标签文件&lt;code&gt;tags&lt;/code&gt; ,以帮助在源文件中定位 &lt;br /&gt;
vim往往可以通过其他插件实现函数，变量等的查找，或者实现源码间切换&lt;br /&gt;
而这些插件依赖于&lt;code&gt;tags&lt;/code&gt;文件&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;安装&lt;/h4&gt;

&lt;p&gt;Ubuntu上可以通过一下命令安装:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install ctags  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他平台，待续&lt;/p&gt;

&lt;h4 id=&quot;tags&quot;&gt;tags中对象列表&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;用#define定义的宏  
枚举型变量的值  
函数的定义、原型和声明  
名字空间(namespace)  
变量(包括定义和声明)  
类(class)、结构(struct)、枚举类型(enum)和联合(union)  
类、结构和联合中成员变量或函数  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;tags-1&quot;&gt;用参数生成我们需要的tags文件　　&lt;/h4&gt;

&lt;p&gt;具体详细的参数，就不再写了，直接使用下面这条略显完备commmand:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ctags -R -c++-kinds=+px --fields=+ialS --extra=+q
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;每个参数解释如下:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-R		|		ctags递归生成子目录的tags（在项目的根目录下很有意义）  
-c++-kinds=+px	|	ctags记录c++文件中的函数声明,各种外部和前向声明  
--fields=+ials	|	ctags要求描述的信息，其中：　　
	i	--&amp;gt;表示如果有继承，则表示出父类  
	a	--&amp;gt;表示如果元素是类成员的话，要标明其调用权限(即public或者private)  
	l	--&amp;gt;表示包含标记源文件的语言  
	S	--&amp;gt;表示函数的签名(即函数原型或者参数列表)  
--extra=+q		|	强制要求ctags做如下操作:  
	如果某个语法元素是类的一个成员，ctags默认会给其记录一行，
	以要求ctags对同一个语法元素再记一行，这样可以保证在VIM中多个同名函数可以通过路径不同来区分。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-2&quot;&gt;插件和使用&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;很多插件依赖于tags文件,例如omnicppcomplete,tagslist,echofunc&lt;br /&gt;
关于这些插件的安装，可以查看之前的&lt;a href=&quot;/记录/2014/06/02/vim-some-plugins/&quot; title=&quot;Vim下的fancy的插件&quot;&gt;《Vim下的fancy的插件》&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Vim中的简单使用&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Ctrl + ]		|		cursor移动到某个元素,按下此组合键,就会跳转到对应定义  
 Ctrl + o		|		按下此组合键，即可返回原来的地方  
 g + d			|		cursor在局部变量出，按下此组合键,就会跳转到局域变量定义处  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/06/02/ctags</link>
                <guid>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/06/02/ctags</guid>
                <pubDate>2014-06-02T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>Vim插件管理及安装</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#vim---vundle&quot; id=&quot;markdown-toc-vim---vundle&quot;&gt;Vim插件管理插件—&amp;gt;Vundle&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#github&quot; id=&quot;markdown-toc-github&quot;&gt;Github地址&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;配置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vundle&quot; id=&quot;markdown-toc-vundle&quot;&gt;四种添加插件到Vundle管理的方式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vundle-1&quot; id=&quot;markdown-toc-vundle-1&quot;&gt;使用Vundle安装插件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vundle-2&quot; id=&quot;markdown-toc-vundle-2&quot;&gt;Vundle的其他使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;vim---vundle&quot;&gt;Vim插件管理插件—&amp;gt;Vundle&lt;/h2&gt;

&lt;h3 id=&quot;github&quot;&gt;Github地址&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;https://github.com/gmarik/vundle.git 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;安装&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;配置&lt;/h3&gt;

&lt;p&gt;把下面这些放在你的&lt;code&gt;.vimrc&lt;/code&gt;中去使用&lt;code&gt;Vundle&lt;/code&gt;&lt;br /&gt;
移除下面不必要的插件，他们仅仅是为了演示效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set nocompatible              &quot; be iMproved, required
filetype off                  &quot; required

&quot; set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
&quot; alternatively, pass a path where Vundle should install plugins
&quot;call vundle#begin(&#39;~/some/path/here&#39;)
&quot;所有的插件管理必须被添加在以上这行之后

&quot; let Vundle manage Vundle, required
Plugin &#39;gmarik/Vundle.vim&#39;

&quot; Powerline---&amp;gt;The ultimate vim statusline utility  
&quot; https://github.com/Lokaltog/vim-powerline
Plugin &#39;Lokaltog/vim-powerline

&quot; Markdown--Syntax highlighting, matching rules and mappings for .md file
&quot; https://github.com/plasticboy/vim-markdown/
Plugin &#39;plasticboy/vim-markdown&#39;

&quot; echofunc---&amp;gt;automatically display function 
&quot; https://github.com/mbbill/echofunc 
Plugin &#39;mbbill/echofunc&#39;

&quot; taglist---&amp;gt; 列出当前文件中所有标签(宏，全局变量，函数名) 
&quot; https://github.com/vim-scripts/taglist.vim 
Plugin &#39;vim-scripts/taglist.vim&#39;  

&quot; 所有的插件必须被添加在以下这行之前
call vundle#end()            &quot; required
filetype plugin indent on    &quot; required
&quot; To ignore plugin indent changes, instead use:
&quot;filetype plugin on
&quot;
&quot;
&quot; see :h vundle for more details or wiki for FAQ
&quot; Put your non-Plugin stuff after this line
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;vundle&quot;&gt;四种添加插件到Vundle管理的方式&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;指定Github中用户仓库的插件，使用“用户名/插件名称”的方式指定&lt;br /&gt;
 插件名中的空格使用“-”代替&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Plugin &#39;tpope/vim-fugitive&#39;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;插件名中的空格使用“-”代替&lt;br /&gt;
 当插件位于仓库的某一子目录时，需用rtp指定子目录&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Plugin &#39;rstacruz/sparkup&#39;, {&#39;rtp&#39;: &#39;vim/&#39;}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定Github中vim-scripts仓库中的插件&lt;br /&gt;
 即在http://vim-scripts.org/vim/scripts.html列出的插件&lt;br /&gt;
 直接指定插件名称即可&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Plugin &#39;L9&#39;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;避免插件名称与L9有冲突&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Plugin &#39;user/L9&#39;, {&#39;name&#39;: &#39;newL9&#39;}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定非Github的Git仓库的插件，需要使用git地址&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Plugin &#39;git://git.wincent.com/command-t.git&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定本地Git仓库中的插件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Plugin &#39;file:///home/gmarik/path/to/plugin&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;vundle-1&quot;&gt;使用Vundle安装插件&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;启动vim,并且运行:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; :PluginInstall
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从命令行安装:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ vim +PluginInstall +qall
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;vundle-2&quot;&gt;Vundle的其他使用&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;预览模式列出已配置的Plugins&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; :PluginList          - list configured plugins
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装(更新)插件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; :PluginInstall(!)    - install plugins
 :PluginInstall!		 - update all plugins
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;搜索(首先刷新缓存)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; :PluginSearch(!) foo - search (or refresh cache first) for foo
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;清除未使用的插件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; :PluginClean(!)      - confirm (or auto-approve) removal of unused plugins
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/06/01/vim-plugin-manage</link>
                <guid>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/06/01/vim-plugin-manage</guid>
                <pubDate>2014-06-01T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>不早不晚，当下最好(转载)</title>
                <description>
&lt;p&gt;人生苦短，大概三件事对我重要。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;锻炼身体 — 为活得久&lt;/h3&gt;

&lt;p&gt;无论当年在潮湿黑暗的地下室做笼中兽，还是如今在凉风习习的操场上腿毛飘飘，都是为了锻炼身体。&lt;/p&gt;

&lt;p&gt;锻炼身体是为了活得更好一点，活得更长一点。&lt;/p&gt;

&lt;p&gt;另外一个私心，就是体悟。身体是灵魂与外部沟通的媒介，对媒介的敏感度越高，便越发能感悟世界。&lt;/p&gt;

&lt;p&gt;无论是在山间小溪旁观察叶脉纹路，还或在人流涌动地铁里轻嗅香水味道，都是感悟。而身体是灵魂行走的壳子，就好比RPG里的任务装备一样。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;阅读&lt;/h3&gt;

&lt;p&gt;无论是当年的模电数电单片机，还是如今的摄影户外文史哲，看书只是想体验更多人的思想与感悟。&lt;/p&gt;

&lt;p&gt;阅读与吃饭一样，要吞食天地。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;记录&lt;/h3&gt;

&lt;p&gt;学习学习，看再多书，只是学。变成自己的东西记录写下来，才是习得。经历再多事，只能是经历，记录并思考，才能成感悟。知道不一定明白，温故知新才能有智慧。&lt;/p&gt;

&lt;p&gt;能说的话，写成博客。不能说的话，写成日记。语言能表达的用文字，语言无法表达的用影响。&lt;/p&gt;

&lt;p&gt;硬要极简主义走偏激路线的话，大体是看书锻炼写日记。&lt;/p&gt;

&lt;p&gt;这一年，我在做几件事。成与不成，此生无悔。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;李洛语&lt;/h3&gt;
&lt;p&gt;这三件事儿，是最简单的事儿，也是最难的事儿&lt;br /&gt;
可能陪伴一辈子，用一生去做&lt;br /&gt;
不过，这样才有意思,我要做这三件事儿&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;备注&lt;/h3&gt;
&lt;p&gt;此文属于转载，在阅读基础上，做了些许修改&lt;br /&gt;
原文链接：&lt;a href=&quot;http://www.xingzhekui.com/archives/6442&quot;&gt;http://www.xingzhekui.com/archives/6442&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/%E6%83%85%E7%BB%AA/2014/05/20/three-big-things</link>
                <guid>http://mwumli.github.io/%E6%83%85%E7%BB%AA/2014/05/20/three-big-things</guid>
                <pubDate>2014-05-20T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>如何改变世界(转载)</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;改变世界，回归自身&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;是自我的呈现还是善其身，济天下?&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;艺术家—内心具现化&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;穷则独善其身，达则兼济天下&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;鱼和熊掌，兼得之&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;大道万千，殊途同归—完善自己&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;认识世界就是认识自己&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;李洛语&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;备注&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;改变世界，回归自身&lt;/h2&gt;

&lt;p&gt;我已经见过太多嚷嚷着要改变世界的人，若问他们要改变世界什么，换来的不过是支支吾吾。&lt;br /&gt;
改变世界这么苍白的理想是如何泛滥的呢？&lt;br /&gt;
这是产品经理中二病，与廉价的成功学并无二致。&lt;/p&gt;

&lt;p&gt;不幸的是，我也是此病的重度患者，晚期。&lt;/p&gt;

&lt;p&gt;三个月前，与 @forresty 聊天，我却说，我对于改变世界什么的越发丧失兴趣，只想要回归到自身。&lt;/p&gt;

&lt;p&gt;这当然是骗人的。因自己的努力，让许多人的生活有一些不同，并且是朝向更好的方向。我怎么可能抛弃这份理想（写作理想，读作野心）。&lt;/p&gt;

&lt;p&gt;改变世界实在太过虚幻，我不过是寻得了一条具体的道路，即回归到自身。&lt;/p&gt;

&lt;p&gt;这可以有多重的诠释。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;是自我的呈现还是善其身，济天下?&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;艺术家—内心具现化&lt;/h3&gt;

&lt;p&gt;有这样一群人，他们沉浸于自己的世界，内心肿胀，被魔鬼驱使着将自己的内心具现化投影于现实世界。&lt;br /&gt;
这些投影，具现化的形态各不相同，可能是文字，可能是绘画，可能是音乐，当然也可能是某个产品。&lt;br /&gt;
他们纯粹为自己而创作，却偏偏能感染许多人。愈是个人的，愈能打动人。&lt;br /&gt;
他们被世人称为艺术家。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;穷则独善其身，达则兼济天下&lt;/h3&gt;

&lt;p&gt;另外一种诠释就无趣许多，却也安全许多。所谓「穷则独善其身，达则兼济天下」，又或者「内圣外王]。无论如何，想要改变世界，首先需要改变自己。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;鱼和熊掌，兼得之&lt;/h3&gt;

&lt;p&gt;至于我选择的是哪一种诠释，我也没有想明白。&lt;br /&gt;
不，这么说未免自欺欺人，我只是没有办法放弃任何一种可能性而已。在&lt;a href=&quot;http://lightory.net/uncompleted-man/692/&quot;&gt;「尚未完成的人」&lt;/a&gt;一文中，我就充分表述过自己的贪婪了。&lt;br /&gt;
是的，鱼与熊掌，我全都想要，只是存在着先后顺序罢了。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;大道万千，殊途同归—完善自己&lt;/h2&gt;

&lt;p&gt;若选择的是第一种诠释，要做的是「认识自己」；&lt;br /&gt;
而第二种诠释要求的则是「改变自己」。&lt;br /&gt;
只认识自己而不改变自己是不可能的，无论具有何等的天赋，也不过是块璞玉，不持续打磨便无法成型。而想要改变自己，首先要做的便是认识自己。&lt;br /&gt;
正如刘未鹏所言，一个程序若想改变自身，首先它要能够指向自身。&lt;/p&gt;

&lt;p&gt;两条道路看似分叉，实则紧密交织，汇作一条大道。大道名为「完善自己」，而入口处的小径是「认识自己」。&lt;/p&gt;

&lt;p&gt;可是，如何才能认识自己？这远比想像中困难，许多东西一直就存在于那儿，可一旦试图诉诸于言语，便立马失去了踪影，简直比薛定谔的猫还要狡猾。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;认识世界就是认识自己&lt;/h2&gt;

&lt;p&gt;在禅房中冥想？偶尔为之尚可，充分的宁静中或许存在纯净的思考。但若长久如此，只会变做空想，未免太过愚蠢。&lt;/p&gt;

&lt;p&gt;认识自己，钥匙从来就不在于自身。&lt;/p&gt;

&lt;p&gt;认识自己是困难的，但在别人身上也能看到自己。结识足够多的人，见贤思齐，见不贤而自省。读足够多的书，真正经典的书，那是历史上最优秀一批人的思考，读书如见人。&lt;/p&gt;

&lt;p&gt;认识自己是困难的，但在周边万物都能看到自己。&lt;br /&gt;
游历足够多的地方，用脚丈量大地，抵达世界的尽头，看潮起潮落。保持初心探索日常的居所，陶醉在夜风的吹拂，用心去看小草的生长，以及枯萎。&lt;/p&gt;

&lt;p&gt;认识世界多一点，便认识自己多一点，两者的界限变得混沌。在这种混沌状态中，仿佛接近于神灵。&lt;/p&gt;

&lt;p&gt;改变世界什么的，一点也不重要了。&lt;/p&gt;

&lt;p&gt;但实在是想为这个美丽的世界，留下一点什么。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-7&quot;&gt;李洛语&lt;/h2&gt;

&lt;p&gt;我们身出世界，故被世界所影响，我们是世界的一部分，我们的变化，也影响着了世界 ,虽然这可能微不足道&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;备注&lt;/h3&gt;

&lt;p&gt;看到此文，受益良多，故转载之&lt;br /&gt;
为了便于阅读，特加些标题,也是自己的感悟&lt;/p&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;http://lightory.net/how-to-change-the-world/&quot;&gt;http://lightory.net/how-to-change-the-world/&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://mwumli.github.io/%E6%83%85%E7%BB%AA/2014/05/19/how-to-change-world</link>
                <guid>http://mwumli.github.io/%E6%83%85%E7%BB%AA/2014/05/19/how-to-change-world</guid>
                <pubDate>2014-05-19T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>来自Linux内核的hello,world</title>
                <description>
&lt;h2 id=&quot;linux&quot;&gt;Linux内核模块&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;内核模块是什么&lt;/h3&gt;

&lt;p&gt;内核模块是Linux内核向外部提供的一个插口,其全程为动态可加载内核模块(LVM,Loadable Kernel Module),简称模块&lt;/p&gt;

&lt;p&gt;内核模块是具有独立功能的程序，可以被单独编译，但不能独立运行&lt;br /&gt;
它在运行时被链接到内核作为内核的一部分在内核空间，这和我们平时在用户空间的进程不同&lt;/p&gt;

&lt;p&gt;内核模块通常由一组函数和数据结构构成&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;内核模块的来由&lt;/h3&gt;

&lt;p&gt;Linux是一个单内核操作系统&lt;br /&gt;
它有着单内核的优点&lt;strong&gt;效率高&lt;/strong&gt;,因为所有内容都集成在一起&lt;br /&gt;
同样，缺点也是显而易见的，可扩展性和可维护性相对较差，模块机制正是为了弥补这一缺陷&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;内核模块可以做什么&lt;/h3&gt;

&lt;p&gt;模块作为内核功能的一个扩展,是为了在保持内核体积较小的情况下，增强其功能&lt;br /&gt;
内核只需要完成必要的功能即可，其他的功能都可以通过模块进行增强，类似于Vim的插件机制&lt;/p&gt;

&lt;p&gt;内核模块用来实现一种文件系统，一个驱动程序和其他内核上层的功能&lt;/p&gt;

&lt;h2 id=&quot;helloworld&quot;&gt;来自内核的hello,world&lt;/h2&gt;

&lt;h3 id=&quot;helloworld-1&quot;&gt;内核版本的hello,world&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/*hello_world.c*/&lt;/span&gt;
	&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;linux/init.h&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;linux/module.h&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;linux/kernel.h&amp;gt;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;MODULE_LICENSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;GPL&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__init&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KERN_ALERT&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Hllo,kernel world&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__exit&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KERN_ALERT&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;goodbye,kernel&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;module_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;module_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;MODULE_AUTHOR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;MwumLi&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;MODULE_DESCRIPTION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Hello World&amp;#39;s kernel version!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一些说明:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&amp;lt;linux/module.h&amp;gt;，&amp;lt;linux/init.h&amp;gt;,&amp;lt;linux/kernel.h&amp;gt;是Linux内核模块程序必不可少的三个头文件
    &lt;ul&gt;
      &lt;li&gt;&amp;lt;linux/module.h&amp;gt;包含模块的结构定义以及模块的版本控制&lt;/li&gt;
      &lt;li&gt;&amp;lt;linux/init.h&amp;gt;包含了宏__init和__exit,函数module_init(),module_exit()&lt;/li&gt;
      &lt;li&gt;&amp;lt;linux/kernel.h&amp;gt;包含了常用的内核函数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;__init告诉编译器此函数仅用于初始化，编译器将__init的所有代码存储到特殊的内存区域,初始化完毕之后，这段内存将被释放掉;__exit表示此段函数是模块卸载清理函数,当模块卸载之时，将执行此函数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MODULE_*系列宏，是一些模块程序的说明信息，可选；但是，要注意的是MODULE_LICENSE(“GPL”)宏，如果模块中无此宏，编译的时候会出现警告(假如你特别在意此问题，那么加上即可)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;module_init()是模块加载函数，当模块加载时，会执行此函数参数指向的函数；module_exit()是模块卸载函数，当卸载模块的时候，会执行此函数参数指向的函数,必须&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;makefile&quot;&gt;编写Makefile文件&lt;/h3&gt;

&lt;p&gt;对于一般的Ｃ程序，我们只需要gcc就可以了，然后直接运行&lt;br /&gt;
但是内核模块程序，我们必须使用内核中makefile文件，里面包含了内核库的位置&lt;br /&gt;
因此，我们需要编写makefile文件来实现内核模块的编译&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-mf&quot; data-lang=&quot;mf&quot;&gt;&lt;span class=&quot;c&quot;&gt;# this is a Makefile&lt;/span&gt;
	obj-m +&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; hello_world.o
&lt;span class=&quot;c&quot;&gt;	#generate the path&lt;/span&gt;
	CURRENT_PATH:&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;shell &lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;	#the current kernel version number&lt;/span&gt;
	LINUX_KERNEL:&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;shell uname -r&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;	#the absolute path&lt;/span&gt;
	LINUX_KERNEL_PATH:&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/src/linux-headers-&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;LINUX_KERNEL&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;	#complie object&lt;/span&gt;
	all:
		make -C &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;LINUX_KERNEL_PATH&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;CURRENT_PATH&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; modules
&lt;span class=&quot;c&quot;&gt;	#clean&lt;/span&gt;
	clean:
		make -C &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;LINUX_KERNEL_PATH&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;CURRENT_PATH&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; clean&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后，在命令行下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ sudo make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以成功编译(报错的话，根据错误信息debug)&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;模块的加载，卸载，查看&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;模块加载到内核&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ sudo insmod hello_world.ko
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看内核中已经加载的内核模块&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ sudo lsmod | head
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你会发现hello_word在第一行,okay,加载成功&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;从内核卸载模块&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ sudo rmmod hello_world
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看编译成功的内核模块信息&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ sudo modinfo hello_world.ko
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://mwumli.github.io/%E5%86%85%E6%A0%B8/2014/05/13/kernel-hello</link>
                <guid>http://mwumli.github.io/%E5%86%85%E6%A0%B8/2014/05/13/kernel-hello</guid>
                <pubDate>2014-05-13T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>只管开始做(转载)</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;流逝的绝大多数时光&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;奇妙的惰性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;无法不去写，写完之后，甚为舒畅&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;清闲罪恶感&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;不仅有爱，还要有饥渴感&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#no-time-to-do&quot; id=&quot;markdown-toc-no-time-to-do&quot;&gt;一种自我蛊惑&amp;lt;—-&amp;gt;No time to do&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#just-do-it&quot; id=&quot;markdown-toc-just-do-it&quot;&gt;清空大脑，简单粗暴—&amp;gt;just do it&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;流逝的绝大多数时光&lt;/h2&gt;

&lt;p&gt;每天24小时：8小时睡觉时间，8小时工作时间，4小时饮食、回家等的时间，那么还剩余4小时呢？&lt;/p&gt;

&lt;p&gt;刷微信；要和朋友聊天；要看朋友转来的有趣图片；要慢慢消磨时光看肥皂剧；要打游戏；要发呆；要胡思乱想；以及更多情况是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;“好吧，我已经决定今天的4小时看完《编程之美》这剩下的一章....等等，看得有点瞌睡啊...不如我先做点别的轻松东西吧，要不玩会《愤怒的小鸟》？“  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;绝大多数时光，就是这样流逝了…&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;奇妙的惰性&lt;/h2&gt;

&lt;p&gt;这样做当然没什么可指责的，因为人类的天性，总会停留在让自己舒服的领域之中。&lt;/p&gt;

&lt;p&gt;那些微小时光的浪费，比如看微信、刷社交网络、慢悠悠听音乐、赖床，都是自我疗愈，是补充元气。&lt;/p&gt;

&lt;p&gt;但人们又有一种奇妙的惰性，不像机器那样，输满能量就能立刻开始运作：人是会贪恋舒服的动物，补充完汽油了，还不愿意出站，哪怕“我再听完加油站里这首歌吧。”&lt;/p&gt;

&lt;p&gt;想读一本书，买下来；买完之后，不读，放着;&lt;br /&gt;
时候久了，越告诉自己该读，就越不想读;&lt;br /&gt;
每当想起，从书架上拿起，翻几页，又放回去:“我已经读过了，过几天再说”。&lt;br /&gt;
反复的自我轻施压，有了逆反情绪，觉得这是苦差事，越不想做。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;无法不去写，写完之后，甚为舒畅&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;海明威说，艾略特的巨作《荒原》是在银行工作时写的，但没名没钱之前，艾略特就是不敢辞职，当时在巴黎的庞德，虽然诗稿卖不出去，穷得想去当翻译算了，但还是伙同诸友捐款，“把艾略特从银行拯救出来！”艾略特，一直描述：那些东西，他无法不去写。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;村上春树的第一二部小说，是在经营酒吧的间隙写完的。非常辛苦，辛苦到他写完第二部小说后就决定不再开店了。但他还是撑下来了。他自陈说自己写《且听风吟》时，甚至没有当小说家的念想，仅仅是必须写完这篇小说，他甚至没有考虑过写完之后怎么处理（最后投给了群像新人奖），但至少是：写完之后，甚为舒畅。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一直有着想写的欲望，就犹如日常吃饭那样，不可残缺，不得不做。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;清闲罪恶感&lt;/h2&gt;

&lt;p&gt;当你有选择的余地，不去做一件事时，便多少会想法子推诿；&lt;br /&gt;
但当你被限期勒令做这件事时，你还是会推诿一阵，你会觉得“这样实在太难受了，想起来就是地狱啊”，但压力之下，便会进入一种疯狂的工作节奏。&lt;/p&gt;

&lt;p&gt;你高速劳作，极为顺手，等做完后回看才发现自己有多大的潜力，“我居然做完了！”&lt;/p&gt;

&lt;p&gt;而在做完这档子事之后的一段时间，你会有些茫然若失；你会带着惯性，继续高效劳作，就像一辆刹不住的车子。&lt;/p&gt;

&lt;p&gt;你会习惯于这种紧张而高效的岁月，甚至对自己的清闲产生罪恶感；而促使你继续劳作的，就是这种罪恶感。&lt;/p&gt;

&lt;p&gt;人许多时候，就是这么种”贱骨头”：总会以为许多心结，自己无法克服；&lt;br /&gt;
但时候到了，心理会自然把曾经厌恶的一切，归化为自己可接纳的部分，并自动从完成度上寻找快感&lt;/p&gt;

&lt;p&gt;许多工作狂大多如此，靠着连续不断的自我施压、击破压力来获得快感，终于欲罢不能。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;不仅有爱，还要有饥渴感&lt;/h2&gt;

&lt;p&gt;所谓巧妙的读书方法，所谓巧妙的工作方法，许多仅仅是变着法的自我激励和自我暗示，是对心绪的谄媚，绕着弯哄自己&lt;br /&gt;
“put your FXXX ass down in front of the desk and keep on working”&lt;/p&gt;

&lt;p&gt;所以许多法子，能有用于一时，却无法持续刺激自己，除了少数天才。&lt;/p&gt;

&lt;p&gt;事情的成效在于你投入的时间，而投入的时间，必然受制于拖延症=懒，要击破这一点，就必须对所做的事情，不只有爱，而且有饥渴感，许多时候的爱慕，只是将之当成一种仪式&lt;/p&gt;

&lt;p&gt;只有真正从中获得了乐趣，才会有上瘾般的偏好，才会有一种“我一空下来就得做这个”，而不是“我是要做这个的，不过等等我先看会儿闲书吧”。&lt;/p&gt;

&lt;h2 id=&quot;no-time-to-do&quot;&gt;一种自我蛊惑&amp;lt;—-&amp;gt;No time to do&lt;/h2&gt;

&lt;p&gt;每个人都会想：我周末要回家看爸妈；我每天回家要给爸妈打个电话问平安……但这心思总存不了太久；总得要父母说得了病，去日无多，有了个期限，人才会一股脑儿，把久已储藏的情感倾泻而出。&lt;/p&gt;

&lt;p&gt;将这里的父母和你从来想做，又从来没开始着手的业余爱好做个替换，道理相去不远。&lt;/p&gt;

&lt;p&gt;成就来自经年累月的累积，累积来自于坚持，坚持受着快感的鼓励，快感则是可以通过自我压迫+释放来获得的（人是有受虐倾向的）；而许多时候，自我压迫，就来自于永不得到或即将逝去的恐惧。&lt;/p&gt;

&lt;p&gt;所以，一种自我蛊惑的心情是：“如果我现在不做某事，也许以后也没时间了。”&lt;/p&gt;

&lt;h2 id=&quot;just-do-it&quot;&gt;清空大脑，简单粗暴—&amp;gt;just do it&lt;/h2&gt;

&lt;p&gt;到最后，当你把心理深层那些欺软怕硬、好吃懒做的东西都摸明白了，也就没必要自我蛊惑了。&lt;/p&gt;

&lt;p&gt;你能够洞悉所谓拖延症，也只是耽于舒适领域，所以便只剩干脆的一点，不要前思后想，只清空大脑，然后简单粗暴的给自己一下：&lt;/p&gt;

&lt;p&gt;“别多想，只管开始做！”&lt;/p&gt;
</description>
                <link>http://mwumli.github.io/%E6%83%85%E7%BB%AA/2014/05/04/just-do-it</link>
                <guid>http://mwumli.github.io/%E6%83%85%E7%BB%AA/2014/05/04/just-do-it</guid>
                <pubDate>2014-05-04T00:00:00+00:00</pubDate>
        </item>

        <item>
                <title>Vim的安装与配置</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#debianubuntu&quot; id=&quot;markdown-toc-debianubuntu&quot;&gt;Debian/ubuntu下安装&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;编写配置文件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vim&quot; id=&quot;markdown-toc-vim&quot;&gt;查看vim做过什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vim-1&quot; id=&quot;markdown-toc-vim-1&quot;&gt;Vim的四大模式&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#normal-mode----press-esc-to-enter&quot; id=&quot;markdown-toc-normal-mode----press-esc-to-enter&quot;&gt;Normal mode	—-	Press [Esc] to enter&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#visual-mode----press-escv-to-enter&quot; id=&quot;markdown-toc-visual-mode----press-escv-to-enter&quot;&gt;Visual mode	—-	press [Esc]+v to enter&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#insert-mode----press-escioa-to-enter&quot; id=&quot;markdown-toc-insert-mode----press-escioa-to-enter&quot;&gt;Insert mode	—-	press [Esc]+[i,o,a] to enter&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#command-line-mode----press-esc-to-enter&quot; id=&quot;markdown-toc-command-line-mode----press-esc-to-enter&quot;&gt;Command-line mode	—-	press [Esc]+[:] to enter&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vim-2&quot; id=&quot;markdown-toc-vim-2&quot;&gt;vim的环境设定参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;debianubuntu&quot;&gt;Debian/ubuntu下安装&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$sudo apt-get install vim
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;编写配置文件&lt;/h2&gt;

&lt;p&gt;vim用户自定义配置文件$(HOME)/.vimrc(若没有,请自行创建)&lt;br /&gt;
vim系统级配置文件/usr/share/vim/vimrc&lt;br /&gt;
而我们一般只修改~/.vimrc&lt;/p&gt;

&lt;h2 id=&quot;vim&quot;&gt;查看vim做过什么&lt;/h2&gt;

&lt;p&gt;~/.viminfo：记录了你曾经在vim上做过的操作(vim会自动创建)&lt;/p&gt;

&lt;h2 id=&quot;vim-1&quot;&gt;Vim的四大模式&lt;/h2&gt;

&lt;h3 id=&quot;normal-mode----press-esc-to-enter&quot;&gt;Normal mode	—-	Press [Esc] to enter&lt;/h3&gt;

&lt;p&gt;此mode是进入其他mode的基础&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	[Ctrl]+[f]	==	[PgDn]
	[Ctrl]+[b]	==	[PgUp]
	[Ctrl]+[d]		向下翻半页
	[Ctrl]+[u]		向上翻半页
	[Ctrl]+[g]  	显示位置信息
	[g]+[Ctrl]+[g]	统计字数
	[d]+[d]			删除光标所在行
	[W]				跳转到下一个单词的开头
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;visual-mode----press-escv-to-enter&quot;&gt;Visual mode	—-	press [Esc]+v to enter&lt;/h3&gt;

&lt;p&gt;选择区域：移动光标选择区域&lt;/p&gt;

&lt;p&gt;复制：选中区域后，按下y,选中的区域就被复制到剪贴板&lt;/p&gt;

&lt;p&gt;粘贴：移动光标到想要粘贴的位置，按下p,剪贴板的内容就被复制到该位&lt;/p&gt;

&lt;p&gt;区块选择：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;光标移动到想复制区域的左上角，然后按下[Ctrl-v],进入区块选择模式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;移动光标选择矩形区域，选定之后，选择的区域会反白，按下[y],反白区域消失，内容已进入vim复制缓冲区&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;移动光标到你想开始粘贴位置的起点，按下[p],刚才复制内容就会以矩形形式粘贴下来&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;insert-mode----press-escioa-to-enter&quot;&gt;Insert mode	—-	press [Esc]+[i,o,a] to enter&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	[Ctrl]+[n]和[Ctrl][p]	单词补全
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;command-line-mode----press-esc-to-enter&quot;&gt;Command-line mode	—-	press [Esc]+[:] to enter&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	:help	进入vim帮助文档
	:set all	查看vim的素有原始设置
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;vim-2&quot;&gt;vim的环境设定参数&lt;/h2&gt;

&lt;p&gt;两种设置方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在配置文件vimrc中写入(永久有效)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在vim的命令行模式下设置(只在此次打开的vim中有效)&lt;br /&gt;
展示一些常用参数：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &quot;设置高亮搜索
 set hlsearch	&quot;high light search,默认

 &quot;设置backspace按键的工作方式
 &quot;0,1表示只删除当前输入的字符
 &quot;2表示可任意删除字符,默认
 set backspace=[0,1,2]
	
 &quot;设置不自动缩进，自动缩进set autoindent
 set noautoindent	&quot;默认
                                                                       
 &quot;设置不显示行号	set nonumber显示行号
 set nonumber

 &quot;设置不自动储存备份,set backup	自动备份
 &quot;更改一个文件file时，会自动在当前路径生成一个file~的文件，记录上一步状态
 set nobackup
    
 &quot;语法高亮,syntax off 取消语法高亮
 syntax on
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/05/03/vim-install-config</link>
                <guid>http://mwumli.github.io/%E8%AE%B0%E5%BD%95/2014/05/03/vim-install-config</guid>
                <pubDate>2014-05-03T00:00:00+00:00</pubDate>
        </item>


</channel>
</rss>
