<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>倘若微小</title>
        <description>倘若微小 - MwumLi</description>
        <link>http://mwumli.github.io</link>
        <link>http://mwumli.github.io</link>
        <lastBuildDate>2015-12-13T23:14:24+08:00</lastBuildDate>
        <pubDate>2015-12-13T23:14:24+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>Ubuntu 下搭建 go 运行环境</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#go&quot; id=&quot;markdown-toc-go&quot;&gt;二进制安装 Go&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#go-1&quot; id=&quot;markdown-toc-go-1&quot;&gt;升级 Go&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#go-2&quot; id=&quot;markdown-toc-go-2&quot;&gt;卸载 Go&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#go--helloworld&quot; id=&quot;markdown-toc-go--helloworld&quot;&gt;go 语言版的 HelloWorld&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;参考链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里介绍一下如何搭建 go 语言的编译运行环境以及一个初始 Hello 程序&lt;/p&gt;

&lt;p&gt;Go 有两种构建方式 : 源码安装和二进制安装&lt;/p&gt;

&lt;p&gt;二进制安装比较简单, 这里主要讲述二进制安装&lt;/p&gt;

&lt;h2 id=&quot;go&quot;&gt;二进制安装 Go&lt;/h2&gt;

&lt;p&gt;下载适合你系统的 Go : &lt;a href=&quot;https://golang.org/dl/#featured&quot;&gt;https://golang.org/dl/#featured&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Go 的二进制的会默认假定安装到 &lt;code&gt;/usr/local/go/&lt;/code&gt; 中&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果你 &lt;strong&gt;安装 Go 到默认位置&lt;/strong&gt; , 那么你需要这样做 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz
 $ echo &quot;export PATH=$PATH:/usr/local/go/bin&quot; &amp;gt;&amp;gt; ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你需要 &lt;strong&gt;安装 Go 到指定位置&lt;/strong&gt; (Eg: &lt;code&gt;~/go/&lt;/code&gt;), 那么这样做 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tar -C ~/ -xzf go$VERSION.$OS-$ARCH.tar.gz
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;然后在 &lt;code&gt;~/.bashrc&lt;/code&gt; 末尾添加 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; export GOROOT=$HOME/go
 export PATH=$PATH:$GOROOT/bin
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; : &lt;code&gt;GOROOT&lt;/code&gt; 仅仅在安装 go 到指定位置的时候才需要设置&lt;/p&gt;

&lt;p&gt;只要你的 &lt;code&gt;.bashrc&lt;/code&gt; 生效, 那么你可以通过 &lt;code&gt;go version&lt;/code&gt; 打印当前 go 的版本号来确定是否安装成功&lt;/p&gt;

&lt;h2 id=&quot;go-1&quot;&gt;升级 Go&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;必须卸载已存在的旧的版本&lt;/li&gt;
  &lt;li&gt;按照上述方法安装新的 Go&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;go-2&quot;&gt;卸载 Go&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;删除 go 安装目录, 默认 &lt;code&gt;/usr/local/go/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在 shell 配置文件中去掉 Go 环境变量 &lt;code&gt;GOROOT&lt;/code&gt; 以及 &lt;code&gt;PATH&lt;/code&gt; 中 go 路径的配置&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;go--helloworld&quot;&gt;go 语言版的 HelloWorld&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;hello.go&lt;/code&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello, Wolrd. 你好, 世界.&quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后命令行中直接运行 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go run hello.go
Hello,World. 你好, 世界!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;go run&lt;/code&gt; 包含编译和运行两步&lt;/p&gt;

&lt;p&gt;你可以先生成可执行文件, 然后执行可执行文件, 比如这样 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go build hello.go
$ ls
hello hello.go
$ ./hello
Hello,World. 你好, 世界!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://docscn.studygolang.com/doc/install&quot;&gt;Go 的安装起步&lt;/a&gt;&lt;br /&gt;
这里有各种系统下 Go 的安装与配置&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://docscn.studygolang.com/doc/code.html&quot;&gt;如何使用 Go 编程&lt;/a&gt;&lt;br /&gt;
在这里你可以看到一个简单 Go 包的开发&lt;br /&gt;
并介绍用 go 工具来获取、 构建并安装 Go 包及命令的标准方式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://docscn.studygolang.com/&quot;&gt;Go 语言中文官方文档&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://docs.studygolang.com/&quot;&gt;Go 语言英文官方文档&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://studygolang.com/&quot;&gt;Go 语言中文网&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
                <link>http://mwumli.github.io/run-go-in-ubuntu</link>
                <guid>http://mwumli.github.io/run-go-in-ubuntu</guid>
                <pubDate>2015-11-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Sublime Text 安装与配置的那些事</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;安装&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#sublime-text-2&quot; id=&quot;markdown-toc-sublime-text-2&quot;&gt;Sublime Text 2&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#sublime-text-3&quot; id=&quot;markdown-toc-sublime-text-3&quot;&gt;Sublime Text 3&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;系统配置&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;中文输入和搜索&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#dock-&quot; id=&quot;markdown-toc-dock-&quot;&gt;固化在左侧的 dock 里&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;设置默认打开文档&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;注册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.sublimetext.com/&quot;&gt;Sublime Text&lt;/a&gt; 是一个很好用的编辑器, 无论对于编程还是文本编辑, 都非常不错&lt;/p&gt;

&lt;p&gt;它小巧且速度非常快，支持 &lt;code&gt;Win/Mac/Linux&lt;/code&gt; 等多种平台&lt;br /&gt;
也同时支持 32 位与 64 位&lt;/p&gt;

&lt;p&gt;它支持各种流行编程语言的语法高亮、代码补全&lt;/p&gt;

&lt;p&gt;它可以像 vim 一样安装插件，增强本身没有的功能，而且有比 Vim 更方便的插件浏览、安装和管理方式  &lt;br /&gt;
只需要一两个命令，就可以方便下载，等待使用&lt;/p&gt;

&lt;p&gt;它收费, 但是它提供免费使用，当然无限期，无限制，只是偶尔提醒你木有购买，而且频率很低，这点让人觉得很赞&lt;/p&gt;

&lt;p&gt;好的软件, 总是要付出软件创作者的巨大的心力, 如果你有足够的金子, 不妨买一个 &lt;a href=&quot;http://www.sublimetext.com/buy&quot;&gt;key&lt;/a&gt; 赞助一下&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;安装&lt;/h2&gt;

&lt;p&gt;Sublimex Text 目前有两个版本 2 和 3, 2 应该属于 LTS(Long Term Support),而 3 是 beta, 不过也算稳定&lt;/p&gt;

&lt;p&gt;至于安装哪个, 取决于你的选择&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下载地址&lt;/strong&gt; :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Sublime Text 2 : &lt;a href=&quot;http://www.sublimetext.com/2&quot;&gt;http://www.sublimetext.com/2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Sulimex Text 3 : &lt;a href=&quot;http://www.sublimetext.com/3&quot;&gt;http://www.sublimetext.com/3&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里只写 Ubuntu 下的安装与配置&lt;/p&gt;

&lt;h3 id=&quot;sublime-text-2&quot;&gt;Sublime Text 2&lt;/h3&gt;

&lt;p&gt;两种安装方式 :  源安装 和 下载压缩包&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;源安装&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo add-apt-repository ppa:webupd8team/sublime-text-2  
$ sudo apt-get update  
$ sudo apt-get install sublime-text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;压缩包安装&lt;/strong&gt; :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下载 Sublime text 2 : &lt;a href=&quot;http://www.sublimetext.com/2&quot;&gt;http://www.sublimetext.com/2&lt;/a&gt;&lt;br /&gt;
(提供的是一个压缩包, 暂且命名为 Sublime-Text-2.0.2-x64.tar.bz2)&lt;/li&gt;
  &lt;li&gt;解压缩到 &lt;code&gt;/opt&lt;/code&gt; 下 : &lt;code&gt;tar -xjvf Sublime-Text-2.0.2-x64.tar.bz2 -C /opt&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;建立软链接到 &lt;code&gt;/usr/bin&lt;/code&gt; 下 : &lt;code&gt;ln -s /opt/Sublime_Text_2 /usr/bin/subl&lt;/code&gt;&lt;br /&gt;
(建立在 PATH 变量任意路径下都可以)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;sublime-text-3&quot;&gt;Sublime Text 3&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载 Sublime Text 3: &lt;a href=&quot;http://www.sublimetext.com/3&quot;&gt;http://www.sublimetext.com/3&lt;/a&gt;&lt;br /&gt;
(提供的是一个 deb 文件, 暂且命名为为 sublime-text_build-3083_amd64.deb)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;命令安装 : &lt;code&gt;sudo dpkg -i sublime-text_build-3083_amd64.deb&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果出现依赖错误, 可以执行 : &lt;code&gt;sudo apt-get install -f&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;系统配置&lt;/h2&gt;

&lt;p&gt;在 Linux , 要想正常使用 Sublime, 你需要做些系统相关的配置&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;中文输入和搜索&lt;/h3&gt;

&lt;p&gt;Ubuntu 下, Sublimex Text 不能输入中文, 这个网上已经给出解决方案&lt;/p&gt;

&lt;p&gt;通过压缩包方式安装 Sublime, 在应用程序搜索中, 不会搜索到 Sublime&lt;br /&gt;
(按下 Window 键, 就唤起了应用程序搜索面板)&lt;/p&gt;

&lt;p&gt;解决方法如下 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;新建文件 &lt;code&gt;sublime-imfix.c&lt;/code&gt; :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; /*
    
  * sublime-imfix.c Use LD_PRELOAD to interpose some function to fix sublime
  * input method support for linux. By Cjacker Huang &amp;lt;jianzhong.huang at
  * i-soft.com.cn&amp;gt;
  * 
  * gcc -shared -o libsublime-imfix.so sublime_imfix.c `pkg-config --libs
  * --cflags gtk+-2.0` -fPIC LD_PRELOAD=./libsublime-imfix.so sublime_text 
    
  */
    
 #include &amp;lt;gtk/gtk.h&amp;gt;        
 #include &amp;lt;gdk/gdkx.h&amp;gt;
    
 typedef GdkSegment GdkRegionBox;        
    
    
 struct _GdkRegion {
     long            size;
     long            numRects;
     GdkRegionBox   *rects;
     GdkRegionBox    extents;
 };      
 GtkIMContext   *local_context;      
    
 void gdk_region_get_clipbox(const GdkRegion * region, GdkRectangle * rectangle)
 {
    
     g_return_if_fail(region != NULL);
     g_return_if_fail(rectangle != NULL);        
        

     rectangle-&amp;gt;x = region-&amp;gt;extents.x1;
     rectangle-&amp;gt;y = region-&amp;gt;extents.y1;
     rectangle-&amp;gt;width = region-&amp;gt;extents.x2 - region-&amp;gt;extents.x1;
     rectangle-&amp;gt;height = region-&amp;gt;extents.y2 - region-&amp;gt;extents.y1;
     GdkRectangle    rect;       
        

     rect.x = rectangle-&amp;gt;x;
     rect.y = rectangle-&amp;gt;y;
     rect.width = 0;
     rect.height = rectangle-&amp;gt;height;
    
     // The caret width is 2;
     // Maybe sometimes we will make a mistake, but for most of the time, it
     // should be the caret.
     if (rectangle-&amp;gt;width == 2 &amp;amp;&amp;amp; GTK_IS_IM_CONTEXT(local_context)) {
         gtk_im_context_set_cursor_location(local_context, rectangle);
     }
 }       
    
    
 // this is needed, for example, if you input something in file dialog and
 // return back the edit area
 // context will lost, so here we set it again.      
    
    
 static GdkFilterReturn event_filter(GdkXEvent * xevent, GdkEvent * event,
                                     gpointer im_context)
 {
     XEvent         *xev = (XEvent *) xevent;        

     if (xev-&amp;gt;type == KeyRelease &amp;amp;&amp;amp; GTK_IS_IM_CONTEXT(im_context)) {

         GdkWindow      *win = g_object_get_data(G_OBJECT(im_context), &quot;window&quot;);        
    
         if (GDK_IS_WINDOW(win))
             gtk_im_context_set_client_window(im_context, win);
    
     }
    
     return GDK_FILTER_CONTINUE;
 }       
    
    
 void gtk_im_context_set_client_window(GtkIMContext * context,
                                       GdkWindow * window)
 {
    
     GtkIMContextClass *klass;       
    
     g_return_if_fail(GTK_IS_IM_CONTEXT(context));
     klass = GTK_IM_CONTEXT_GET_CLASS(context);
    
     if (klass-&amp;gt;set_client_window)
         klass-&amp;gt;set_client_window(context, window);      
            
     if (!GDK_IS_WINDOW(window))
         return;
    
     g_object_set_data(G_OBJECT(context), &quot;window&quot;, window);

     int             width = gdk_window_get_width(window);
     int             height = gdk_window_get_height(window);     
    
     if (width != 0 &amp;amp;&amp;amp; height != 0) {
    
         gtk_im_context_focus_in(context);
         local_context = context;
     }
    
     gdk_window_add_filter(window, event_filter, context);
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装编译环境 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo apt-ger install build-essential libgtk2.0-dev -y
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编译共享库 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; gcc -shared -o libsublime-imfix.so sublime-imfix.c  `pkg-config --libs --cflags gtk+-2.0` -fPIC
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;移动共享库到 &lt;code&gt;/usr/lib/&lt;/code&gt; 下 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo mv libsublime-imfix.so /usr/lib/
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试一下是否能输入中文 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; LD_PRELOAD=./libsublime-imfix.so subl
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;命令行启动，自动使用共享库 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; echo &quot;LD_PRELOAD=/usr/lib/libsublime-imfix.so subl&quot; &amp;gt;&amp;gt; ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加应用程序菜单,自动使用共享库 :&lt;br /&gt;
新建 &lt;code&gt;/usr/share/applications/sublime_text.desktop&lt;/code&gt;, 内容如下 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [Desktop Entry]
 Version=1.0
 Type=Application
 Name=Sublime Text
 GenericName=Text Editor
 Comment=Sophisticated text editor for code, markup and prose
 Exec=bash -c &#39;LD_PRELOAD=/usr/lib/libsublime-imfix.so /opt/sublime_text/sublime_text %F&#39;
 Terminal=false
 MimeType=text/plain;
 Icon=sublime-text
 Categories=TextEditor;Development;
 StartupNotify=true
 Actions=Window;Document;

 [Desktop Action Window]
 Name=New Window
 Exec=bash -c &#39;LD_PRELOAD=/usr/lib/libsublime-imfix.so /opt/sublime_text/sublime_text -n&#39;
 OnlyShowIn=Unity;

 [Desktop Action Document]
 Name=New File
 Exec=bash -c &#39;LD_PRELOAD=/usr/lib/libsublime-imfix.so /opt/sublime_text/sublime_text --command new_file&#39;
 OnlyShowIn=Unity;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;重启或注销生效&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;dock-&quot;&gt;固化在左侧的 dock 里&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;通过命令行或者应用程序菜单启动 Sublime&lt;/li&gt;
  &lt;li&gt;在 dock 里会出现 Sublime 的图标, 点击右键，选择&lt;code&gt;lock from Launcher&lt;/code&gt;,然后它就被锁定在 dock 中了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以后你就可以直接可以从 dock 中打开 Sublime&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;设置默认打开文档&lt;/h3&gt;

&lt;p&gt;希望使用 sublime 成为某种特定文档的默认打开方式, 可以这样做 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;右键文件，选择&lt;code&gt;Propertites&lt;/code&gt;（属性）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点击&lt;code&gt;Open With&lt;/code&gt;, &lt;code&gt;Default Application&lt;/code&gt; 下选择&lt;code&gt;Sublime Text&lt;/code&gt;, 点击 &lt;code&gt;Set as default&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样，你双击打开每一个这种类型的文件，都会自动用&lt;code&gt;Sublime Text&lt;/code&gt;打开&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;注册&lt;/h2&gt;

&lt;p&gt;虽然可以一直免费使用，但是弹出来的警告框总是令人很不爽&lt;br /&gt;
有幸在网络上搜集到一枚 Sublimex Text 2 的注册码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;----- BEGIN LICENSE -----
Andrew Weber
Single User License
EA7E-855605
813A03DD 5E4AD9E6 6C0EEB94 BC99798F
942194A6 02396E98 E62C9979 4BB979FE
91424C9D A45400BF F6747D88 2FB88078
90F5CC94 1CDC92DC 8457107A F151657B
1D22E383 A997F016 42397640 33F41CFC
E1D0AE85 A0BBD039 0E9C8D55 E1B89D5D
5CDB7036 E56DE1C0 EFCC0840 650CD3A6
B98FC99C 8FAC73EE D2B95564 DF450523
------ END LICENSE ------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过，若是大家手头方便的话，不妨支持一下&lt;a href=&quot;http://www.sublimetext.com/buy&quot;&gt;正版&lt;/a&gt;，毕竟辛辛苦苦做一个软件不容易，何况还是这么好的软件(将来可能会更好)&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/sublime-text-such-things</link>
                <guid>http://mwumli.github.io/sublime-text-such-things</guid>
                <pubDate>2015-11-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Ubuntu 下安装 nodejs</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ubuntu-&quot; id=&quot;markdown-toc-ubuntu-&quot;&gt;Ubuntu 下的安装&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;源安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#node-version-manager&quot; id=&quot;markdown-toc-node-version-manager&quot;&gt;Node Version Manager&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;安装&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;各大平台下 nodejs 的安装看这里 : &lt;a href=&quot;https://nodejs.org/en/download/package-manager/#windows&quot;&gt;https://nodejs.org/en/download/package-manager/#windows&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Nodejs 发展比较快, 所以版本更新迭代快&lt;/p&gt;

&lt;h2 id=&quot;ubuntu-&quot;&gt;Ubuntu 下的安装&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;源安装&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Nodejs v5.x&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sL https://deb.nodesource.com/setup_5.x | sudo -E bash -
sudo apt-get install -y nodejs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Nodejs v4.x&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sL https://deb.nodesource.com/setup_4.x | sudo -E bash -
sudo apt-get install -y nodejs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如你在使用 Ubuntu 12.04 以及更低版本,请升级你的系统, 再进行安装&lt;br /&gt;
至于原因，看这里 : &lt;a href=&quot;https://github.com/nodesource/distributions/blob/master/OLDER_DISTROS.md&quot;&gt;https://github.com/nodesource/distributions/blob/master/OLDER_DISTROS.md&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;node-version-manager&quot;&gt;Node Version Manager&lt;/h3&gt;

&lt;p&gt;Nodejs 升级迭代很快, 不同的 Nodejs 项目，可能使用的是不同版本的 Nodejs&lt;br /&gt;
因此, 要维持多个 Nodejs 项目, 那就需要一种工具来管理 nodejs&lt;/p&gt;

&lt;p&gt;这就是 Node Version Manager&lt;/p&gt;

&lt;p&gt;目前, 有两个比较有名的 Node Version Manager : &lt;a href=&quot;https://github.com/tj/n&quot;&gt;n&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/creationix/nvm&quot;&gt;nvm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Github 上 nvm 的 Star 明显是 n 的 2 倍多&lt;br /&gt;
因此, 这里讲述一下 nvm 的安装与使用&lt;/p&gt;

&lt;p&gt;nvm 项目地址 : &lt;a href=&quot;https://github.com/creationix/nvm&quot;&gt;https://github.com/creationix/nvm&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;安装&lt;/h4&gt;

&lt;p&gt;nvm 给出了自动安装的脚本, 因此你可以用过 &lt;code&gt;wget&lt;/code&gt;, &lt;code&gt;curl&lt;/code&gt; 实现自动安装, 看这里 :
&lt;a href=&quot;https://github.com/creationix/nvm#install-script&quot;&gt;https://github.com/creationix/nvm#install-script&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里主要讲一下手动安装&lt;br /&gt;
手动安装可以使你明白自动安装到底做了什么&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装前的准备 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo apt-get install build-essential libssl-dev -y
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;克隆仓库到 &lt;code&gt;~/.nvm&lt;/code&gt; :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; git clone https://github.com/creationix/nvm.git ~/.nvm &amp;amp;&amp;amp; cd ~/.nvm &amp;amp;&amp;amp; git checkout `git describe --abbrev=0 --tags`
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加下面到 &lt;code&gt;~/.bashrc&lt;/code&gt;(&lt;code&gt;~/.profile&lt;/code&gt;或 &lt;code&gt;~/.zshrc&lt;/code&gt;) :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; export NVM_DIR=&quot;$HOME/.nvm&quot;
 [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;amp;&amp;amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-2&quot;&gt;使用&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装一个指定的版本 : &lt;code&gt;nvm install v0.10.32&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装最新的 0.10.x 版本 : &lt;code&gt;nvm install 0.10&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 v0.10.32 版本的 nodejs 去运行 app.js :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; nvm run 0.10.32 node app.js
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示已安装的 v0.10.32 node 的安装路径 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; nvm which v0.10.32
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;node&lt;/code&gt; 代表最新版本的 node, 因此你可以直接在 &lt;code&gt;nvm use&lt;/code&gt;, &lt;code&gt;nvm install&lt;/code&gt;, &lt;code&gt;nvm exec&lt;/code&gt;, &lt;code&gt;nvm which&lt;/code&gt; 中使用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在一个 nodejs 中集成其他版本的 &lt;code&gt;npm&lt;/code&gt; :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; nvm install v5.0 --reinstall-packages-from=4.2
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用系统安装的 node :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; nvm use system
 nvm run system --version
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;列出当前已经安装的 node :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; nvm ls
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;列出当前可以获得的 node :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; nvm ls-remote
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
                <link>http://mwumli.github.io/install-nodejs-on-ubuntu</link>
                <guid>http://mwumli.github.io/install-nodejs-on-ubuntu</guid>
                <pubDate>2015-11-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>构建 SSH 隧道 -- 端口转发</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ssh-&quot; id=&quot;markdown-toc-ssh-&quot;&gt;SSH 隧道&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ssh--1&quot; id=&quot;markdown-toc-ssh--1&quot;&gt;SSH 隧道的类型&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;参数提前说明&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#socks-&quot; id=&quot;markdown-toc-socks-&quot;&gt;动态端口转发 – SOCKS 代理&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;假设&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;命令原型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;实际使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;本地端口转发&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;假设&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;命令原型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;实际使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;远程端口转发&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;假设&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-10&quot; id=&quot;markdown-toc-section-10&quot;&gt;命令原型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-11&quot; id=&quot;markdown-toc-section-11&quot;&gt;实际应用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ssh--2&quot; id=&quot;markdown-toc-ssh--2&quot;&gt;SSH 一些辅助参数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-12&quot; id=&quot;markdown-toc-section-12&quot;&gt;相关命令&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-13&quot; id=&quot;markdown-toc-section-13&quot;&gt;代理软件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ssh-&quot;&gt;SSH 隧道&lt;/h2&gt;

&lt;p&gt;使用 SSH 可以进行端口转发，从而实现流往某端口的数据被加密后传向另一机器,这个过程形似构造了一条通道，因此也称之为 SSH 隧道(SSH Tunnel)&lt;/p&gt;

&lt;p&gt;使用 SSH 隧道可以让数据被加密并透明地传输到远端系统&lt;/p&gt;

&lt;h3 id=&quot;ssh--1&quot;&gt;SSH 隧道的类型&lt;/h3&gt;

&lt;p&gt;SSH 隧道有三种类型 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;动态端口转发 (socks 代理)&lt;/li&gt;
  &lt;li&gt;本地端口转发&lt;/li&gt;
  &lt;li&gt;远程端口转发&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;参数提前说明&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;bind_address&lt;/code&gt; – 可选的, 监听的网卡地址
    &lt;ol&gt;
      &lt;li&gt;省略 – 取决于  &lt;code&gt;GatewayPorts&lt;/code&gt; 的设置(man 手册可以看到，但是没有在 Ubuntu 14.04中找到)&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;localhost&lt;/code&gt;/&lt;code&gt;127.0.0.1&lt;/code&gt; – 监听 127.0.0.1, 仅能用于本地&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;0.0.0.0&lt;/code&gt;/&lt;code&gt;*&lt;/code&gt; – 监听本机所有网络接口&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;hostX&lt;/code&gt; – 主机 hostX 的 ip 或 域名&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;hostX_port&lt;/code&gt; – 主机hostX 的空闲端口
    &lt;ol&gt;
      &lt;li&gt;0 - 1023 : 特权端口,只能 root 用户才能进行端口转发&lt;br /&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports&quot;&gt;特权端口列表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;1024 - 65535 : 选择一个没被占用的端口&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;user@hostX&lt;/code&gt; – 用户名为 &lt;code&gt;user&lt;/code&gt; 可以登录主机 hostX&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;socks-&quot;&gt;动态端口转发 – SOCKS 代理&lt;/h2&gt;

&lt;p&gt;支持 SOCKS4 和 SOCKS5 代理&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;假设&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;存在两台主机 host1, host2&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host1 可以 SSH 连接 host2&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以使 host1 某端口的数据发往 host2, host2 根据其应用程序协议发出到指定地址, 就好像是从 host2 直接发出的数据&lt;/p&gt;

&lt;p&gt;可以认为我们搭建了一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_server&quot;&gt;代理服务器(Proxy Server)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;于是就有了下面这个命令 (&lt;code&gt;host1上执行&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;命令原型&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;host1 $ ssh -D [bind_address:]host1_port user@host2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;动态端口转发的过程 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;host1 申请了一个 socket 来监听 &lt;code&gt;bind_address:host1_port&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host1 与 host2 建立一条 ssh 隧道&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当 host1 有请求 &lt;code&gt;bind_address:host1_port&lt;/code&gt;, 请求数据会从 ssh 隧道发往 host2&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host2 收到数据, 根据数据的应用程序协议去发送数据到指定的地址&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;返回数据会按原有路径返还&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-3&quot;&gt;实际使用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;host1 $ ssh -D 127.0.0.1:7070 user@host2
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;chrome 上使用 proxy SwitchySharp 进行代理设置
    &lt;ol&gt;
      &lt;li&gt;新建情景模式 &lt;code&gt;proxy&lt;/code&gt;, 在 &lt;code&gt;socks代理&lt;/code&gt; 那行填入 &lt;code&gt;127.0.0.1&lt;/code&gt; 和 端口那栏填入 &lt;code&gt;7070&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;点击 proxy SwitchySharp 的头标, 勾选 &lt;code&gt;proxy&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Ubuntu 下使用 proxychains 为应用程序设置代理
    &lt;ol&gt;
      &lt;li&gt;安装 – &lt;code&gt;sudo apt-get install proxychains&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;修改配置文件(&lt;code&gt;/etc/proxychains.conf&lt;/code&gt;)的 &lt;code&gt;[ProxyList]&lt;/code&gt; 为自己的代理 : &lt;code&gt;socks4 127.0.0.1 7070&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;让程序使用代理 : &lt;code&gt;proxychains program-name&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以使用 &lt;code&gt;curl&lt;/code&gt; 进行下载验证&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ curl --sock5 localhost:7070 download-link
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-4&quot;&gt;本地端口转发&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;假设&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;存在三台主机 host1, host2, host3&lt;/li&gt;
  &lt;li&gt;host1 和 host3 不能通信&lt;/li&gt;
  &lt;li&gt;host2 可以同时和 host1 与 host3 通信&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此, 我们可以借助 host2 实现 host1 和 host3 的通信&lt;/p&gt;

&lt;p&gt;于是就有了下面这个命令原型(&lt;code&gt;host1 上执行&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;命令原型&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;host1 $ ssh -L [bind_address:]host1_port:host3:host3_port user@host2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本地端口转发的过程 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;绑定 host1 的 &lt;code&gt;bind_address:host1_port&lt;/code&gt;, 与 host2 构建一条 SSH 隧道&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当我们请求 &lt;code&gt;bind_address:host1_port&lt;/code&gt; 时, 请求的数据通过 SSH 隧道到达 host2，host2 就会把数据发送到 host3 的 &lt;code&gt;host3_port&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;返回的数据按照原路返回&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-7&quot;&gt;实际使用&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;通过访问 host1 本地 8080 端口来访问 host3 的 80 端口(host3 已经安装 Web 服务)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; host1 $ ssh -L 8080:host3:80 user@host2
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;执行完成，在 host1 浏览器中 输入 &lt;code&gt;localhost:8080&lt;/code&gt; 即可看到 host3 的 Web 页面&lt;br /&gt;
如果使用 xshell 等工具访问 host1, 那么可以使用 &lt;code&gt;curl localhost:8080&lt;/code&gt; 来查看 Web 内容&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host1 使用 ssh 登录 host3 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; host1 $ ssh -L 2030:host3:22 user@host2
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;现在你可以在另开一个 host1 终端输入 : &lt;code&gt;ssh -p 2030 user@host3&lt;/code&gt; 去登录 host3&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-8&quot;&gt;远程端口转发&lt;/h2&gt;

&lt;h3 id=&quot;section-9&quot;&gt;假设&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;存在三台主机 host1, host2, host3&lt;/li&gt;
  &lt;li&gt;host1 和 host3 不能相互访问&lt;/li&gt;
  &lt;li&gt;host2 可以和 host3 相互访问&lt;/li&gt;
  &lt;li&gt;host2 可以 ssh 访问 host1&lt;/li&gt;
  &lt;li&gt;host1 不可以访问 host2&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样的话, host1 就不可以 ssh 连接 host2 了，所以本地端口转发就不能用了&lt;br /&gt;
而 host2 可以 ssh 连接 host1, 那么 host1 就可以借助这条连接与 host3 进行通信&lt;/p&gt;

&lt;p&gt;这就是 SSH 的远程端口转发&lt;/p&gt;

&lt;p&gt;于是就有了下面这个命令原型 (&lt;code&gt;host2 上执行&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;命令原型&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;host2 $ ssh -R [bind_address:]host1_port:host3:host3_port user@host1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;远程端口转发的过程 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;host2 与 host1 构建了一条 ssh 隧道&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host1 申请了一个 socket 随时监听 &lt;code&gt;bind_address:host1_port&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当 host1 有请求 &lt;code&gt;bind_address:host1_port&lt;/code&gt; 时, 请求的数据会从 ssh 隧道 发往 host2&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host2 收到数据, 然后转发数据到 &lt;code&gt;host3:host3_port&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;返回数据按原路径返还&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-11&quot;&gt;实际应用&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;通过访问 host1 本地 8080 端口来访问 host3 的 80 端口(host3 已经安装 Web 服务)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; host2 $ ssh -R 8080:host3:80 user@host1
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;执行完成，在 host1 浏览器中 输入 &lt;code&gt;localhost:8080&lt;/code&gt; 即可看到 host3 的 Web 页面&lt;br /&gt;
如果使用 xshell 等工具访问 host1, 那么可以使用 &lt;code&gt;curl localhost:8080&lt;/code&gt; 来查看 Web 内容&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host1 使用 ssh 登录 host3 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; host2 $ ssh -R 2030:host3:22 user@host1
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;现在你可以在另开一个 host1 终端输入 : &lt;code&gt;ssh -p 2030 user@host3&lt;/code&gt; 去登录 host3&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;ssh--2&quot;&gt;SSH 一些辅助参数&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;-q&lt;/code&gt; – 安静模式. 抑制警告和诊断信息&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-T&lt;/code&gt; – 不分配伪终端，只是使用隧道&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-N&lt;/code&gt; – 不运行远程命令(仅对端口转发有用)&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-f&lt;/code&gt; – 后台运行
    &lt;ul&gt;
      &lt;li&gt;配合 &lt;code&gt;-N&lt;/code&gt; 一起使用, 否则产生 &lt;code&gt;Cannot fork into background without a command to execute.&lt;/code&gt;的错误&lt;/li&gt;
      &lt;li&gt;或者在命令末尾加上一个简单的命令 : &lt;code&gt;sleep 30&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-n&lt;/code&gt; – 重定向标准输入到 &lt;code&gt;/dev/null&lt;/code&gt;(阻止从标准输入读)&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-o ServerAliveInterval=60&lt;/code&gt; – 让 SSH 每隔一段时间发送一些消息,避免隧道关闭 &lt;code&gt;Write failed: Broken pipe&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;-v&lt;/code&gt; – 打印调试信息&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  ssh -qTfnN -D 7070 xxx@yyy.com	//ssh 后台动态端口转发
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-12&quot;&gt;相关命令&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;查看端口是否占用 : &lt;code&gt;sudo lsof -i :port&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;使用 &lt;code&gt;curl&lt;/code&gt; 下载文档&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-13&quot;&gt;代理软件&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.proxycap.com/download.html&quot;&gt;proxycap&lt;/a&gt; – windows&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.proxifier.com/&quot;&gt;Proxifier&lt;/a&gt; – windows/OS – 全局代理&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://proxychains.sourceforge.net/&quot;&gt;proxychains&lt;/a&gt; – Linux&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/darkk/redsocks&quot;&gt;readsocks&lt;/a&gt; – Linux&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://tsocks.sourceforge.net/&quot;&gt;tsocks&lt;/a&gt; – Linux – 全局代理&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm?utm_source=chrome-app-launcher-info-dialog&quot;&gt;Proxy SwitchySharp&lt;/a&gt; – chrome&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;curl&lt;/code&gt; 支持 socks4/SOCKS5 等代理下载  – 太棒了, 命令行用起来很方便&lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://mwumli.github.io/ssh-port-forwarding</link>
                <guid>http://mwumli.github.io/ssh-port-forwarding</guid>
                <pubDate>2015-09-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用 SSH 进行远程操作</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ssh-copy-id-&quot; id=&quot;markdown-toc-ssh-copy-id-&quot;&gt;ssh-copy-id 做了什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;做些什么(几个实例)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;远程自动化脚本的实现&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;是否允许分配伪终端&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;参考链接&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用 SSH 可以实现直接在本地对远程主机执行操作&lt;/p&gt;

&lt;h2 id=&quot;ssh-copy-id-&quot;&gt;ssh-copy-id 做了什么&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ ssh-copy-id ifmicro@remote-host  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它实现了这样一个功能 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;把 `~/.ssh/id_rsa.pub` 内容添加到 remote-host 的用户 ifmicro 的用户主目录下的文件 `~/.ssh/authorized_keys` 的末尾  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过命令组合, 我们也可以实现同样的功能 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh ifmicro@remote-host &#39;mkdir -p .ssh &amp;amp;&amp;amp; cat &amp;gt;&amp;gt; .ssh/authorized_keys &amp;amp;&amp;amp; chmod 600 .ssh/authorized_keys&#39; &amp;lt; ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此, 我们可以得出这样一个结论 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SSH 可以在用户和服务器之间，建立一条通道来实现命令和数据的传输  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;做些什么(几个实例)&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;复制 &lt;code&gt;hello-cpp/&lt;/code&gt; 目录下的东西到远程主机的 &lt;code&gt;~/hello-cpp&lt;/code&gt; 目录下 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tar czv hello-cpp | ssh ifmicro@remote-host &#39;tar xz&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将服务器 &lt;code&gt;~/hello-cpp/&lt;/code&gt; 下的东西复制到本地当前目录 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ ssh ifmicro@remote-host &#39;tar czv hello-cpp&#39; | tar xz
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看服务器的有多少个用户 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ ssh ifmicro@remote-host &#39;ls .. | wc -w&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;远程自动化脚本的实现&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
# 这只是一个远程自动化脚本的架构  
remote_auto(){
	ssh -T $1 &amp;lt;&amp;lt;&quot;EOF&quot;
	echo &quot;Hi, I&#39;m in $1, my name is&quot;$(whoami);
	pwd;
	# 这里可以添加更多的命令
	EOF
}

# 这里可以继续添加更多其他服务器执行任务
remote_auto ifmicro@remote-host-1 &amp;amp;
remote_auto ifmicro@remote-host-1 &amp;amp;
...

# 等待所有后台进程结束
wait 
# 做些结果处理
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;自行填充这个脚本中的内容&lt;/li&gt;
  &lt;li&gt;请学习 &lt;a href=&quot;http://www.tldp.org/LDP/abs/html/here-docs.html&quot;&gt;here Document&lt;/a&gt; 的语法&lt;/li&gt;
  &lt;li&gt;根据需求使用 &lt;code&gt;ssh -T&lt;/code&gt; 或 &lt;code&gt;ssh -t&lt;/code&gt; 、&lt;code&gt;ssh -tt&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;是否允许分配伪终端&lt;/h3&gt;

&lt;p&gt;当采用 Here Document 执行命令的时候，可能会出现 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Pseudo-terminal will not be allocated because stdin is not a terminal.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意思是无法分配一个伪终端给这个 ssh 链接&lt;/p&gt;

&lt;p&gt;在伪终端中执行脚本, 可以进行交互&lt;br /&gt;
而没有伪终端, 则不能进行交互&lt;/p&gt;

&lt;p&gt;因此对于此的解决方案就呼之欲出了 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;禁止分配伪终端 – 使用 &lt;code&gt;ssh -T&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;强制分配伪终端 – 使用 &lt;code&gt;ssh -t&lt;/code&gt;  或 &lt;code&gt;ssh -tt&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里是 &lt;code&gt;man ssh&lt;/code&gt; 中这两个参数的描述 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-T	Disable pseudo-terminal allocation.
-t	Force pseudo-terminal allocation. This can be used to execute arbitrary screen-based 
	programs on a remote machine, which can be very useful, e.g. when implementing menu 
	services. Multiple -t options force tty allocation, even if ssh has no local tty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们上面的自动化脚本框架中使用了 &lt;code&gt;ssh -T&lt;/code&gt;, 是因为对于自动化来说，基本上不用交互的&lt;br /&gt;
当然也有可能需要交互, 可以考虑 &lt;code&gt;expect&lt;/code&gt; 来实现自动交互&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;参考链接&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.unixmantra.com/2014/03/a-simple-way-to-send-multiple-line-commands-over-ssh.html&quot;&gt;a-simple-way-to-send-multiple-line-commands-over-ssh&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.tldp.org/LDP/abs/html/here-docs.html&quot;&gt;Here Document-en&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://shouce.jb51.net/shell/here-docs.html&quot;&gt;Here Document-zh&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.open-open.com/lib/view/open1415793400445.html&quot;&gt;shell 操作之 read、cat 和 here document&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://mwumli.github.io/ssh-remote-run-cmd</link>
                <guid>http://mwumli.github.io/ssh-remote-run-cmd</guid>
                <pubDate>2015-09-23T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用 SSH 登录服务器</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ssh-&quot; id=&quot;markdown-toc-ssh-&quot;&gt;SSH 是什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ssh&quot; id=&quot;markdown-toc-ssh&quot;&gt;安装 SSH&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;两种登陆方式&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;使用密码口令登录服务器&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;验证流程&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;使用公钥实现无密码登录&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;登录流程&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;第一次登录服务器&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;中间人攻击&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;公钥加密技术&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-10&quot; id=&quot;markdown-toc-section-10&quot;&gt;一些思考&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-11&quot; id=&quot;markdown-toc-section-11&quot;&gt;一些相关的文件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-12&quot; id=&quot;markdown-toc-section-12&quot;&gt;待补充&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ssh-&quot;&gt;SSH 是什么&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Secure_Shell&quot;&gt;SSH&lt;/a&gt; 是一个允许两台电脑之间通过安全的连接进行数据交换的网络协议&lt;br /&gt;
它采用公钥加密技术对传输的数据进行加密, 保证了数据的保密性和完整性&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/OpenSSH&quot;&gt;OpenSSH&lt;/a&gt; 是 SSH 协议的一种实现，是一种比较 popular 的远程登录服务器的软件&lt;/p&gt;

&lt;h2 id=&quot;ssh&quot;&gt;安装 SSH&lt;/h2&gt;

&lt;p&gt;Linux 主机普遍默认安装 OpenSSH&lt;/p&gt;

&lt;p&gt;客户端安装 ssh client 去登录服务器 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install openssh-client
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务器端安装 ssh server 用以验证客户端的登录 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install openssh-server
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;两种登陆方式&lt;/h2&gt;

&lt;p&gt;SSH 提供两种登录服务器的方式 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用密码口令&lt;/li&gt;
  &lt;li&gt;使用公钥实现无密码登录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在此，做出以下假定 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;服务器上的用户名 : &lt;code&gt;ifmicro&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;服务器地址 : &lt;code&gt;remote-host&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;服务器的 SSH 服务监听端口 : &lt;code&gt;22&lt;/code&gt;(默认)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-1&quot;&gt;使用密码口令登录服务器&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;使用&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ ssh ifmicro@remote-host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果本地用户名也是 &lt;code&gt;ifmicro&lt;/code&gt; , 那么 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh ifmicro
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如你的服务器 SSH 服务监听端口是 &lt;code&gt;2222&lt;/code&gt; , 那么 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh -p 2222 ifmicro@remote-host
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-3&quot;&gt;验证流程&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;客户端想服务器发送登录请求&lt;/li&gt;
  &lt;li&gt;服务器收到请求，把自己的公钥发给用户&lt;/li&gt;
  &lt;li&gt;用户使用这个公钥，对自己的密码进行加密，然后发送给服务器&lt;/li&gt;
  &lt;li&gt;服务器用自己的私钥对收到加密后的密码进行解密，如果密码正确，就同意用户登录&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-4&quot;&gt;使用公钥实现无密码登录&lt;/h3&gt;

&lt;h4 id=&quot;section-5&quot;&gt;使用&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;生成公钥和私钥(如果存在，请忽略) :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;

 Generating public/private rsa key pair.
 Enter file in which to save the key (/home/vagrant/.ssh/id_rsa):
 Enter passphrase (empty for no passphrase):
 Enter same passphrase again:
 Your identification has been saved in /home/vagrant/.ssh/id_rsa.
 Your public key has been saved in /home/vagrant/.ssh/id_rsa.pub.
 The key fingerprint is:
 2e:a3:02:c9:f1:bd:bd:d3:2e:85:26:4c:4a:b6:d1:11 your_email@example.com
 The key&#39;s randomart image is:
 +--[ RSA 4096]----+
 |     E.          |
 |     .           |
 |    . .          |
 | . + o           |
 |..= B   S        |
 |o. + + + .       |
 | .    B +        |
 |  .  o * .       |
 |   ..  .=.       |
 +-----------------+
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;一路默认即可，生成的私钥和公钥位于 &lt;code&gt;~/.ssh/&lt;/code&gt; : &lt;code&gt;id_rsa&lt;/code&gt;(私钥) 和 &lt;code&gt;id_rsa.pub&lt;/code&gt;(公钥)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把公钥添加到服务器的 &lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt; 末尾:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ ssh-copy-id -i id_rsa.pub ifmicro@remote-host
 /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
 /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
 ifmicro@remote-host&#39;s password:

 Number of key(s) added: 1

 Now try logging into the machine, with:   &quot;ssh &#39;ifmicro@remote-host&#39;&quot;
 and check to make sure that only the key(s) you wanted were added.
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;可以看到已经成功添加&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 ssh 登录服务器 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ ssh -i ~/.ssh/id_rsa ifmicro@remote-host
 Last login: Tue Sep 22 06:39:30 2015 from 10.18.61.57
 ifmicro@remmote-host $ 
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;如果私钥是 &lt;code&gt;~/.ssh/id_rsa&lt;/code&gt; ，那么可以忽略 &lt;code&gt;-i ~/.ssh/id_isa&lt;/code&gt;  选项&lt;br /&gt;
否则，请用 &lt;code&gt;-i private_key&lt;/code&gt; 指定私钥&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-6&quot;&gt;登录流程&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;客户端向服务器发送登录请求&lt;/li&gt;
  &lt;li&gt;服务器收到请求后, 向客户端发送一断随机字符串&lt;/li&gt;
  &lt;li&gt;客户端收到字符串，然后用自己的私钥进行加密，发送给服务器&lt;/li&gt;
  &lt;li&gt;服务器用实现客户给的公钥进行解密, 如果解密成功, 证明用户可信，登录成功&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-7&quot;&gt;第一次登录服务器&lt;/h3&gt;

&lt;p&gt;第一次登录服务器 , 系统会有如下提示 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The authenticity of host &#39;remote-host (10.108.79.5)&#39; can&#39;t be established.
RSA key fingerprint is 31:51:f8:e3:53:01:c4:76:af:60:9c:3b:b3:1b:5e:37.
Are you sure you want to continue connecting (yes/no)?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段话意思是本地主机在这之前没有与服务器 remote-host 建立过链接, 无法确定服务器的真实性&lt;br /&gt;
只知道 RSA 公钥的指纹&lt;sup id=&quot;fnref:fingerprint&quot;&gt;&lt;a href=&quot;#fn:fingerprint&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，是否要继续连接&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;ssh-keygen&lt;/code&gt; 工具可以生成 SSH 密钥对，其中公钥的长度很长，对于用户来说不容易比较&lt;br /&gt;
因此对其进行 MD5 计算生成的 128 位指纹进行比较就非常容易了&lt;/p&gt;

&lt;p&gt;为了确认主机的真实性，这里就要求我们事先知道服务器的公钥指纹&lt;/p&gt;

&lt;p&gt;如果你确定这是你要登录的那台服务器，那么输入 &lt;code&gt;yes&lt;/code&gt; 继续连接&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果你采用密码口令登录服务器，那么&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Warning: Permanently added &#39;remote-host,10.108.79.5&#39; (RSA) to the list of known hosts.
 Enter passphrase for key &#39;/home/vagrant/.ssh/id_rsa&#39;:
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;输入密码，如果密码正确，那么登录成功&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你采用公钥认证登录服务器, 那么输出上面这条 &lt;code&gt;Warning&lt;/code&gt;, 就直接登录上服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一次登录成功后, 服务器的公钥会被保存到文件 &lt;code&gt;$HOME/.ssh/known_hosts&lt;/code&gt; 中&lt;br /&gt;
下次登录服务器，&lt;code&gt;Warning&lt;/code&gt; 消失&lt;/p&gt;

&lt;p&gt;每个 SSH 用户都有自己的 &lt;code&gt;known_hosts&lt;/code&gt; 文件&lt;br /&gt;
系统也有一个这样的文件，通常是 &lt;code&gt;/etc/ssh/ssh_known_hosts&lt;/code&gt; 保存一些对所有用户都可信赖的服务器的公钥&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;中间人攻击&lt;/h3&gt;

&lt;p&gt;SSH 之所以可以保证安全，是因为采用了公钥加密信息&lt;/p&gt;

&lt;p&gt;在上面我们可以看到，使用密码口令的真个过程本身是安全的, 但是存在这个一个风险 ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;如果有攻击者截获了用户的登录请求，然后冒充服务器，将伪造后的公钥发送给用户  
用户在不知情或难辨真伪的情况下,用这个伪造密钥进行加密，然后发送给服务器  
然后攻击者又一次截获，获得用伪造密钥加密的密码，然后用自己的私钥进行解密，就得到了用户在服务器上的账号和密码  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于使用口令进行 ssh 登录的情况下，伪造的公钥很难辨别真伪&lt;br /&gt;
因为公钥都是自己签发的, 没有证书中心 (CA) 公正&lt;/p&gt;

&lt;p&gt;可以设想一下 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;如果攻击者在用户登录服务器时, 截获登录请求，并用伪造的公钥欺骗用户, 那么很容易获取用户在服务上的登录密码  
然后攻击者就可以在服务器上为所欲为(如果有权限的话)
这样, SSH 的安全机制就荡然无存  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是著名的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Man-in-the-middle_attack&quot;&gt;中间人攻击&lt;/a&gt;(Man-in-the-middle attack)&lt;/p&gt;

&lt;p&gt;所以，基于密码的安全认证是无法避免中间人攻击&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;公钥加密技术&lt;/h2&gt;

&lt;p&gt;公钥加密技术提供两个密钥 : 公钥(id_rsa.pub) 和 私钥(id_rsa)&lt;/p&gt;

&lt;p&gt;公钥加密技术主要是利用公钥和私钥的互相加密和解密的非对成性 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;公钥加密的文件，只能被私钥解密&lt;/li&gt;
  &lt;li&gt;私钥加密的文件，只能被公钥解密&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;普通的加密技术的加密运算和解密运算使用同样的密钥, 被称作对称密码学&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html&quot;&gt;数字签名是什么&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;一些思考&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;为什么要修改 ssh 服务的默认端口 22 ?&lt;br /&gt;
默认情况下, ssh 服务的端口为 22, 所以那些骇客们都会先从 22 端口入手, 通过 “暴力手段” 获取登录密码&lt;br /&gt;
所以, 建议修改 ssh 服务默认端口, 这样能一定程度上过滤掉一些不怀好意的访客&lt;br /&gt;
(虽然说对有心者并没什么鸟用,但是多做点防护总没坏处)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;ssh-copy-id&lt;/code&gt; 到底做了什么?&lt;br /&gt;
事实上, ssh-copy-id 做了下面脚本做的事 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ ssh ifmicro@remote-host &#39;mkdir -p .ssh &amp;amp;&amp;amp; cat &amp;gt;&amp;gt; .ssh/authorized_keys &amp;amp;&amp;amp; chmod 600 .ssh/authorized_keys&#39; &amp;lt; ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-11&quot;&gt;一些相关的文件&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;id_rsa&lt;/code&gt;(私钥) 和 &lt;code&gt;id_rsa.pub&lt;/code&gt;(公钥)
    &lt;ul&gt;
      &lt;li&gt;默认情况下, 位于 &lt;code&gt;~/.ssh/id_rsa&lt;/code&gt;、&lt;code&gt;~/.ssh/id_rsa.pub&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;这是使用 &lt;code&gt;ssh-keygen&lt;/code&gt; 指定 &lt;code&gt;-t rsa&lt;/code&gt; 默认生成的私钥和公钥, 可以在过程中指定生成的文件名&lt;/li&gt;
      &lt;li&gt;默认情况下, ssh 只会读取 &lt;code&gt;~/.sss/id_rsa&lt;/code&gt; 去加密&lt;br /&gt;
如果使用非默认的私钥, 那么需要在 &lt;code&gt;ssh -i private-key&lt;/code&gt; 或者使用 &lt;code&gt;ssh-agent&lt;/code&gt; 去管理&lt;/li&gt;
      &lt;li&gt;要保持当前文件权限为 &lt;code&gt;600&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;authorized_keys&lt;/code&gt; – 存储来自客户端的公钥
    &lt;ul&gt;
      &lt;li&gt;默认情况下, 位于 &lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;把来自客户端的公钥添加到这个文件中，就可以实现无密码登录&lt;/li&gt;
      &lt;li&gt;要保持当前文件权限为 &lt;code&gt;600&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-12&quot;&gt;待补充&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;ssh-agent 和 ssh 之间的关系&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ssh 端口转发&lt;br /&gt;
&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html&quot;&gt;SSH原理与运用（二）：远程操作与端口转发&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://wiki.archlinux.org/index.php/Secure_Shell_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)&quot;&gt;Arch Linux&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://help.github.com/articles/generating-ssh-keys/&quot;&gt;Generating SSH keys&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;s. &lt;a href=&quot;http://www.ibm.com/developerworks/cn/aix/library/1006_lisali_sshlogon/#major6&quot;&gt;开发自动化脚本&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:fingerprint&quot;&gt;
      &lt;p&gt;对 RSA 公钥进行 MD5 计算生成的一个 128 位的指纹 &lt;a href=&quot;#fnref:fingerprint&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://mwumli.github.io/ssh-login-server</link>
                <guid>http://mwumli.github.io/ssh-login-server</guid>
                <pubDate>2015-09-21T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>用 gitbook 来写书</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#gitbook-&quot; id=&quot;markdown-toc-gitbook-&quot;&gt;GitBook 是什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gitbook--1&quot; id=&quot;markdown-toc-gitbook--1&quot;&gt;GitBook 能做些什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ubuntu--gitbook-&quot; id=&quot;markdown-toc-ubuntu--gitbook-&quot;&gt;Ubuntu 下 gitbook 的安装&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gitbook--2&quot; id=&quot;markdown-toc-gitbook--2&quot;&gt;用 gitbook 来写书&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gitbook--3&quot; id=&quot;markdown-toc-gitbook--3&quot;&gt;gitbook 的命令小结&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;构建和运行&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#pdfepubmobi&quot; id=&quot;markdown-toc-pdfepubmobi&quot;&gt;生成电子书(PDF、ePub和Mobi)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;指定一个版本&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;管理版本&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#css&quot; id=&quot;markdown-toc-css&quot;&gt;自定义书本的 css&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;用插件来丰富你的书&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;发现插件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;安装插件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;一些插件&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#disqus-----disqushttppluginsgitbookcomplugindisqus&quot; id=&quot;markdown-toc-disqus-----disqushttppluginsgitbookcomplugindisqus&quot;&gt;disqus 评论系统 – &lt;a href=&quot;http://plugins.gitbook.com/plugin/disqus&quot;&gt;disqus&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#autocoverhttppluginsgitbookcompluginautocover&quot; id=&quot;markdown-toc-autocoverhttppluginsgitbookcompluginautocover&quot;&gt;自动化封面 – &lt;a href=&quot;http://plugins.gitbook.com/plugin/autocover&quot;&gt;autocover&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gitbook--4&quot; id=&quot;markdown-toc-gitbook--4&quot;&gt;GitBook 相关链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gitbook-&quot;&gt;GitBook 是什么&lt;/h2&gt;

&lt;p&gt;GitBook 是一个可以用来构建一本漂亮的电子书的命令行工具&lt;sup id=&quot;fnref:gitbook-online&quot;&gt;&lt;a href=&quot;#fn:gitbook-online&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; , 基于 Node.js&lt;/p&gt;

&lt;p&gt;可以使用 Markdown 文法来写作&lt;/p&gt;

&lt;p&gt;只要你部署好一定的目录结构并且完成书的内容，就能通过命令很方便地转化成网页和其它格式的电子书&lt;/p&gt;

&lt;p&gt;所以，用起来很简单&lt;/p&gt;

&lt;h2 id=&quot;gitbook--1&quot;&gt;GitBook 能做些什么&lt;/h2&gt;

&lt;p&gt;写一本书，听起来有点太高级，但是往往却是如此现实&lt;br /&gt;
因此，你可以用 GitBook 来写一本属于你自己的书&lt;/p&gt;

&lt;p&gt;至于书的内容，就由你自己来定:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以是你幻想已久的一个世界&lt;/li&gt;
  &lt;li&gt;可以是平时生活中的小常识&lt;/li&gt;
  &lt;li&gt;可以是一本菜谱&lt;/li&gt;
  &lt;li&gt;可以是你整理知识的小册子&lt;/li&gt;
  &lt;li&gt;可以是…&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ubuntu--gitbook-&quot;&gt;Ubuntu 下 gitbook 的安装&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装 nodejs并建立软链接&lt;sup id=&quot;fnref:nodejs&quot;&gt;&lt;a href=&quot;#fn:nodejs&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo apt-get install nodejs -y &amp;amp;&amp;amp; sudo ln -s `which nodejs` /usr/bin/node
&lt;/code&gt;&lt;/pre&gt;

  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装 NPM&lt;sup id=&quot;fnref:npm&quot;&gt;&lt;a href=&quot;#fn:npm&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo apt-get install npm
&lt;/code&gt;&lt;/pre&gt;

  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装 gitbook(全局)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo npm install gitbook-cli -g
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;gitbook--2&quot;&gt;用 gitbook 来写书&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;新建一个项目，命名为 learn-gitbook, 并初始化&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ mkdir learn-gitbook &amp;amp;&amp;amp; cd learn-gitbook
 learn-gitbook $ gitbook init 
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;learn-gitbook 下会生成两个文件 README.md 和 SUMMARY.md&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;构建并运行服务器&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ gitbook serve ./learn-gitbook  --port 4001
 ...
 Starting server ...
 Serving book on http://localhost:4001
 ...
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在浏览器中访问 &lt;code&gt;http://localhost:4001&lt;/code&gt;, 就可以看到一个没有内容的书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改书籍名称&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; learn-gitbook $ echo &quot;#learn gitbook&quot; &amp;gt; README.md
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在浏览器中查看浏览器标签页显示内容的变化&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改书籍介绍的内容&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; learn-gitbook $ echo &quot;GitBook is a command line tool (and Node.js library) for building beautiful books using GitHub/Git and Markdown (or AsciiDoc).&quot; &amp;gt;&amp;gt; README.md
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在浏览器中查看 Introduction 页面的变化&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增加几个章节(Markdown 的列表和链接语法)&lt;br /&gt;
在 SUMMARY.md 中增加以下内容 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; * [Part I](part1/README.md)
   * [Writing is nice](part1/writing.md)
   * [GitBook is nice](part1/gitbook.md)
 * [Part II](part2/README.md)
   * [We love feedback](part2/feedback_please.md)
   * [Better tools for authors](part2/better_tools.md)
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;重建项目页面和目录 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;learn-gitbook  $ gitbook init		
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在浏览器中查看左边侧边栏的变化：发现有了几个新的章节&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为每个页面增加内容&lt;/p&gt;

    &lt;p&gt;你只要在相应的页面用 Markdown 文法写作&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增加术语页面(GLOSSARY.md)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; learn-gitbook $ touch GLOSSARY.md &amp;amp;&amp;amp; vim GLOSSARY.md		
 # 术语
 这个术语的定义

 # 另外一个术语
 它的定义可以包含粗体和其他所有类型的内嵌式标记...
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;浏览器中你会发现 : 书中有 &lt;code&gt;术语&lt;/code&gt;、&lt;code&gt;另外一个术语&lt;/code&gt; 字样的都被高亮，而且可以点击看到它的解释&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 book.json 中指定 gitbook 版本&lt;br /&gt;
列出已经安装的版本&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; learn-gitbook $ gitbook versions				
 Versions Installed:

      2.2.0
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;新建 book.json,并指定版本 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; learn-gitbook $ touch book.json &amp;amp;&amp;amp; vim book.json
 {
     &quot;gitbook&quot; : &quot;2.2.0&quot;
 }
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;避免运行 gitbook 时输出警告 : &lt;code&gt;warn: you should specify a gitbook version to use in your book.json, for example: 2.x.x&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定书籍所用语言风格&lt;br /&gt;
修改 book.json 内容为 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; {
     &quot;gitbook&quot; : &quot;2.2.0&quot;,
     &quot;language&quot; : &quot;cn&quot;
 }
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在浏览器中可以看到侧边栏的 &lt;code&gt;Introduction&lt;/code&gt; 变为 &lt;code&gt;介绍&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为侧边栏顶部增加链接&lt;br /&gt;
   修改 book.json 内容为 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;{
    &quot;gitbook&quot; : &quot;2.2.0&quot;,
    &quot;language&quot; : &quot;cn&quot;,
    &quot;links&quot; : {
        &quot;sidebar&quot; : {
            &quot;倘若微小&quot; : &quot;http://www.ifmicro.com/&quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在浏览器中可以看到侧边栏顶部增加一个链接，名为 &lt;a href=&quot;http://www.ifmicro.com/&quot;&gt;倘若微小&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后，尽情写下你奇妙的想法，分享给大家吧&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;通过网站分享：把 learn-gitbook/_book 的内容放到一个云服务器上&lt;/li&gt;
  &lt;li&gt;发布电子书到云盘: 生成 pdf、epub、mobi电子书，放到云盘进行分享&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gitbook--3&quot;&gt;gitbook 的命令小结&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;构建和运行&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;初始化项目目录:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ gitbook init
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;会自动生成 SUMMARY.md 中指定的页面目录和页面&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成网站&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ gitbook build book_path output_path
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;构建网页并运行一个小型服务器&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ gitbook serve --port 4001  
 ...
 Serving book on http://localhost:4001
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在浏览器上，访问 http://localhost:4001 , 就可以看到你的书&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;pdfepubmobi&quot;&gt;生成电子书(PDF、ePub和Mobi)&lt;/h3&gt;

&lt;p&gt;第一步 : &lt;a href=&quot;http://www.calibre-ebook.com/download&quot;&gt;安装 calibre&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;第二步 : 执行对应命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ gitbook pdf  book_path  output_path/book_name.pdf
	$ gitbook epub book_path  output_path/book_name.epub
	$ gitbook mobi book_path  output_path/book_name.mobi
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;指定一个版本&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	$ gitbook build book_path --gitbook=2.3.0
	$ gitbook help --gitbook=2.3.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;管理版本&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;查看 gitbook 使用&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ gitbook -h
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看可以获得的所有 GitBook 版本:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ gitbook versions:available  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装最新的 GitBook 版本&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo gitbook versions:install latest
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;css&quot;&gt;自定义书本的 css&lt;/h2&gt;

&lt;p&gt;一般在生成站点时，会有默认的 css (_book/gitbook/style.css)&lt;/p&gt;

&lt;p&gt;你也可以自定义 css，使你的书籍更好看&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;建立 css 文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; learn-gitbook $ mkdir -p assets/css &amp;amp;&amp;amp; cd assets/css &amp;amp;&amp;amp; touch myWebStyle.css myPdfStyle.css myMobiStyle.css myEpubStyle.css
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在 myStyle.css 写下你的样式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 book.json 中添加&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; {
     &quot;styles&quot; : {
         &quot;website&quot; : &quot;assets/css/myWebStyle.css&quot;,
         &quot;pdf&quot; : &quot;assets/css/myPdfStyle.css&quot;,
         &quot;mobi&quot; : &quot;assets/css/myMobiStyle.css&quot;,
         &quot;epub&quot; : &quot;assets/css/myEpubStyle.css&quot;
     }
 }
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;我分别为 site, pdf, mobi, epub 指定了 css, 那么分别生成它们的时候，会在默认的 css 基础上层叠指定的 css&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;用插件来丰富你的书&lt;/h2&gt;

&lt;p&gt;gitbook 文档推荐插件(主题也是插件的一种)的命名方式:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;gitbook-plugin-X&lt;/li&gt;
  &lt;li&gt;gitbook-theme-X&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;发现插件&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/search?q=gitbook-plugin&quot;&gt;NPM-Search-gitbook-plugin&lt;/a&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; https://www.npmjs.com/search?q=gitbook-plugin
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/search?q=gitbook-theme&quot;&gt;NPM-Search-gitbook-theme&lt;/a&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; https://www.npmjs.com/search?q=gitbook-theme
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://plugins.gitbook.com/&quot;&gt;gitbook 插件官方地址&lt;/a&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; http://plugins.gitbook.com/
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-5&quot;&gt;安装插件&lt;/h3&gt;

&lt;p&gt;一旦你发现你需要的插件，在 book.json 添加:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;plugins&quot;: [&quot;myPlugin&quot;, &quot;anotherPlugin&quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于 gitbook-plugin-X 的插件，请这样安装 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;book-dir $ gitbook install  或者 npm install gitbook-plugin-X
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于 gitbook-theme-X 的插件，请这样安装 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;book-dir $ npm install gitbook-theme-X &amp;amp;&amp;amp; mv node_modules/gitbook-theme-X node_modules/gitbook-plugin-X`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;PS : 具体插件请参照具体插件的文档&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;一些插件&lt;/h3&gt;

&lt;h4 id=&quot;disqus-----disqushttppluginsgitbookcomplugindisqus&quot;&gt;disqus 评论系统 – &lt;a href=&quot;http://plugins.gitbook.com/plugin/disqus&quot;&gt;disqus&lt;/a&gt;&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装 gitbook-plugin-disqus&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo npm install gitbook-plugin-disqus -g
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 book.json 中添加 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; {
     &quot;plugins&quot;: [&quot;disqus&quot;],
     &quot;pluginsConfig&quot;: {
         &quot;disqus&quot;: {
                 &quot;shortName&quot;: &quot;XXXXXXX&quot;
             }
         }  
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;shortName&lt;/code&gt; 是你在 &lt;a href=&quot;https://disqus.com/&quot;&gt;disqus.com&lt;/a&gt; 上创建 website 指定的 shortname&lt;/p&gt;

&lt;h4 id=&quot;autocoverhttppluginsgitbookcompluginautocover&quot;&gt;自动化封面 – &lt;a href=&quot;http://plugins.gitbook.com/plugin/autocover&quot;&gt;autocover&lt;/a&gt;&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;安装 &lt;a href=&quot;https://github.com/Automattic/node-canvas/wiki/_pages&quot;&gt;node-canvas&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装 gitbook-plugin-autocover&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo npm install gitbook-plugin-autocover
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 book.json 中添加 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; {
     &quot;plugins&quot;: [&quot;autocover&quot;],
     &quot;pluginsConfig&quot;: {
         &quot;autocover&quot;: {
             &quot;title&quot;: &quot;My Book&quot;,
             &quot;author&quot;: &quot;Author&quot;,
             &quot;font&quot;: {
                 &quot;size&quot;: null,
                 &quot;family&quot;: &quot;Impact&quot;,
                 &quot;color&quot;: &quot;#FFF&quot;
             },
             &quot;size&quot;: {
                 &quot;w&quot;: 1800,
                 &quot;h&quot;: 2360
             },
             &quot;background&quot;: {
                 &quot;color&quot;: &quot;#09F&quot;
             }
         }
     }
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;gitbook--4&quot;&gt;GitBook 相关链接&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;GitBook 官方文档 : &lt;a href=&quot;https://www.gitbook.com/book/gitbookio/documentation/details&quot;&gt;https://www.gitbook.com/book/gitbookio/documentation/details&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GitBook 项目目录 : &lt;a href=&quot;https://github.com/GitbookIO/gitbook&quot;&gt;https://github.com/GitbookIO/gitbook&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gitbook-cli 项目目录 : &lt;a href=&quot;https://github.com/GitbookIO/gitbook-cli&quot;&gt;https://github.com/GitbookIO/gitbook-cli&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GitBook API Documentation : &lt;a href=&quot;http://developer.gitbook.com/&quot;&gt;http://developer.gitbook.com/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GitBook Enterprise Guide : &lt;a href=&quot;https://www.gitbook.com/book/gitbookio/enterprise-guide/details&quot;&gt;https://www.gitbook.com/book/gitbookio/enterprise-guide/details&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:gitbook-online&quot;&gt;
      &lt;p&gt;还有一个与之同名的在线创建和托管书籍的平台&lt;a href=&quot;https://www.gitbook.com/&quot;&gt;www.gitbook.com&lt;/a&gt; &lt;a href=&quot;#fnref:gitbook-online&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:nodejs&quot;&gt;
      &lt;p&gt;采用软链接解决ubuntu下 nodejs 命令名与 gitbook 内部使用 nodejs 命令名不一致&lt;br /&gt;具体看&lt;a href=&quot;http://stackoverflow.com/questions/18130164/nodejs-vs-node-on-ubuntu-12-04#answer-18130296&quot;&gt;nodejs vs node on ubuntu 12.04&lt;/a&gt; &lt;a href=&quot;#fnref:nodejs&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:npm&quot;&gt;
      &lt;p&gt;Node Package Manager , 一个 nodejs 包管理和分发工具 &lt;br /&gt;&lt;a href=&quot;https://github.com/npm/npm&quot;&gt;NPM Github项目地址&lt;/a&gt; &lt;a href=&quot;#fnref:npm&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
                <link>http://mwumli.github.io/gitbook</link>
                <guid>http://mwumli.github.io/gitbook</guid>
                <pubDate>2015-09-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>用 tmux 保存工作现场</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-&quot; id=&quot;markdown-toc-tmux-&quot;&gt;tmux 是什么?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux--1&quot; id=&quot;markdown-toc-tmux--1&quot;&gt;tmux 的任务会话机制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux&quot; id=&quot;markdown-toc-tmux&quot;&gt;安装 tmux&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-session&quot; id=&quot;markdown-toc-tmux-session&quot;&gt;tmux session&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-window&quot; id=&quot;markdown-toc-tmux-window&quot;&gt;tmux window&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#window&quot; id=&quot;markdown-toc-window&quot;&gt;创建 window&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#window-1&quot; id=&quot;markdown-toc-window-1&quot;&gt;切换 window&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;重命名当前窗口&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-pane&quot; id=&quot;markdown-toc-tmux-pane&quot;&gt;tmux pane&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux--2&quot; id=&quot;markdown-toc-tmux--2&quot;&gt;tmux 的复制&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#copy--&quot; id=&quot;markdown-toc-copy--&quot;&gt;Copy 模式下的复制, 然后粘贴&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;复制&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;粘贴&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#copy-&quot; id=&quot;markdown-toc-copy-&quot;&gt;推荐使用 Copy 模式&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux--3&quot; id=&quot;markdown-toc-tmux--3&quot;&gt;tmux 的配置文件&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;配置文件生效&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux--4&quot; id=&quot;markdown-toc-tmux--4&quot;&gt;一个简单的 tmux 配置文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;自动生成布局&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux--5&quot; id=&quot;markdown-toc-tmux--5&quot;&gt;tmux 在远程服务器中的表现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;结对编程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux--6&quot; id=&quot;markdown-toc-tmux--6&quot;&gt;tmux 小技巧&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux--command-prompt&quot; id=&quot;markdown-toc-tmux--command-prompt&quot;&gt;tmux 的 command-prompt&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux--7&quot; id=&quot;markdown-toc-tmux--7&quot;&gt;tmux 快捷键帮助&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#send-prefix&quot; id=&quot;markdown-toc-send-prefix&quot;&gt;重新绑定 send-prefix&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux--8&quot; id=&quot;markdown-toc-tmux--8&quot;&gt;tmux 底部状态栏&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;显示钟表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#pane----&quot; id=&quot;markdown-toc-pane----&quot;&gt;为 pane 显示编号—快速切换&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-1&quot; id=&quot;markdown-toc-tmux-1&quot;&gt;使用tmux的一些问题&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux--vimpowerline&quot; id=&quot;markdown-toc-tmux--vimpowerline&quot;&gt;tmux 和 vim的powerline插件&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;一些自言自语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tmux-&quot;&gt;tmux 是什么?&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;tmux&lt;/code&gt; 是一款非常好用的终端复用器&lt;/p&gt;

&lt;p&gt;可以认为是终端分屏软件，但远远不止…&lt;br /&gt;
可以认为是 &lt;code&gt;nohup&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 的结合体，但远远不止…&lt;br /&gt;
可以认为是一款结对编程 ( Pair Programming ) 的软件，但远远不止…&lt;/p&gt;

&lt;p&gt;是的，远远不止…&lt;/p&gt;

&lt;p&gt;不知道怎么去描述，且跟随使用去体会吧&lt;/p&gt;

&lt;h2 id=&quot;tmux--1&quot;&gt;tmux 的任务会话机制&lt;/h2&gt;

&lt;p&gt;当你运行 &lt;code&gt;tmux&lt;/code&gt; 之后，会启动一个 tmux server 来管理 tmux 的 sessions&lt;/p&gt;

&lt;p&gt;tmux server 有且仅有一个，并且在第一个 session 创建时启动， 当最后一个 session 销毁时销毁&lt;/p&gt;

&lt;p&gt;然后有以下几条规则:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个 tmux server 可以有多个 sessions&lt;/li&gt;
  &lt;li&gt;一个 session 可以有多个 window ， 类似终端有多个标签页&lt;/li&gt;
  &lt;li&gt;一个 window 可以有多个 pane, 即分屏&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;session&lt;/code&gt; 可译作 &lt;code&gt;会话&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;window&lt;/code&gt; 可译作 &lt;code&gt;窗口&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;pane&lt;/code&gt; 可译作 &lt;code&gt;窗格&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;tmux&quot;&gt;安装 tmux&lt;/h2&gt;

&lt;p&gt;Ubuntu下安装:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install tmux
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;tmux-session&quot;&gt;tmux session&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;快速创建:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;这样创建的 session 被自动用数字命名&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个命名的 session :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux new-session -s session-name
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看当前所有的 sessions :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux list-sessions
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;脱离当前 session : &lt;code&gt;ctrl-b + d&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;脱离当前 session , 你的工作状态依然保留&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果想重新进入之前的 session , 只需:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux attach-session -t session-name
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;这样你又回看到你之前的工作进度了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当你想退出当前 session :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 在终端中输入 `exit`, 直到所有的 window 和 pane 被关闭  
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;这时，你的 session 也被销毁了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;杀死指定的 session :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux kill-session -t session-name
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重命名 session : &lt;code&gt;ctrl-b + $&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;杀死所有的 session :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux kill-server
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;因为所有的 sessions 跑在一个 server 上&lt;br /&gt;
所以只要关掉 tmux server 即可&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;tmux-window&quot;&gt;tmux window&lt;/h2&gt;

&lt;h3 id=&quot;window&quot;&gt;创建 window&lt;/h3&gt;

&lt;p&gt;当你创建一个 session 时，也自动创建一个 window , window 中也会自动创建一个 pane&lt;/p&gt;

&lt;p&gt;在 session 中创建 window :  按下&lt;code&gt;ctrl-b +c&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;window-1&quot;&gt;切换 window&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;切换到下一个窗口 : &lt;code&gt;ctrl-b + n&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切换到上一个窗口 : &lt;code&gt;ctrl-b + p&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切换到num窗口，num为窗口编号，底部状态栏可看到 : &lt;code&gt;ctrl-b + num&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示当前会话的所有窗口 : &lt;code&gt;ctrl-b + w&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭当前窗口 : &lt;code&gt;ctrl-b + &amp;amp;&lt;/code&gt; 或者 &lt;code&gt;exit&lt;/code&gt; 或者 &lt;code&gt;ctrl + d&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section&quot;&gt;重命名当前窗口&lt;/h3&gt;

&lt;p&gt;按下 &lt;code&gt;ctrl-b + ,&lt;/code&gt;&lt;br /&gt;
然后输入 window-name 即可&lt;/p&gt;

&lt;h2 id=&quot;tmux-pane&quot;&gt;tmux pane&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;分割一个垂直的窗格 : &lt;code&gt;ctrl-b + &quot;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分割一个水平的窗格 : &lt;code&gt;ctrl-b + %&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;移动到其他窗格 : &lt;code&gt;ctrl-b + Arrow-Up/Down/Left/Right&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭所有窗格 : &lt;code&gt;ctrl-b + !&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tmux--2&quot;&gt;tmux 的复制&lt;/h2&gt;

&lt;p&gt;在没有启动鼠标滚轮时， tmux 可以通过鼠标选中，并复制&lt;/p&gt;

&lt;p&gt;当你用了上面配置文件中的鼠标滚轮启用，那么一般的鼠标选中就不可能了:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;按下 shift, 然后使用鼠标去选中想要copy的内容进行复制操作  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;copy--&quot;&gt;Copy 模式下的复制, 然后粘贴&lt;/h3&gt;

&lt;p&gt;tmux 提供了一种 copy 模式,类似于 vim 的(Esc-v)模式&lt;/p&gt;

&lt;p&gt;按下 &lt;code&gt;ctrl-b + [&lt;/code&gt; 进入 copy 模式&lt;/p&gt;

&lt;p&gt;tmux 的 copy 模式下有两种快捷键模式: vim 和 Emacs&lt;br /&gt;
当你在配置文件中启用 vim 模式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setw -g mode-keys vi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 copy 模式下， 我们就可以使用 &lt;code&gt;j/k/h/l&lt;/code&gt; 来移动光标了&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;复制&lt;/h4&gt;

&lt;p&gt;在 Copy 模式下，我们这样复制:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;移动光标到复制开始位置&lt;/li&gt;
  &lt;li&gt;按下 &lt;code&gt;Space&lt;/code&gt; 键进入复制模式&lt;/li&gt;
  &lt;li&gt;移动光标选择要复制的内容&lt;/li&gt;
  &lt;li&gt;按下 &lt;code&gt;Enter&lt;/code&gt; 键完成复制&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-2&quot;&gt;粘贴&lt;/h4&gt;

&lt;p&gt;到你要粘贴内容的位置， 使用快捷键 &lt;code&gt;ctrl-b + ]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;刚才复制的内容已经被完美粘贴了&lt;/p&gt;

&lt;h3 id=&quot;copy-&quot;&gt;推荐使用 Copy 模式&lt;/h3&gt;

&lt;p&gt;如果你只是想复制不超过一行文字，那么这两种方式均可，甚至第一种方式更有效率&lt;/p&gt;

&lt;p&gt;如果你想复制多行文本，那么还是使用Copy 模式&lt;/p&gt;

&lt;p&gt;这和 tmux 的实现方式有关,具体请自行探讨&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tmux--3&quot;&gt;tmux 的配置文件&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;配置文件生效&lt;/h3&gt;

&lt;p&gt;配置文件生效有两种方式:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;新建一个 session, &lt;code&gt;.tmux.conf&lt;/code&gt; 中的设置就在此 session 中生效了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在当前 session 中，按下 &lt;code&gt;ctrl-b + :&lt;/code&gt;,然后:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; : source-file ~/.tmux.conf
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;code&gt;.tmux.conf&lt;/code&gt;是 tmux 配置文件的命名，默认位于你的用户主目录下&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;tmux--4&quot;&gt;一个简单的 tmux 配置文件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# This is a tmux configure file
# 取消默认Ctrl+b的前缀绑定，绑定Ctrl+a为新的快捷发送前缀方式
unbind C-o
set -g prefix C-a

# Copy模式下使用vim快捷操作方式
setw -g mode-keys vi

# split window with s/v after C-a
bind s split-window -h
bind v split-window -v

# move into left/Down/Up/Right panes with h/j/k/l after C-a
bind h select-pane -L
bind j select-pane -D
bind k select-pane -U
bind l select-pane -R

# resize panes forward left/right/Down/Up with &amp;lt;/&amp;gt;/-/+ after C-a
bind &amp;lt; resize-pane -L 10
bind &amp;gt; resize-pane -R 10
bind - resize-pane -D 10
bind + resize-pane -U 10

# bind : to command-prompt like vim
# this is the defalut in tmux already
bind : command-prompt

#鼠标可以选中窗格
set-option -g mouse-select-pane on  
#鼠标滚轮可以使用
set-window-option -g mode-mouse on  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;自动生成布局&lt;/h3&gt;

&lt;p&gt;新建一个文件 &lt;code&gt;~/.tmux/mylayout&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;selectp -t 0 #选中第0个窗格
splitw -h -p 50 #将其分成左右两个
selectp -t 1 #选中第一个，也就是右边那个
splitw -v -p 50 #将右边那个分成上下两个
selectp -t 0 #选中第一个
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在 &lt;code&gt;.tmux.conf&lt;/code&gt;	后面添加:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind D source-file ~/.tmux/mylayout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，每次当我们启动 tmux 后， 可以使用 &lt;code&gt;ctrl-b + D&lt;/code&gt; 来生成布局&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tmux--5&quot;&gt;tmux 在远程服务器中的表现&lt;/h2&gt;

&lt;p&gt;如果通过 &lt;code&gt;ssh&lt;/code&gt; 远程登录到服务器，恰好要进行一个很耗时的任务&lt;/p&gt;

&lt;p&gt;我们不可能等待这个任务执行完毕，再去做其他工作&lt;/p&gt;

&lt;p&gt;因此，我们选择了启用一个新的终端来完成其他工作&lt;/p&gt;

&lt;p&gt;但是网络可能很不稳定，你那个耗时任务在执行过程，突然网络掉线，然后，你的 ssh 断掉，然后你的任务挂掉了&lt;/p&gt;

&lt;p&gt;但是我们的任务已经进行了80%，功亏一篑&lt;/p&gt;

&lt;p&gt;是的，你可以选择执行任务时，采用 &lt;code&gt;nohup&lt;/code&gt; ，那样，网络断掉，也不会影响你的任务&lt;/p&gt;

&lt;p&gt;但是你永远也回不到 &lt;em&gt;案发现场&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;案发现场&lt;/em&gt; 在某些情况下很重要&lt;/p&gt;

&lt;p&gt;而且费那么多心思在保证任务完成，现场保留上，实在太浪费了&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;tmux&lt;/code&gt; 完全可以解决这个问题，除非远程服务器挂了&lt;/p&gt;

&lt;p&gt;因此，远程工作的正确方式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh pi@192.168.199.114 
...
Last login: Tue May  5 02:37:14 2015 from 192.168.199.104
pi@raspberrypi ~ $ tmux new-session -s code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，你可在 session 中进行分屏来完成其他工作&lt;br /&gt;
或者你可以脱离终端， 继续其他操作&lt;br /&gt;
再或者网络中断，当你重新连接上服务器:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
Last login: Tue May  5 02:37:14 2015 from 192.168.199.104
pi@raspberrypi ~ $ tmux a -t code
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你会发现，哦，我的工作现场依旧完整无缺…&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;结对编程&lt;/h2&gt;

&lt;p&gt;关于结对编程的概念，可以查看维基百科:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://zh.wikipedia.org/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tmux 利用服务器上的同一账户的同一 tmux session 实现的&lt;/p&gt;

&lt;p&gt;两个人打开同一个 tmux session, 一个人所做的改变，会即时的反映到另一个人的终端上&lt;/p&gt;

&lt;p&gt;tmux 基于文本， 所以即使网速慢点也无妨&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tmux--6&quot;&gt;tmux 小技巧&lt;/h2&gt;

&lt;h3 id=&quot;tmux--command-prompt&quot;&gt;tmux 的 command-prompt&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;command-prompt&lt;/code&gt; 是用来输入 tmux 命令的&lt;/p&gt;

&lt;p&gt;tmux 的所有快捷键的功能都是通过命令来实现的&lt;/p&gt;

&lt;p&gt;因此，我们也通过键入命令来实现某种功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;按下 ctrl-b + : 即可打开 command-prompt  
然后，你输入相应命令即可  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;tmux--7&quot;&gt;tmux 快捷键帮助&lt;/h3&gt;

&lt;p&gt;tmux 的快捷键由 send-prefix 和 bind-key 组成&lt;/p&gt;

&lt;p&gt;按下 send-prefix 的同时，按下 bind-key 才唤醒相应的快捷功能&lt;/p&gt;

&lt;p&gt;&lt;code&gt;send-prefix&lt;/code&gt; 是固定的，默认是 &lt;code&gt;ctrl-b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bind-key&lt;/code&gt; 对应不同的功能绑定了不同的 key, 可以通过以下方式查看:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;按下 `ctrl-b + ?`  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;send-prefix&quot;&gt;重新绑定 send-prefix&lt;/h3&gt;

&lt;p&gt;更换 send-prefix 为 &lt;code&gt;ctrl-a&lt;/code&gt; ,在 tmux 的配置文件(&lt;code&gt;.tmux.conf&lt;/code&gt;)中这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unbind C-b
set -g prefix C-a
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;tmux--8&quot;&gt;tmux 底部状态栏&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;tmux 窗口底部就是状态栏&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;状态栏左边显示 session-name ,并且列出当前所有 window-name ,以及所有 window 当前运行的 process-name&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当前所在 window 旁边会有 &lt;code&gt;*&lt;/code&gt; 提示&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;右边会显示主机名和时间&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;显示钟表&lt;/h3&gt;

&lt;p&gt;按下 &lt;code&gt;ctrl-b + t&lt;/code&gt;, 会在当前 window 的当前 pane 显示当前时间&lt;/p&gt;

&lt;h3 id=&quot;pane----&quot;&gt;为 pane 显示编号—快速切换&lt;/h3&gt;

&lt;p&gt;按下 &lt;code&gt;ctrl-b + q&lt;/code&gt;, 每一个 pane 都会出现一个数字&lt;br /&gt;
按下想要切换的 pane 显示的数字， 就可以切换到那个 pane&lt;/p&gt;

&lt;h2 id=&quot;tmux-1&quot;&gt;使用tmux的一些问题&lt;/h2&gt;

&lt;h3 id=&quot;tmux--vimpowerline&quot;&gt;tmux 和 vim的powerline插件&lt;/h3&gt;

&lt;p&gt;默认情况下，启动vim, 如果使用了 powerline 插件， 那么会发现颜色显示不正常&lt;/p&gt;

&lt;p&gt;此时，只要你在每次打开 tmux 时启动256色即可，即 &lt;code&gt;tmux -2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们可以在 &lt;code&gt;.bashrc&lt;/code&gt; 末尾添加:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias tmux=&#39;tmux -2&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，每次使用 tmux 就会很方便啦&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-7&quot;&gt;一些自言自语&lt;/h2&gt;

&lt;p&gt;任何时候不要太过迷信一件东西&lt;/p&gt;

&lt;p&gt;你知道的, 服务器也会有重启的时候&lt;/p&gt;

&lt;p&gt;及时保存你的编辑，及时提交你的修改，及时备份你的收藏，永远是明智的做法&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/tmux</link>
                <guid>http://mwumli.github.io/tmux</guid>
                <pubDate>2015-05-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>离去</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;实习&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;前端的进步&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;离去&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;回家&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;离职咯，嘿嘿，不要误会，只是实习期结束了…&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;实习&lt;/h2&gt;

&lt;p&gt;实习这段时间，我的工作主要是前端方面的(喂，是不是搞错了，我面的是后台呀…)&lt;/p&gt;

&lt;p&gt;对于此，我郁闷好一会儿。&lt;br /&gt;
不过，未来的学习计划安排有前端，所以也就提前让它生长发芽吧&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;前端的进步&lt;/h3&gt;

&lt;p&gt;同事中有位大哥，前端很厉害，指导了我很多&lt;/p&gt;

&lt;p&gt;之前接触过一些前端 : 基础知识很简单( HTML/CSS/JS ),但是简单也意味着，在某些方面会比较麻烦，比如页面布局，比如网站框架设计&lt;/p&gt;

&lt;p&gt;前端学习阶梯:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;HTML/CSS/JS，基础知识，很必要&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JQuery 的使用 — 这是一门很流行的js框架，我想学习它，非常必要&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bootstrap 的使用 — 想要快速开发一个响应式网站，那么学习它&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;与后台数据交互和Ajax — 与后台进行数据交互，这是一个必备技能，使用Ajax，也是必备技能&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JS的原型链继承，很重要, 这对学习框架设计(如果你只想写些效果，按照已有的框架设计，那就…)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;看源码 — 研究一下比较流行的插件源码吧,仅仅看书学习,不仅枯燥，而且你的知识只会碎片化&lt;br /&gt;
 看源码,永远是最有效的学习方式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写插件 — 你已经学会原型链继承，也吸收了高手们开发插件的经验，那么开始写吧(有想法的时候)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;寻找机会 — 等待一个合适机会，从一个最基本的网站进行构建&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;快速编写 — less,sass,coffeescript …&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nodejs…&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;应该还有很多，目前就只了解到这里&lt;br /&gt;
以上这些，有些顺序可以提前，学习本无先后，有所需，就得学…
我也并没有完全掌握这些知识，但是要想成为一个真正的前端，这些步骤时必须的&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;离去&lt;/h2&gt;

&lt;p&gt;下雨了，没想到离去的时候，竟然会下雨&lt;/p&gt;

&lt;p&gt;长安也下雨了&lt;/p&gt;

&lt;p&gt;“青山一道同云雨，明月何曾是两乡”&lt;/p&gt;

&lt;p&gt;最后，再见，帝都…&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;回家&lt;/h2&gt;

&lt;p&gt;我要回来了&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/leave-beijing</link>
                <guid>http://mwumli.github.io/leave-beijing</guid>
                <pubDate>2015-05-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Linux下php扩展安装</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;碎碎念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#extensiondir--extension&quot; id=&quot;markdown-toc-extensiondir--extension&quot;&gt;extension_dir 和 extension&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#extensiondir-&quot; id=&quot;markdown-toc-extensiondir-&quot;&gt;extension_dir 实际生效值&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;检验扩展是否应用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#php&quot; id=&quot;markdown-toc-php&quot;&gt;安装并添加php扩展&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#phpize-&quot; id=&quot;markdown-toc-phpize-&quot;&gt;phpize 的安装&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;几个扩展常用扩展安装&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#mccrypt-&quot; id=&quot;markdown-toc-mccrypt-&quot;&gt;MCcrypt 扩展的安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#igbinary-&quot; id=&quot;markdown-toc-igbinary-&quot;&gt;igbinary 扩展的安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#redis-&quot; id=&quot;markdown-toc-redis-&quot;&gt;redis 扩展的安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#mongo-&quot; id=&quot;markdown-toc-mongo-&quot;&gt;mongo 扩展的安装&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;碎碎念&lt;/h2&gt;

&lt;p&gt;通过搭建 &lt;a href=&quot;/lamp-build&quot;&gt;LAMP 环境&lt;/a&gt;, 就可以使用 php 进行动态网站开发&lt;/p&gt;

&lt;p&gt;但有的时候增强 php 对某些特殊功能, 比如对 mongodb 的操纵, redis 的访问等&lt;/p&gt;

&lt;p&gt;这时候, 你就需要为 php 安装并配置相应扩展, 即 extension&lt;/p&gt;

&lt;h2 id=&quot;extensiondir--extension&quot;&gt;extension_dir 和 extension&lt;/h2&gt;

&lt;p&gt;php 有一个变量定义了 extension 在你的系统中的存放位置, 那就是 &lt;code&gt;extension_dir&lt;/code&gt;&lt;br /&gt;
只有 extension 存放到 &lt;code&gt;extension_dir&lt;/code&gt; 的指定路径, 那么 php 才能正确读取&lt;/p&gt;

&lt;p&gt;关于 &lt;code&gt;extension_dir&lt;/code&gt; :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;默认值 : &lt;code&gt;php -i | grep extension_dir&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重新指定&lt;br /&gt;
在  &lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt; 进行指定, 比如 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;extension_dir=&quot;/usr/share/php_extension&quot;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;extensiondir-&quot;&gt;extension_dir 实际生效值&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在你的 Apache 目录下新建文件 &lt;code&gt;phpinfo.php&lt;/code&gt;, 内容如下 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;?php
     phpinfo();
 ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;访问 &lt;code&gt;phpinfo.php&lt;/code&gt;, 搜索 &lt;code&gt;extension_dir&lt;/code&gt;, 可以看到当前 php 寻找 extension 的路径&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-1&quot;&gt;检验扩展是否应用&lt;/h3&gt;

&lt;p&gt;访问 &lt;code&gt;phpinfo.php&lt;/code&gt;，搜索你的扩展，比如 &lt;code&gt;redis&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果你的扩展放到 &lt;code&gt;extension_dir&lt;/code&gt; 并且已经添加到 php 的 apache 配置文件，那么就会搜索到&lt;br /&gt;
如果没有搜索到 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;查看 &lt;code&gt;extension_dir&lt;/code&gt; 下有没有你的 extension&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;确认是否在 &lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt; 中添加此 extension, 比如 redis :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [redis]
 extension=redis.so
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;重启服务器 : &lt;code&gt;sudo service apache2 restart&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;可以留言共同讨论或者谷歌&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;php&quot;&gt;安装并添加php扩展&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载并安装下载相应扩展(请自行搜索)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; http://php.net/manual/zh/extensions.php  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加扩展到配置文件&lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt;&lt;br /&gt;
 (以&lt;code&gt;redis&lt;/code&gt;为例)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [redis]
 extension=redis.so
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;添加文件末尾即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo service apache2 restart
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;phpize-&quot;&gt;phpize 的安装&lt;/h2&gt;

&lt;p&gt;用 C 开发的 PHP 扩展使用动态链接库的方式编译扩展模块，需要用到 &lt;code&gt;phpize&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个工具在使用 &lt;code&gt;apt-get install php5&lt;/code&gt; 默认情况也是没安装的&lt;/p&gt;

&lt;p&gt;执行以下命令去安装 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install php5-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;几个扩展常用扩展安装&lt;/h2&gt;

&lt;h3 id=&quot;mccrypt-&quot;&gt;MCcrypt 扩展的安装&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装 : &lt;code&gt;sudo apt-get install php5-mcrypt&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加配置 &lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt;:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [mcrypt]
 extension=mcrypt.so
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;igbinary-&quot;&gt;igbinary 扩展的安装&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装 : &lt;code&gt;sudo pecl install igbinary&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加配置 &lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt;:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;[igbinary]
extension=igbinary.so
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;redis-&quot;&gt;redis 扩展的安装&lt;/h3&gt;

&lt;p&gt;官方文档 : &lt;a href=&quot;https://github.com/phpredis/phpredis#installingconfiguring&quot;&gt;https://github.com/phpredis/phpredis#installingconfiguring&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载, 编辑, 安装 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ git clone https://github.com/phpredis/phpredis.git
 $ phpize
 $ ./configure [--enable-redis-igbinary]
 $ make &amp;amp;&amp;amp; sudo make install
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;这样 redis 就被安装在合适的位置&lt;br /&gt;
如果需要 &lt;code&gt;--enable-redis-igbinary&lt;/code&gt;, 请先进行 &lt;code&gt;igbinary 扩展的安装&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加扩展到配置文件&lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [redis]                            
 extension=redis.so
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;mongo-&quot;&gt;mongo 扩展的安装&lt;/h3&gt;

&lt;p&gt;官方文档: &lt;a href=&quot;http://php.net/manual/zh/mongo.installation.php&quot;&gt;http://php.net/manual/zh/mongo.installation.php&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载，编译，安装:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ git clone https://github.com/mongodb/mongo-php-driver-legacy.git
 $ cd mongo-php-driver-legacy
 $ phpize
 $ ./configure
 $ make all &amp;amp;&amp;amp; sudo make install
 ...
 Installing shared extensions:     
 /usr/lib/php5/20121212+lfs/
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加配置 &lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt;:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [mongo.so]
 extension=mongo.so
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://mwumli.github.io/php-extension-install</link>
                <guid>http://mwumli.github.io/php-extension-install</guid>
                <pubDate>2015-04-24T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Raspberry Pi安装Debian Wheezy系统</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;碎碎念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;系统安装&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;不同平台下的镜像写入&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;访问&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;和正常计算机一样访问&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ssh&quot; id=&quot;markdown-toc-ssh&quot;&gt;通过ssh远程访问&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;一些必要的小贴士&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vnc&quot; id=&quot;markdown-toc-vnc&quot;&gt;使用VNC远程图形化访问&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;配置&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;更换软件源&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;配置自动连接你的局域网&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#localhost&quot; id=&quot;markdown-toc-localhost&quot;&gt;使用localhost&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;后记&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;碎碎念&lt;/h3&gt;

&lt;p&gt;Raspberry Pi，是一款基于Linux系统的、信用卡大小的单板机电脑&lt;br /&gt;
它的出现源于一个想&lt;strong&gt;制作一套启发孩子的电脑&lt;/strong&gt;的想法&lt;br /&gt;
看来一切美好的事情背后总是有一颗让人心动的理念，而这个理念往往才是他们获得流行的动力&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/imgs/640px-RaspberryPi.jpg&quot; alt=&quot;树莓派B2.0简图&quot; title=&quot;树莓派B2.0简图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;系统安装&lt;/h3&gt;
&lt;p&gt;可以用于Raspberry Pi的系统很多，有我们即将安装的Debian Wheezy,还有Arch Linux ARM, RISC OS等等&lt;br /&gt;
对咯，Debian Wheezy更为常见的称呼是Raspbian,但是为了避免与Raspberry Pix形似，我特意称其为Debian Wheezy,也喜欢这样称呼(嘿嘿…)&lt;br /&gt;
这些资源都可以送网络上获取，感谢互联网&lt;/p&gt;

&lt;p&gt;为树莓派安装系统很简单，开始咯&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先从&lt;a href=&quot;http://www.raspberrypi.org/downloads/&quot; title=&quot;RaspberryPi OS下载页&quot;&gt;树莓派官网下载页&lt;/a&gt;选择下载Debian Wheezy系统(第一个应该就是),这是树莓派专用系统&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;因为Raspberry Pi是从SD卡启动的(&lt;strong&gt;没有BIOS和其他内部存储设备，只有一个SD卡槽&lt;/strong&gt;)，所以我们需要准备一张SD卡,8G大小(&lt;strong&gt;更大更好，不过it depends&lt;/strong&gt;),把SD卡使用卡托或者读卡器接入你的计算机&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-2&quot;&gt;不同平台下的镜像写入&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Windows
    &lt;ol&gt;
      &lt;li&gt;请下载官方推荐工具&lt;a href=&quot;http://sourceforge.net/projects/win32diskimager/&quot; title=&quot;一个Windows下把原始数据写入可移动设备的工具&quot;&gt;Win32 Disk Imager&lt;/a&gt;，它是一款绿色软件，点击即可使用&lt;/li&gt;
      &lt;li&gt;运行软件，选择我们SD卡盘符，加载我们的Debian Wheezy镜像(&lt;strong&gt;像2014-09-09-wheezy-raspbian.img&lt;/strong&gt;)，最后点击”Write”,等待几分钟写入完成&lt;/li&gt;
      &lt;li&gt;哦，对了，在写入镜像前，你也可以校验镜像的完整性，可以使用&lt;code&gt;fciv&lt;/code&gt;命令生成SHA1校验码与网上公布的码值对比，如果一样，okay，没问题。不过假如你从官网下载镜像与软件以及网络环境没问题，那么应该不会有太大问题问题(&lt;strong&gt;可忽略&lt;/strong&gt;)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Linux
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;校验镜像，使用sha1sum生成SHA1校验码&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; $ sha1sum 2014-09-09-wheezy-raspbian.img 
 57a73544fab3f1163a14903647e55c3998bf9dc9  2014-09-09-wheezy-raspbian.img  
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;查看你的SD卡的准确位置，并确定是否挂载分区&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; $ df -h
 Filesystem      Size  Used Avail Use% Mounted on
 /dev/sda1       103G   37G   61G  38% /
 none            4.0K     0  4.0K   0% /sys/fs/cgroup
 udev            2.0G   12K  2.0G   1% /dev
 tmpfs           393M  1.3M  392M   1% /run
 none            5.0M     0  5.0M   0% /run/lock
 none            2.0G   58M  1.9G   3% /run/shm
 none            100M   40K  100M   1% /run/user
 /dev/sde2       3.6G  1.2G  2.4G  30% /media/mwumli/12C-3244-2342
 /dev/sde1		4.2G	0G	0G	   0% /media/mwumli/43C-2334-4354
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如果挂载，请先卸载所有分区，以免发生错误&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; $ umount /dev/sde1
 $ umount /dev/sde2
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用&lt;code&gt;dd&lt;/code&gt;写入镜像&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; $ sudo dd bs=1M if=2014-09-09-wheezy-raspbian.img of=/dev/sde 
 [sudo] password for mwumli:
 3125+0 records in
 3125+0 records out
 3276800000 bytes (3.3 GB) copied, 406.802 s, 8.1 MB/s
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;访问&lt;/h3&gt;
&lt;p&gt;把写好的SD卡插入树莓派卡槽，连接上电源&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;和正常计算机一样访问&lt;/h4&gt;
&lt;p&gt;为树莓派配上显示器和键盘，鼠标，这样就和正常的计算机一样访问了 &lt;br /&gt;
但要注意的是USB接口在B2.0上只有两个，就算B+也只有4个&lt;br /&gt;
同时还要注意电压不足的问题，这个问题好解决，买一个可以接入外接电源的USB集线器&lt;/p&gt;

&lt;h4 id=&quot;ssh&quot;&gt;通过ssh远程访问&lt;/h4&gt;
&lt;p&gt;Debian Wheezy系统默认已经开启ssh服务，所以我们可以通过ssh进行远程访问，对于很多操作，那已足够&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh pi@192.168.199.244
pi@192.168.199.244&#39;s password: 
Linux raspberrypi 3.12.28+ #709 PREEMPT Mon Sep 8 15:28:00 BST 2014 armv6l

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Sat Dec  6 23:08:25 2014 from mwumli-k43sa.lan
pi@raspberrypi ~ $ whoami
pi
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-5&quot;&gt;一些必要的小贴士&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;用户名为&lt;code&gt;pi&lt;/code&gt;,密码为&lt;code&gt;raspberry&lt;/code&gt;&lt;br /&gt;
Debian Wheezy提供一个默认的用户名&lt;code&gt;pi&lt;/code&gt;和密码&lt;code&gt;raspberry&lt;/code&gt;(据说很久之前密码是&lt;code&gt;suse&lt;/code&gt;,假如你足够幸运)&lt;br /&gt;
&lt;code&gt;raspberry&lt;/code&gt;不是一个很好的密码，因为很多地区的键盘布局并没有设置&lt;code&gt;y&lt;/code&gt;(德国)，假如你是在国外，那么你可以使用&lt;code&gt;raspberrz&lt;/code&gt;来登录&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取你的Raspberry Pi的IP &lt;br /&gt;
请保证树莓派连接上网络，然后&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;你可以在路由器后台中查看你的树莓派的IP&lt;/li&gt;
      &lt;li&gt;你可以在Windows下使用&lt;a href=&quot;http://abel.oss.aliyuncs.com/file/PortScan.zip&quot; title=&quot;一款Windows下的端口扫描工具&quot;&gt;PortScan&lt;/a&gt;去查看,它会列出当前局域网内所有主机&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;你可以在Linux下使用&lt;code&gt;nmap&lt;/code&gt;&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  $ nmap -sP 192.168.199.0/24  
  Starting Nmap 6.40 ( http://nmap.org ) at 2014-12-07 08:51 CST
  Nmap scan report for Hiwifi.lan (192.168.199.1)
  Host is up (0.39s latency).
  Nmap scan report for mwumli-K43SA.lan (192.168.199.104)
  Host is up (0.00036s latency).
  Nmap scan report for MI2A-xiaomishouji.lan (192.168.199.137)
  Host is up (0.64s latency).
  Nmap scan report for android-e54569f466270a09.lan (192.168.199.226)
  Host is up (0.34s latency).
  Nmap scan report for raspberrypi.lan (192.168.199.244)
  Host is up (0.016s latency).
  Nmap done: 256 IP addresses (5 hosts up) scanned in 14.32 seconds
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体可参考&lt;a href=&quot;http://www.jbxue.com/LINUXjishu/10514.html&quot; title=&quot;Linux 查看局域网内所有主机IP和MAC的方法&quot;&gt;Linux 查看局域网内所有主机IP和MAC的方法&lt;/a&gt;&lt;br /&gt;
&lt;code&gt;nmap&lt;/code&gt;的介绍可以参考&lt;a href=&quot;http://nmap.org/man/zh/&quot; title=&quot;Nmap的Man手册&quot;&gt;Nmap参考指南&lt;/a&gt;&lt;br /&gt;
&lt;code&gt;nmap&lt;/code&gt;的使用介绍可以参考&lt;a href=&quot;http://netsecurity.51cto.com/art/200801/63660.htm&quot; title=&quot;端口扫描工具nmap使用介绍&quot;&gt;端口扫描工具namp的使用介绍&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;vnc&quot;&gt;使用VNC远程图形化访问&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Raspberry Pi安装VNC Server&lt;code&gt;tightvncserver&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo apt-get install tightvncserver  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code&gt;vncpasswd&lt;/code&gt;设置登录密码和一个view-only密码&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ vncpasswd
 You will require a password to access your desktops.

 Password: 
 Verify:   
 Would you like to enter a view-only password (y/n)? n view-only密码仅仅用来查看，所以可以不设置  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启用VNC Server&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tightvncserver
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在初次启动时，会提示步骤2的过程，之后就不会再提示&lt;br /&gt;
每启动一次，就会建立一个虚拟屏幕，那个&lt;code&gt;:n&lt;/code&gt;后面的数字n就是虚拟屏幕ID，我们使用VNC Client连接时需要&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在你的计算机中使用VNC Client,客户端很多
    &lt;ul&gt;
      &lt;li&gt;安装chrome浏览器，使用VNC Viewer for Google Chrome插件&lt;/li&gt;
      &lt;li&gt;在这里下在&lt;a href=&quot;https://www.realvnc.com/download/&quot; title=&quot;一个VNC Software站点&quot;&gt;https://www.realvnc.com/download/&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Linux下可以通过命令安装&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  $ sudo apt-get install vncviewer xtightvncviewer  
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用VNC客户端连接VNC服务端需要两个参数:&lt;code&gt;Pi的IP地址和屏幕的端口地址&lt;/code&gt;&lt;br /&gt;
VNC端口地址：&lt;code&gt;基础端口(默认5900)+屏幕ID&lt;/code&gt; &lt;br /&gt;
如果Pi的iP地址为:&lt;code&gt;192.168.199.227&lt;/code&gt;，屏幕ID为:&lt;code&gt;1&lt;/code&gt;&lt;br /&gt;
那么在Linux下可以这样访问:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ xtightvncviewer 192.168.199.227:5901
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于基础端口一般默认为5901,所以我们直接通过屏幕ID访问&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ xtightvncviewer 192.168.199.227:1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他客户端访问一样，在输入地址区域输入:&lt;code&gt;Pi&#39;s IP:[base port]+Screen ID&lt;/code&gt; &lt;br /&gt;
然后选择连接即可&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;配置&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;raspi-config&lt;/code&gt;进行一些重要的系统配置&lt;br /&gt;
主要是设置合适的区域以及扩展其可用存储空间&lt;/p&gt;

&lt;p&gt;&lt;em&gt;扩展文件系统到SD卡所有空间&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo raspi-config 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了出现一个命令行设置界面，选择第一项&lt;code&gt;Expand Filesystem&lt;/code&gt;,设置完毕，然后重启即可生效&lt;/p&gt;

&lt;p&gt;Raspberry镜像在整个系统中只占用2G空间，即用户8G的SD卡，也只能被使用2G空间，那么一些大的软件将无法安装&lt;/p&gt;

&lt;p&gt;&lt;em&gt;设置区域&lt;/em&gt; &lt;br /&gt;
每个地区的语言环境不一样，造成我们使用的键盘布局不一样，排序方法不一样，设置合适的区域，便于我们操作&lt;br /&gt;
而且各个地方的时间并不一致，难道你想坐在大白天看的时间凌晨一点吗?&lt;/p&gt;

&lt;p&gt;当然，假如你有此癖好，就请忽略&lt;/p&gt;

&lt;p&gt;&lt;em&gt;其他设置&lt;/em&gt;&lt;br /&gt;
按你的需求吧&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;更换软件源&lt;/h3&gt;
&lt;p&gt;树莓派的服务器在国外，在国内访问可能有点慢，额，应该很慢，还有些东西可能因为土啬的原因还下载不了&lt;br /&gt;
还好Raspberry Pi官方提供了一个镜像列表:&lt;a href=&quot;http://www.raspbian.org/RaspbianMirrors&quot; title=&quot;树莓派软件源列表&quot;&gt;http://www.raspbian.org/RaspbianMirrors&lt;/a&gt;&lt;br /&gt;
就近原则选择更换吧&lt;/p&gt;

&lt;p&gt;编辑&lt;code&gt;/etc/apt/sources.list&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#deb http://mirrordirector.raspbian.org/raspbian/ wheezy main contrib non-free rpi
deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ wheezy main contrib non-free rpi 
deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ wheezy main non-free contrib rpi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存，更新软件源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我注释了旧的软件源，添加一个中国的软件源&lt;/p&gt;

&lt;p&gt;对咯，使用上面地址打开的是一个目录，然后我们需要进入当前目录的&lt;code&gt;dists&lt;/code&gt;,然后可以看到&lt;code&gt;wheezy&lt;/code&gt;目录,进入&lt;code&gt;wheezy&lt;/code&gt;就可以看到&lt;code&gt;main&lt;/code&gt;,&lt;code&gt;contrib&lt;/code&gt;,&lt;code&gt;non-free&lt;/code&gt;,&lt;code&gt;rpi&lt;/code&gt;目录,每一个软件源的目录结构都是这样的，所以其他软件源的添加都这样办即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http-address wheezy main contrib non-free rpi 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-8&quot;&gt;配置自动连接你的局域网&lt;/h3&gt;
&lt;p&gt;修改/etc/network/interfaces,原内容如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;auto lo 

iface lo inet loopback
iface eth0 inet dhcp

allow-hotplug wlan0
iface wlan0 inet manual
wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf
iface default inet dhcp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改如下:&lt;/p&gt;

&lt;h1 id=&quot;localhost&quot;&gt;使用localhost&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;auto lo

iface lo inet loopback
iface eth0 inet dhcp

allow-hotplug wlan0 #表示wlan0设备可以热插拔
iface wlan0 inet dhcp
wpa-ssid your-wifi-ssid
wpa-psk your-wifi-passwd

iface default inet dhcp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OKay，以后就会自动连接上你的wifi，假如存在&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;后记&lt;/h3&gt;
&lt;p&gt;刚看到树莓派的时候，就一块布满电路的板子，瞬间有点懵，天生对电路过敏&lt;/p&gt;

&lt;p&gt;但事实上，关于电路的部分，人家已经为你封装好了(&lt;strong&gt;多好的思想,感谢面向对象&lt;/strong&gt;),你只需要会一点软件的知识，痛快的玩就可以了&lt;/p&gt;

&lt;p&gt;文章很长，但还是觉得不够，很多东西还没讲到，但这些应该已经足够&lt;/p&gt;

&lt;p&gt;装系统其实只花费了一小会儿，而写文章却用了4个小时&lt;/p&gt;

&lt;p&gt;希望玩的愉快!…&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/raspberrypi-install</link>
                <guid>http://mwumli.github.io/raspberrypi-install</guid>
                <pubDate>2014-12-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Linux下MASM汇编环境搭建</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;碎碎念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dosbox&quot; id=&quot;markdown-toc-dosbox&quot;&gt;安装dosbox&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#masm&quot; id=&quot;markdown-toc-masm&quot;&gt;下载MASM软件包&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dosbox-1&quot; id=&quot;markdown-toc-dosbox-1&quot;&gt;启动dosbox&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dosbox-2&quot; id=&quot;markdown-toc-dosbox-2&quot;&gt;使用脚本启动dosbox&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#helloworld&quot; id=&quot;markdown-toc-helloworld&quot;&gt;写个汇编版的HelloWorld&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#dosbox-3&quot; id=&quot;markdown-toc-dosbox-3&quot;&gt;在dosbox中编译连接&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;一些自言自语&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;推荐&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;碎碎念&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;MASM&lt;/code&gt;是Microsoft Macro Assembler的缩写，它是微软为x86微处理器家族缩写的一套宏编译器&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dosbox&lt;/code&gt;是一款x86/DOS环境模拟器，可以很好模拟DOS环境,方便我们运行DOS程序&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.asm&lt;/code&gt;是汇编代码的后缀&lt;/p&gt;

&lt;p&gt;好了，现在开始吧！&lt;/p&gt;

&lt;h2 id=&quot;dosbox&quot;&gt;安装dosbox&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install dosbox  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;masm&quot;&gt;下载MASM软件包&lt;/h2&gt;

&lt;p&gt;从这里下载&lt;a href=&quot;http://yun.baidu.com/share/link?shareid=507770005&amp;amp;uk=388194121&quot; title=&quot;masm.tar.bz2&quot;&gt;masm.tar.bz2&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~
$ mkdir -p masm/tools
$ tar xjf Download/masm.tar.bz2 -C masm/tools 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载的文件，解压到新建的文件夹masm/tools下&lt;br /&gt;
masm即将作为dosbox的C盘&lt;/p&gt;

&lt;h2 id=&quot;dosbox-1&quot;&gt;启动dosbox&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ dosbox -c &quot;mount C: ~/masm/tools&quot; -c &quot;path %path%;C:\tools\&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，dosbox应该出现了，你可以使用&lt;code&gt;debug.exe&lt;/code&gt;,&lt;code&gt;masm.exe&lt;/code&gt;了&lt;br /&gt;
&lt;code&gt;-c&lt;/code&gt;: 指定dosbox的启动参数&lt;br /&gt;
&lt;code&gt;mount C: ~/masm/tools&lt;/code&gt;: 把我们用户主目录下的masm/tools作为dosbox的C盘&lt;br /&gt;
&lt;code&gt;path %path%;C:\tools&lt;/code&gt; : 给path(&lt;em&gt;可执行文件搜索路径&lt;/em&gt;)环境变量添加值，这样，我们无论在哪个目录都可以使用masm软件包的工具了&lt;/p&gt;

&lt;h2 id=&quot;dosbox-2&quot;&gt;使用脚本启动dosbox&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;dosbox_setup.sh&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
dosbox -c &quot;mount C: ~masm&quot; -c &quot;path %path%;C:\tools\&quot; &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为dosbox_setup.sh添加执行权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod a+x dosbox_setup.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，你可以通过运行此脚本打开dosbox,而且路径已经配置好了&lt;/p&gt;

&lt;h2 id=&quot;helloworld&quot;&gt;写个汇编版的HelloWorld&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;hello.asm&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assume cs:codes, ds:datas
datas segment
		str db &#39;hello,world&#39;,13,10,&#39;$&#39;
datas ends
codes segment
	start:
		mov ax, datas
		mov ds, ax
		lea dx, str
		mov ah, 9
		int 21h
		mov ah, 4ch
		int 21h
codes ends
	end start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用vim写代码(当然如果你嫌影响你的心情的话，可以使用&lt;code&gt;EDIT.COM&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;dosbox-3&quot;&gt;在dosbox中编译连接&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;C:\&amp;gt; masm hello.asm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译生成hello.obj的连接文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\&amp;gt; link hello.obj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连接生成hello.exe的可执行文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\&amp;gt; hello.exe
hello,world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此结束&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;一些自言自语&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;为什么选择MASM呢？&lt;/em&gt;&lt;br /&gt;
事实上，各大高校的汇编语言学习都是使用MASM的语法，而Linux下的NASM的语法和其还是有些差异的&lt;br /&gt;
(不要问我为何在Linux下使用MASM，我能告诉你这是我的偏执吗?嘿嘿…)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;为什么还要学习汇编?&lt;/em&gt;  &lt;br /&gt;
这个各人有个人的理由吧，而我只是单纯想了解一下底层程序的运行机制&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;推荐&lt;/h2&gt;

&lt;p&gt;对于汇编学习，推荐王爽先生的《汇编语言》&lt;br /&gt;
对于dosbox的其他用法，请使用Linux下的&lt;code&gt;man dosbox&lt;/code&gt;&lt;br /&gt;
对于其它问题，请留言或者google&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/linux-masm-built</link>
                <guid>http://mwumli.github.io/linux-masm-built</guid>
                <pubDate>2014-12-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>简单的DNS讲解</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#dns&quot; id=&quot;markdown-toc-dns&quot;&gt;DNS是什么&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#linuxdns&quot; id=&quot;markdown-toc-linuxdns&quot;&gt;Linux下的一些用于DNS查询的命令&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tcpdumpdns&quot; id=&quot;markdown-toc-tcpdumpdns&quot;&gt;使用tcpdump观察DNS通信过程&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#dns-1&quot; id=&quot;markdown-toc-dns-1&quot;&gt;修改DNS&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dns&quot;&gt;DNS是什么&lt;/h2&gt;

&lt;p&gt;DNS，可以看作Domain Name Service，Domain Name Server, Domain Name System的缩写，网上也没有统一的解释,说明是哪一种的缩写,我们暂且先不管它&lt;/p&gt;

&lt;p&gt;早期互联网的时代，我们使用IP地址访问网站&lt;br /&gt;
由于IPV4(IPv6)地址的难以记忆，人们用了一种转换的思想:&lt;code&gt;使用人类容易记忆的名字来代替IP地址,然后通过某种服务把域名转化成IP&lt;/code&gt;，这样，就可以实现精确的定位&lt;br /&gt;
而这个名字就是域名,例如耳熟能详的百度首页&lt;code&gt;www.baidu.com&lt;/code&gt;,我们学校的论坛&lt;code&gt;www.xiyoubbs.com&lt;/code&gt;&lt;br /&gt;
这种服务就是域名解析服务，我们用来提供服务的服务器就被称作域名解析服务器&lt;/p&gt;

&lt;p&gt;事实上,我们通常把域名服务，域名服务器都可以称作DNS，理解了域名解析服务的工作原理，就很容易明白我们交流，或者其他文献中简称DNS时，它所代表的真实含义&lt;br /&gt;
#### DNS的两种查询方式&lt;br /&gt;
分别是递归查询和迭代查询&lt;/p&gt;

&lt;p&gt;所谓&lt;em&gt;递归查询&lt;/em&gt;：如果目标DNS服务器无法解析某个主机名,则它将向其他DNS服务器继续查询，如此递归，知道获得结果并把结果返回给客户&lt;/p&gt;

&lt;p&gt;所谓&lt;em&gt;迭代查询&lt;/em&gt;：如果目标DNS服务器无法解析某个主机名，则它将已知道的其他DNS服务器的IP地址返回给客户端，以供客户端参考&lt;/p&gt;

&lt;p&gt;一般默认都是递归查询&lt;/p&gt;

&lt;h3 id=&quot;linuxdns&quot;&gt;Linux下的一些用于DNS查询的命令&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ping命令，不仅可以判断网络是否畅通，还可以用域名ping外网时，查看域名对应的主机IP&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ ping www.baidu.com
  PING www.a.shifen.com (61.135.169.125) 56(84) bytes of data.
  64 bytes from 61.135.169.125: icmp_seq=1 ttl=53 time=19.7 ms
  64 bytes from 61.135.169.125: icmp_seq=2 ttl=53 time=21.1 ms
  64 bytes from 61.135.169.125: icmp_seq=3 ttl=53 time=20.0 ms
  ...
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host命令,一个DNS查询工具&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ host -t A www.baidu.com  
  www.baidu.com is an alias for www.a.shifen.com.
  www.a.shifen.com has address 61.135.169.121
  www.a.shifen.com has address 61.135.169.125  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tcpdumpdns&quot;&gt;使用tcpdump观察DNS通信过程&lt;/h3&gt;
&lt;p&gt;tcpdump是Linux下的一个抓包工具&lt;br /&gt;
(Linux下各种服务所对应的端口，可以在&lt;code&gt;/etc/services&lt;/code&gt;看到)&lt;br /&gt;
在一个终端A输入一下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo tcpdump -i wlan0 -nt port domain 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后开启另一个终端B,输入一下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ host -t -A www.baidu.com  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以在终端A下看到:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IP 172.24.243.3.21645 &amp;gt; 172.24.243.1.53: 18340+ A? www.baidu.com. (31)
IP 172.24.243.1.53 &amp;gt; 172.24.243.3.21645: 18340 3/0/0 CNAME www.a.shifen.com., A 115.239.211.110, A 115.239.210.27 (138)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cpdump以“IP地址.端口号”的形式来描述通信的某一端；以“&amp;gt;”表示数据传输的方向，“&amp;gt;”前面是源端，后面是目的端。&lt;/p&gt;

&lt;p&gt;目标端口53是DNS服务使用的端口&lt;/p&gt;

&lt;p&gt;第一个数据包是我的机器(172.24.243.3)发送的DNS查询报文&lt;br /&gt;
第二个数据包是服务器反馈的DNS应答报文&lt;/p&gt;

&lt;p&gt;第一个数据包中，数值18340是DNS查询报文的标识值，因此该值也出现在DNS应答报文中。&lt;br /&gt;
“+”表示启用递归查询标志。&lt;br /&gt;
“A”表示使用A类型的查询方式。&lt;br /&gt;
“www.baidu.com”则是DNS查询问题中的查询名。&lt;br /&gt;
括号中的数值31是DNS查询报文的长度（以字节为单位）。&lt;/p&gt;

&lt;p&gt;第二个数据包中，“3/0/0”表示该报文中包含3个应答资源记录、0个授权资源记录和0个额外信息记录。&lt;br /&gt;
“CNAME www.a.shifen.com., A 115.239.211.110, A 115.239.210.27 (138)”则表示3个应答资源记录的内容。&lt;br /&gt;
其中CNAME表示紧随其后的记录是机器的别名，A表示紧随其后的记录是IP地址。&lt;br /&gt;
该应答报文的长度为138字节。&lt;/p&gt;

&lt;h3 id=&quot;dns-1&quot;&gt;修改DNS&lt;/h3&gt;
&lt;p&gt;我记得以前碰到过这样一见很诡异的事情：qq可以登录聊天，邮件客户端也可以正常工作，就唯独浏览器打不开网站页面&lt;/p&gt;

&lt;p&gt;当时遇到的时候，感觉可诡异，后来才知道，原来是DNS挂了&lt;/p&gt;

&lt;p&gt;我们通常上网都是直接通过网络运营商(电信，网通等)提供的网络，所以DNS也是自动获取，一定运行上的域名服务器出现了问题，那么我们也就不能正常访问网站&lt;/p&gt;

&lt;p&gt;此时，我们就得修改DNS，著名的DNS有谷歌的:&lt;code&gt;8.8.8.8&lt;/code&gt; 和 &lt;code&gt;8.8.4.4&lt;/code&gt;   &lt;br /&gt;
还有114DNS:&lt;code&gt;114.114.114.114&lt;/code&gt;和&lt;code&gt;114.114.115.115&lt;/code&gt;  &lt;br /&gt;
这两个算是比较好记的&lt;/p&gt;

&lt;p&gt;还有其他的请参考&lt;a href=&quot;www.ip.cn/dns.html&quot;&gt;公共DNS服务器&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/dns</link>
                <guid>http://mwumli.github.io/dns</guid>
                <pubDate>2014-11-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>编译和连接</title>
                <description>&lt;h2 id=&quot;section&quot;&gt;编译和连接&lt;/h2&gt;
&lt;p&gt;对于平常的应用程序开发，我们很少关注编译和连接的过程，因为通常的开发环境都是流行的集成开发环境(IDE)&lt;/p&gt;

&lt;p&gt;而IDE往往将编译和连接的过程“一气呵成”,通常编译和连接合并到一块被称为”build”,也就是构建.&lt;/p&gt;

&lt;p&gt;即使是命令行来编译一个&lt;code&gt;hello.c&lt;/code&gt;，简单一句&lt;code&gt;gcc hello.c&lt;/code&gt;，然后你就可以&lt;code&gt;./a.out&lt;/code&gt;来得到富有盛名的&lt;code&gt;Hello,World!&lt;/code&gt;了&lt;/p&gt;

&lt;p&gt;正所谓“有一得必有一失”，我们享受与这种一键执行的快感，却忽略很多系统软件背后的运行机制和机理，程序中很多莫名其妙的错误常常令我们无所适从，面对程序运行时种种性能瓶颈我们束手无策，而为了解决这些问题，我们往往需要追根溯源&lt;/p&gt;

&lt;p&gt;因此，了解编译和连接的过程，有助于我们对软件运行的机理的了解以及对出现的各种问题能有更高效的解决途径&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;从最简单最熟悉开始&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Hello,World&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//hello.c&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样的程序，闭着眼睛，用心作笔，估计一秒钟都可以写几万次了吧&lt;br /&gt;
在Linux下，当我们使用GCC来编译hello.c,这样做:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls 
hello.c
$ gcc hello.c
$ ls
a.out hello.c
$ ./a.out
Hello,World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，我们使用gcc编译处理hello.c之后，生成了一个a.out的文件&lt;br /&gt;
这个文件正是我们可执行程序，运行之后，输出&lt;code&gt;Hello,World&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;整个过程很简单，但这只是表面上的，事实上，上述过程可以分解为4个步骤，分别是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;预处理(Prepressing)[.c]-&amp;gt;编译(Compilation)[.i]-&amp;gt;汇编(Assembly)[.o]-&amp;gt;链接(Linking)[可执行文件]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;c-i-using-cpp&quot;&gt;预处理(.c-&amp;gt;.i using cpp)&lt;/h3&gt;
&lt;p&gt;Linux下对c文件进行预处理，可以使用预编译器&lt;code&gt;cpp&lt;/code&gt;&lt;br /&gt;
进行预处理之后，生成的预处理文件为&lt;code&gt;.i&lt;/code&gt;,对于C++程序而言，预编译后的文件为&lt;code&gt;.ii&lt;/code&gt;&lt;br /&gt;
以下是预编译的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cpp hello.c &amp;gt; hello.i  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -E hello.c -o hello.i  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无论是&lt;code&gt;cpp&lt;/code&gt;还是&lt;code&gt;gcc -E&lt;/code&gt;,他们的结果(在不指定目标文件的情况下)会输出到&lt;code&gt;stdout&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;预编译的过程主要处理那些源码中以”#”开始的预编译指令，比如&lt;code&gt;#include&lt;/code&gt;，&lt;code&gt;#define&lt;/code&gt;&lt;br /&gt;
主要做了一下处理:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;将所有&lt;code&gt;#define&lt;/code&gt;处删除，展开所有宏定义&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 在include和main之间添加“#define HELLO &quot;hello,world\n&quot; ”,
 然后把printf()中的内容改为HELLO,接着如上预处理生成目标文件hello_micro.i
 使用diff hello.i hello_micro.i,发现两个文件完全一致 
 由此证明删除定义宏，展开所有宏  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;处理所有条件预编译指令，比如&lt;code&gt;#if&lt;/code&gt;,&lt;code&gt;#ifdef&lt;/code&gt;,&lt;code&gt;#elif&lt;/code&gt;,&lt;code&gt;#else&lt;/code&gt;,&lt;code&gt;#endif&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;处理&lt;code&gt;#include&lt;/code&gt;预编译指令，将被包含的文件插入到该预编译指令的位置。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。
 因此，在多文件程序中要注意同一文件被多次包含引起的错误  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;删除所有的注释&lt;code&gt;//&lt;/code&gt;和&lt;code&gt;/**/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;添加行号和文件名标识，比如&lt;code&gt;#2 &quot;hello.c&quot; 2&lt;/code&gt;,以便于编译时产生调试用的行号信息及用于编译时产生编译错误或警告时都能显示行号&lt;/li&gt;
  &lt;li&gt;保留所有的&lt;code&gt;#pragma&lt;/code&gt;编译器指令，因为编译器需要使用它们&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;经过预编译后的&lt;code&gt;.i&lt;/code&gt;文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中。&lt;br /&gt;
所以当我们&lt;em&gt;无法判断宏定义是否正确&lt;/em&gt;或者&lt;em&gt;头文件是否正确引入&lt;/em&gt;的时候，可以查看预编译后的&lt;code&gt;.i&lt;/code&gt;文件来确定问题&lt;/p&gt;

&lt;h3 id=&quot;i-s-using-cc1&quot;&gt;编译(.i-&amp;gt;.s using cc1)&lt;/h3&gt;
&lt;p&gt;编译过程就是把&lt;code&gt;.i&lt;/code&gt;文件进行一系列的词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件&lt;code&gt;.s&lt;/code&gt;&lt;br /&gt;
这个过程整个程序构建的核心部分,也是最复杂的部分，涉及到编译原理的一些内容&lt;br /&gt;
Linux命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -S hello.i -o hello.s  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;据说，现在的gcc已经将预编译和编译两个步骤合并成一个步骤，使用一个叫做&lt;code&gt;cc1&lt;/code&gt;的程序&lt;br /&gt;
&lt;code&gt;cc1&lt;/code&gt;在我的机器(Ubuntu 14.04 LTS)上的路径&lt;code&gt;/usr/lib/gcc/x86_64-linux-gnu/4.8/cc1&lt;/code&gt; &lt;br /&gt;
因此，我这样编译：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/lib/gcc/x86_64-linux-gnu/4.8/cc1 hello.i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和上面的命令效果等同&lt;br /&gt;
但是根据资料显示，&lt;code&gt;cc1&lt;/code&gt;把预编译和编译融合，因此我使用&lt;code&gt;/usr/lib/gcc/x86_64-linux-gnu/4.8/cc1 hello.c&lt;/code&gt;,结果出错&lt;/p&gt;

&lt;p&gt;为了研究其原因，我使用&lt;code&gt;gcc -v hello.c 2&amp;gt;cp.txt&lt;/code&gt;打印gcc对其编译过程做了那些操作&lt;br /&gt;
因为比较长，只截取有用的部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/lib/gcc/x86_64-linux-gnu/4.8/cc1 -quiet -v -imultiarch x86_64-linux-gnu hello.c -quiet -dumpbase hello.c -mtune=generic -march=x86-64 -auxbase hello -version -fstack-protector -Wformat -Wformat-security -o /tmp/cckHwTs6.s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到cc1携带了大量的参数，最终生成汇编文件保存在&lt;code&gt;/tmp/cckHwTs6.s&lt;/code&gt;&lt;br /&gt;
我在命令行进行了验证，确实如此&lt;br /&gt;
这里又一次证明了：IDE掩盖很多已有的参数。不过，这么多参数确实让人心烦，既然常用，默认是一个好的办法，不过，你应该了解有这么个过程&lt;/p&gt;

&lt;h3 id=&quot;s-o-using-as&quot;&gt;汇编(.s-&amp;gt;.o using as)&lt;/h3&gt;
&lt;p&gt;汇编器就是将汇编代码转变成机器可以执行的指令，每一个汇编语句都对应一条机器指令,所以汇编器的汇编过程相对于编译过程就显得简单多了。&lt;/p&gt;

&lt;p&gt;汇编过程在linux下我们调用汇编器as来完成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ as hello.s -o hello.o  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -c hello.s -o hello.o  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者使用gcc从.c文件开始，经过预编译、编译、汇编直接输出&lt;em&gt;目标文件&lt;/em&gt;(Object File)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -c hello.s -o hello.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样，我们可以在cp.txt文件中看到下面一段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;COLLECT_GCC_OPTIONS=&#39;-v&#39; &#39;-mtune=generic&#39; &#39;-march=x86-64&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;链接通常是一个让人费解的过程：&lt;br /&gt;
为什么汇编器不直接输出可执行文件而是一个目标文件呢？&lt;br /&gt;
链接过程到底包含了什么内容？&lt;br /&gt;
为什么要链接?&lt;br /&gt;
…&lt;br /&gt;
我们通常使用ld来链接目标文件&lt;br /&gt;
我们来看看cp.txt中的相应描述：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/lib/gcc/x86_64-linux-gnu/4.8/collect2 --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -z relro /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.8/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.8 -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../.. /tmp/ccfb7d3z.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/4.8/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crtn.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;额，好长啊，不过貌似没有&lt;code&gt;ld&lt;/code&gt;的字眼，看来gcc并没有如同我们想象的那样直接调用ld进行链接。而是调用&lt;code&gt;collect2&lt;/code&gt;进行链接&lt;/p&gt;

&lt;p&gt;实际上，&lt;code&gt;collect2&lt;/code&gt;只是一个辅助程序最终它仍调用&lt;code&gt;ld&lt;/code&gt;进行链接&lt;/p&gt;

&lt;p&gt;举个例子：对于C++程序来说，在执行main函数前，全局静态对象必须构造完成。
也就是说，在main之前程序需要进行一些必要的初始化，gcc就是使用collect2安排初始化过程中如何调用各个初始化函数的。根据链接过程可见，除了hello.c对应的目标文件ccfb7d3z.o外，ld也链接了libc、libgcc等库，以及所谓的包含启动代码（start code）的启动文件（start/startup file），包括crt1.o、crti.o、crtbegin.o、crtend.o和crtn.o&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;《程序员的自我修养》&lt;/li&gt;
  &lt;li&gt;《深度探索Linux操作系统：系统构建和原理解析》&lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://mwumli.github.io/compile-link</link>
                <guid>http://mwumli.github.io/compile-link</guid>
                <pubDate>2014-09-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Linux内核链表的分析</title>
                <description>&lt;h3 id=&quot;listhead&quot;&gt;内核中list_head的定义&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;struct list_head {
	struct list_head *next, *prev;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仅仅只有两个指针，prev指向前一个节点,next指向后一个节点&lt;br /&gt;
但是为什么没有data域呢？&lt;br /&gt;
内核出错了，显然不可能，别急，慢慢来&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;栈，队列，链表…..&lt;/h4&gt;
&lt;p&gt;我们可以用这个结构定义一个新的结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;strutc my_list_node {
	int	data;
	strutc list_head list;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;假如我们禁用了list中的prev,它就是一个&lt;em&gt;单链表&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如(单链表的基础上)我们启用list中的prev，它就是一个&lt;em&gt;双链表&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如(单链表基础上)我们让最后一个节点next指向第一个节点，那么它就是一个&lt;em&gt;单向循环链表&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如(单向循环链表基础上)我们启用list中的prev域，那么它就是一个&lt;em&gt;双向循环链表&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如(单链表的基础上)，我们有方法可以从头部插入，头部删除，那么它就是一个&lt;em&gt;栈&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如(单链表的基础上)，我们有方法可以头部删除，尾部插入那么它就是一个&lt;em&gt;队列&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如…,它就是一个…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好了,我想也不用多说了，大家应该思维澎湃了&lt;br /&gt;
这正体现了一点：链表是其他数据结构的根本形式&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;为什么没有数据域？&lt;/h4&gt;
&lt;p&gt;怎么可能？链表没有数据，这还有什么意义&lt;br /&gt;
是啊，没有数据域，我们该怎储存信息呢？&lt;br /&gt;
事实上，上面我们定义的这个&lt;em&gt;struct my_list_node&lt;/em&gt;就解释了为什么没有数据域&lt;br /&gt;
没有数据正是为了可以容纳更多的，不同的数据类型(通过自定义)&lt;/p&gt;

&lt;p&gt;这就是抽象的艺术，说起抽象，谈谈面向对象也不不错&lt;/p&gt;

&lt;p&gt;我们常说，C++是面向对象的语言，其实面向对象并不只是说一种语言，而是一种思想：我们把具体的东西通过对其共性的分析，抽象出来，从而形成一种结构，这种结构或许单独来说么有实际意义，但是通过我们增添不同的功能，从而就有了不同的意义新的结构，那么此时，其意义得以体现，这就是我理解的面向对象&lt;/p&gt;

&lt;p&gt;可以看到我们抛弃了那所谓的数据，只留下了两个指针，正因为抛弃了数据域(也不能说抛弃，应该是还未迎娶),我们才可以通过自定义添加不同的数据类型(int,char等),更多的数据成员(1,2,3…)&lt;/p&gt;

&lt;p&gt;所有有的时候，所谓的舍弃，只是为了更好的扩展&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;内核链表的初始化&lt;/h3&gt;
&lt;p&gt;两个宏，一个函数&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;两个宏&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#define LIST_HEAD_INIT(name) { &amp;amp;(name), &amp;amp;(name) }

#define LIST_HEAD(name) strutc list_head name = LIST_HEAD_INIT(name)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;一个函数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;static inline void INIT_LIST_HEAD(struct list_head *list) 
{
	list-&amp;gt;next = list;
	list-&amp;gt;prev = list;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些有什么不同呢？&lt;br /&gt;
我看了有看，也确实有点不同&lt;br /&gt;
&lt;em&gt;LIST_HEAD&lt;/em&gt;和&lt;em&gt;LIST_HEAD_INIT&lt;/em&gt;是相辅相成的，如果单独使用的话，那么&lt;em&gt;LIST_HEAD_INIT&lt;/em&gt;需要用在结构体变量定义初始化的时候，而&lt;em&gt;LIST_HEAD&lt;/em&gt;只需要提供一个变量名即可完成定义兼初始化：&lt;br /&gt;
&lt;strong&gt;LIST_HEAD_INIT&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct list_head lp = LIST_HEAD_INIT(lp);	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;LIST_HEAD&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LIST_HEAD(lp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两段代码看起来不一样，其实本质是一样的：定义了一个名为lp的struct list_head变量，同时用其自己的地址对其初始化&lt;/p&gt;

&lt;h4 id=&quot;static-inline&quot;&gt;static inline&lt;/h4&gt;
&lt;p&gt;当你看过&lt;em&gt;list.h&lt;/em&gt;后，我相信你对static inline已经熟的不能在熟&lt;br /&gt;
但是有有点困惑，为什么这么频繁的使用呢？&lt;br /&gt;
真是熟悉的陌生人!…呵呵&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;static&lt;/strong&gt;&lt;br /&gt;
被static修饰的函数，作用域将限于本文件，也就是其他文件看不见&lt;/p&gt;

&lt;p&gt;可能你觉的这样说起来很模糊，而且假如我们在.h文件中定义，然后被其他.c文件&lt;em&gt;include&lt;/em&gt;,那么根据&lt;em&gt;include&lt;/em&gt;的定义：当预处理器具发现include的时候，就会寻找inlucde之后的文件,并把这个文件包含到当前文件,即替换include指令&lt;/p&gt;

&lt;p&gt;所以这样的话，.h文件也是.c文件的一部分了，那么.h文件中被static修饰的函数必然也能在.c文件中使用了，那么，static的意义不存了&lt;/p&gt;

&lt;p&gt;嗯哼，当然不是这样的，我们试着这样做一做吧:&lt;br /&gt;
&lt;em&gt;test_static.h&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void func1(){ }
void func2(){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还有两个文件，一个是main.c, 一个是test_static.c，这两文件我们都引用了&lt;strong&gt;test_static.h&lt;/strong&gt;,然后我们执行下面指令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -o main main.c test_static.c test_static.h
/tmp/ccSrEpb2.o: In function `func2&#39;:
test_static.c:(.text+0x6): multiple definition of `func2&#39;
/tmp/cc54UVtA.o:main.c:(.text+0x6): first defined here
collect2: error: ld returned 1 exit status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是的报错了：func2多重定义,对就是那个没有定义为static的家伙&lt;/p&gt;

&lt;p&gt;好了，我们给func2加上static,在编译一次(自己操作)，啊哈，编译成功&lt;br /&gt;
是的，static让错误消失了&lt;/p&gt;

&lt;p&gt;怎么回事儿呢？&lt;br /&gt;
添加了static ,虽然每个.c文件中都定义了static函数，但是经过编译，所有的static隐藏在自己的目的文件(.o)中，连接器(linker)在找寻symbol的过程中，是会被忽略的&lt;/p&gt;

&lt;p&gt;所以，我们加上static是为了避免多重定义连接错误&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;inline&lt;/strong&gt;&lt;br /&gt;
inline是内联的意思，即当定义了inline,就会暗示编译器，我有”倒插门”的倾向，然后，编译器愿不愿意接受，那就得看具体编译器的不同配置了;如果我被接受了，那么在编译的时候，我会每个call我的地方”赤身裸体”(即展开代码)&lt;/p&gt;

&lt;p&gt;因为代码被插入到被调用的地方，所以效率肯定提高了(相比函数调用的上下文切换)&lt;br /&gt;
这也就是函数前使用inline的意义：提高效率(现在存储技术发展很快，相比之下，效率尤为重要)&lt;/p&gt;

&lt;p&gt;现在，关键的来了，我们同时使用了static inline：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When an inline function is not static, then the compiler must assume that there may be calls from other source files; since a global symbol can be defined only once in any program, the function must not be defined in the other source files, so the calls therein cannot be integrated. Therefore, a non-static inline function is always compiled on its own in the usual fashion.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这段话来自&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Inline.html&quot;&gt;gcc的官方文档&lt;/a&gt;&lt;br /&gt;
我的理解：在.h文件中定义inline,如果没有static,那么编译器(至少gcc是这样)就会认为你可能被其他文件多次调用，因为一个全局符号在任何一个程序中仅能出现一次，这个函数一定不能定义在其他源文件中，因此这此调用不能inline函数代码不能被集成到被调用处&lt;/p&gt;

&lt;p&gt;所以，我想应该是基于这个原因，所以内核代码中多次使用&lt;em&gt;static inline&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;内核链表的插入&lt;/h3&gt;
&lt;p&gt;将new插入head之后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void list_add(struct isr_head *new , struct list_head *head) 
{
	__list_add(new, head, head-&amp;gt;next);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码注释里有句话：This is good for implementing stacks.&lt;/p&gt;

&lt;p&gt;将new插入到head之前，即尾部&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void list_add_tail(struct list_head *new, struct list_head *head)  
{
	__list_add(new, head-&amp;gt;prev, head);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码注释里有句话：This is good for implementing queues.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;__list_add&lt;/strong&gt;到底是何方人士，竟引得list_add和list_add_tail竞相使用?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void __list_add(struct list_head *new,
				struct list_head *prev;
				struct list_head *next;)
{
	next-&amp;gt;prev = new;
	new-&amp;gt;next = next;
	prev-&amp;gt;next = new;
	new-&amp;gt;prev = prev;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到代码，才知道：哦，原来只是把一个node插入到两个node之间的函数&lt;br /&gt;
不用多说了，这里很简单，但是重要的是这种抽象的思想&lt;br /&gt;
对了，看来那两句注释，感觉如何？&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;内核链表之删除&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;static inline void __list_del(struct list_head * prev, 
				struct list_head * next)
{
	next-&amp;gt;prev = prev;
	prev-&amp;gt;next = next;
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry-&amp;gt;prev, entry-&amp;gt;next);  
	entry-&amp;gt;next = LIST_POISON1;        
	entry-&amp;gt;prev = LIST_POISON2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码很简单，LIST_POISON1和LIST_POISON2是两个宏，被定义在poison.h中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define LIST_POISON1  ((void *) 0x00100100 + POISON_POINTER_DELTA)
#define LIST_POISON2  ((void *) 0x00200200 + POISON_POINTER_DELTA)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释说这两个非空指针在正常情况下会导致页错误，这是它的注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 *These are non-NULL pointers that will result in page faults¬
 * under normal circumstances, used to verify that nobody uses¬
 * non-initialized list entries.
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些都可以理解，但是为什么是0x00100100和0x00200200呢？&lt;br /&gt;
我查了很多资料，都没找到答案，恳请各位解惑&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;内核链表之遍历&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; #define list_for_each(pos, head) \
	for (pos = (head)-&amp;gt;next; pos != (head); pos = pos-&amp;gt;next)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个宏很简单，但是有个难点就是我们怎么根据pos找到node的位置，例如我上面定义的struct my_list_node这个结构&lt;br /&gt;
list.h给出了代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define list_entry(ptr, type, member) \
	container_of(ptr, type, member)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个container_of在kernel.h中有定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define container_of(ptr, type, member) ({       \
|	const typeof( ((type *)0)-&amp;gt;member ) *__mptr = (ptr);   \
|	 (type *)( (char *)__mptr - offsetof(type,member) );})  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码还真不好说，还是给出一段代码，试试就知道了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

struct list_head {
	struct list_head *self;
};
typedef struct Type_List {
	int a;
	struct list_head list;
}Type_List;

int main(int argc, const char *argv[])
{
	Type_List *tl=(Type_List *)malloc(sizeof(Type_List));
	//打印tl的地址
	printf(&quot;%x\n&quot;, tl);

	//获取tl的成员list的地址赋给ptr
	struct list_head *ptr=&amp;amp;(tl-&amp;gt;list);
	//使用ptr获取tl的地址
	Type_List *p=(Type_List *)((char *)ptr-(unsigned long)&amp;amp;(((Type_List *)0)-&amp;gt;list));
	printf(&quot;%x\n&quot;, p);

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简而言之，就是使用list的地址减去list成员距my_list_head的起始地址的偏移量&lt;br /&gt;
而offsetof就是求偏移量的宏&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;内核链表删除的不安全性&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#define list_for_each_safe(pos, n, head) \
    for (pos = (head)-&amp;gt;next, n = pos-&amp;gt;next; pos != (head); \
		pos = n, n = pos-&amp;gt;next)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是list.h中提供的用于安全删除链表的遍历宏&lt;br /&gt;
之前我们看到list_for_each这个宏&lt;br /&gt;
如果我们向下面这样用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list_for_each(ptr, head) {
	tmp = list_entry(ptr, struct my_list_head, list);
	list_del(ptr);
	free(tmp)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写的话，因为ptr已经被删除，但根据list_for_each内部实现却是在删除ptr之后，调用ptr=ptr-&amp;gt;next,因为地址已经被引入LIST_POISON1了，所以肯定报错&lt;/p&gt;

&lt;p&gt;而我们使用了list_for_each_safe,就不会这样，因为有一个临时的struct my_list_head类型变量n记录了ptr的下一个节点，所以就不会出现问题&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;结束&lt;/h3&gt;
&lt;p&gt;呵，松了口气，好长啊，不过，看了内核对list的实现，确实收获很多，尽管现在看到是”冰山一脚“，但是这一脚总算是才上去了&lt;br /&gt;
对于文章中出现的问题，希望作为读者的你能提出来，帮助我改进&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/kernel-list</link>
                <guid>http://mwumli.github.io/kernel-list</guid>
                <pubDate>2014-09-22T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>静态博客系统-->JekyllBootstrap</title>
                <description>
&lt;h3 id=&quot;jekyllbootstrap&quot;&gt;上菜–JekyllBootstrap&lt;/h3&gt;
&lt;p&gt;在&lt;a href=&quot;/%E8%AE%B0%E5%BD%95/2014/08/14/static-website-by-jekyll/&quot; title=&quot;使用jekyll搭建静态站点&quot;&gt;使用jekyll搭建静态站点&lt;/a&gt;一文中， 我已经介绍了怎么创建最简单站点的例子(&lt;code&gt;jekyll new myblog&lt;/code&gt;),但看起来貌似难以起步(神马都没有),一切都需要start from scratch，真是愁啊&lt;/p&gt;

&lt;p&gt;不过，现在不用担心了，我们有技能–&amp;gt;JekyllBootstrap&lt;/p&gt;

&lt;p&gt;JekyllbBootstrap就像WordPress(动态博客系统）一样，但是，jekyllbootstrap用于静态网站&lt;/p&gt;

&lt;p&gt;好了，开始准备干活吧&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个新的仓库&lt;br /&gt;
去你的&lt;a href=&quot;https://github.com&quot; title=&quot;github首页&quot;&gt;https://github.com&lt;/a&gt;创建一个新的仓库，命名为&lt;code&gt;username.github.io&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装Jekyll-Bootstrap&lt;br /&gt;
打开终端，切换到你想放置站点的目录，输入一下命令：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ git clone https://github.com/plusjade/jekyll-bootstrap.git username.github.io
 $ cd username.github.io
 $ git remote set-url origin git@github.com:username/username.github.com.git
 $ git push origin master
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;等待与收获&lt;br /&gt;
等待大约10分钟，你就可以通过browser在&lt;code&gt;http://username.github.com&lt;/code&gt;看到你的站点&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;rakepost-or-page&quot;&gt;使用rake快速创建post or page&lt;/h3&gt;
&lt;p&gt;顺便说一句，&lt;code&gt;rake&lt;/code&gt;工具需要安装，Linux/Ubuntu请使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install rake  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rake&lt;/code&gt;使用之前需要有一个&lt;code&gt;Rakefile&lt;/code&gt;文件，如果你使用&lt;code&gt;JekyllBootstrap&lt;/code&gt;,那你就不用自己创建&lt;code&gt;Rakefile&lt;/code&gt;文件，已经内置;否则，你如果想使用&lt;code&gt;Rake&lt;/code&gt;，可以拷贝一下&lt;code&gt;JekyllBoostrap&lt;/code&gt;里的&lt;code&gt;Rakefile&lt;/code&gt;，或者，自己查阅相关资料按照规则编写（你可以的，嘿嘿）&lt;/p&gt;

&lt;h4 id=&quot;post&quot;&gt;创建一篇post&lt;/h4&gt;
&lt;p&gt;通过&lt;code&gt;rake&lt;/code&gt;很容易创建一篇post&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rake post title=&quot;Hello World&quot;  
Creating new post: ./_posts/2014-08-14-hello-world.md  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rake&lt;/code&gt;会帮你格式化名字并添加日期(当前时间) &lt;br /&gt;
并且post中自动添加YAML头信息，太方便了&lt;br /&gt;
&lt;code&gt;rake&lt;/code&gt;不会覆盖原有文件，除非你让它那么做&lt;/p&gt;

&lt;h4 id=&quot;page&quot;&gt;创建一个page&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在根目录创建&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ rake page name=&quot;about.md&quot;
  Creating new page: ./about.md  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个内嵌&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ rake page name=&quot;pages/about.md&quot;
  Creating new page: ./pages/about.md  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个”漂亮”的路径&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ rake page name=&quot;pages/about.md
  Creating new page: ./pages/about/index.html&quot;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三种方式的区别在于browser呈现的路径的不同,自己尝试吧&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;发布你的站点&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git add .
$ git commit -m &quot;add new content&quot;
$ git push origin master  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，新的内容已经在你的github项目，享受新的变化吧&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;自定义&lt;/h4&gt;
&lt;p&gt;Jekyll-Bootstrap可以根据喜好自我定义&lt;br /&gt;
主题可以更换，也可以自己写；配置根据喜好自己修改&lt;br /&gt;
具体请参考&lt;a href=&quot;http://jekyllbootstrap.com/usage/jekyll-quick-start.html&quot; title=&quot;Jekyll-Bootstrap快速开始&quot;&gt;Jekyll-Bootstrap快速开始&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;说些什么&lt;/h3&gt;
&lt;p&gt;其实这篇文章也算是一篇简单的译文吧&lt;br /&gt;
不管如何，看完基本能懂得怎么安装，使用Jekyll-Bootstrap就可以了&lt;br /&gt;
至于深入用法和配置，请参考&lt;a href=&quot;http://jekyllbootstrap.com&quot; title=&quot;Jekyll-Bootstrap官方网站&quot;&gt;Jekyll-Bootstrap官方网站&lt;/a&gt;&lt;br /&gt;
单词和句型都很简单(就连我四级都没过的人都看的懂)，你一定可以的，嘿嘿&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/website-by-using-jekyllboostrap</link>
                <guid>http://mwumli.github.io/website-by-using-jekyllboostrap</guid>
                <pubDate>2014-08-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用jekyll搭建静态站点</title>
                <description>
&lt;h3 id=&quot;jekyll&quot;&gt;Jekyll的安装&lt;/h3&gt;

&lt;p&gt;假如系统未曾安装gem,请使用以下命令安装:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install ruby1.9.1-full
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装ruby(1.9.3)的时候，会同时安装gem1.8.23&lt;/p&gt;

&lt;p&gt;使用gem安装jekyll:&lt;code&gt; sudo gem install jekyll&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;假如报错的话，请安装ruby1.9.1的编译扩展组件的头文件:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install ruby1.9.1-dev    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本安装已经完成了，但是你执行&lt;code&gt;jekyll new myblog&lt;/code&gt;时，可能会报&lt;code&gt;Could not find a JavaScript runtime&lt;/code&gt;这样的错误，你需要使用一下命令解决：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install nodejs  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;jekyll-1&quot;&gt;Jekyll的使用&lt;/h3&gt;

&lt;p&gt;一个获取最简单 Jekyll 模板并生成静态站点的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll new myblog
New jekyll site installed in /home/temp/myblog.  
$ cd myblog
$ ls
about.md     css/      _includes/  _layouts/  _sass/
_config.yml  feed.xml  index.html  _posts/
$ jekyll serve
Configuration file: /home/temp/myblog/_config.yml
	    Source: /home/temp/myblog
       Destination: /home/temp/myblog/_site
      Generating... 
                	    done.
 Auto-regeneration: disabled. Use --watch to enable.
Configuration file: /home/temp/myblog/_config.yml
    Server address: http://0.0.0.0:4000/
  Server running... press ctrl-c to stop.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well,你可以browse to http://localhost:4000&lt;/p&gt;

&lt;p&gt;就是这么简单。从现在开始，你可以通过创建文章、改变头信息来控制模板和输出、修改 Jekyll 设置来使你的站点变得更有趣～&lt;/p&gt;

&lt;h4 id=&quot;jekyll-2&quot;&gt;运行jekyll开发服务器&lt;/h4&gt;

&lt;p&gt;jekyll使用一下命令，将会运行一个服务器，用来在本地查看你的静态站点&lt;br /&gt;
类似于在本地搭建的apache服务器，命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll serve  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个开发服务器将会在&lt;code&gt;http://localhost:4000&lt;/code&gt;运行&lt;/p&gt;

&lt;p&gt;假如你想脱离终端在后台运行,请使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll serve --detach
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想关闭服务器，可以使用&lt;code&gt;kill -9 PID&lt;/code&gt;命令&lt;br /&gt;
如果你找不到进程号，那么就用&lt;code&gt;ps aux | grep jekyll&lt;/code&gt;命令来查看，然后关闭服务器。&lt;/p&gt;

&lt;p&gt;如果你想查看变更并且自动再生成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll serve --watch 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;jekyll-3&quot;&gt;Jekyll的配置&lt;/h3&gt;

&lt;h4 id=&quot;rdiscountmd&quot;&gt;使用RDiscount来渲染md文档&lt;/h4&gt;

&lt;p&gt;如果你希望使用RDiscount来渲染markdown,而不是Maruku,只要确保RDiscount被正确的安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo gem install rdiscount  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行 Jekyll，并使用以下的参数选项：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll --rdiscount  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以在你的_config.yml中写入代码，从而不必指定参数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;markdown: rdiscount  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;pygments&quot;&gt;Pygments来实现代码高亮&lt;/h4&gt;

&lt;p&gt;如果你是一个程序员，那么你一定希望你的文章中代码高亮&lt;br /&gt;
不错，已经有好的解决办法了：通过 highlight 标签实现代码高亮&lt;br /&gt;
但在此之前，你需要首先安装 Pygments&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install python-pygments  
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;highlight&quot;&gt;在文章中引用highlight标签&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用pygmentize生成高亮CSS文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ pygmentize -f html -S default &amp;gt; pygments.css  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把生成的pygments.css移到你的css文件夹里，在post模板里引用一下&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改配置文件_config.xml,添加： &lt;code&gt;highlighter: pygments&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用格式如下:  &lt;br /&gt;
&lt;img src=&quot;/assets/imgs/heligher_demo.png&quot; alt=&quot;helighter_demo&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中&lt;code&gt;language&lt;/code&gt;可以从&lt;a href=&quot;http://pygments.org/docs/lexers/&quot; title=&quot;pygments语法高亮&quot;&gt;Syntax highlighter&lt;/a&gt;获取&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/static-website-by-jekyll</link>
                <guid>http://mwumli.github.io/static-website-by-jekyll</guid>
                <pubDate>2014-08-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>为你和你的项目建立一个站点--Github Pages</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#github-pages&quot; id=&quot;markdown-toc-github-pages&quot;&gt;什么是GitHub Pages?&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;两种站点服务&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;好处不言而喻&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;建站开始&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#user-or-organization-site&quot; id=&quot;markdown-toc-user-or-organization-site&quot;&gt;User or organization Site&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#githubrepository&quot; id=&quot;markdown-toc-githubrepository&quot;&gt;&lt;a href=&quot;https://github.com/new&quot; title=&quot;新建一个GitHub仓库&quot;&gt;创建一个仓库&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#git&quot; id=&quot;markdown-toc-git&quot;&gt;选择你正在使用的git客户端&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#terimal&quot; id=&quot;markdown-toc-terimal&quot;&gt;Terimal(终端)&lt;/a&gt;                &lt;ul&gt;
                  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;克隆刚创建的仓库&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#hello-world&quot; id=&quot;markdown-toc-hello-world&quot;&gt;Hello World&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#pushgithub&quot; id=&quot;markdown-toc-pushgithub&quot;&gt;push你的项目到github&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#github-for-windows-or-mac&quot; id=&quot;markdown-toc-github-for-windows-or-mac&quot;&gt;GitHub for Windows or Mac&lt;/a&gt;                &lt;ul&gt;
                  &lt;li&gt;&lt;a href=&quot;#clone&quot; id=&quot;markdown-toc-clone&quot;&gt;Clone仓库&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#createindexhtml&quot; id=&quot;markdown-toc-createindexhtml&quot;&gt;Create一个index.html文件&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#commit--sync&quot; id=&quot;markdown-toc-commit--sync&quot;&gt;commit &amp;amp;&amp;amp; Sync&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;未知区域&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;浏览你的网站吧&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#project-site&quot; id=&quot;markdown-toc-project-site&quot;&gt;project Site&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#generate-a-site&quot; id=&quot;markdown-toc-generate-a-site&quot;&gt;半路出家(Generate a Site)&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#repository-settings&quot; id=&quot;markdown-toc-repository-settings&quot;&gt;Repository Settings&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#automatic-generator&quot; id=&quot;markdown-toc-automatic-generator&quot;&gt;使用Automatic Generator&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;添加内容&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;选择一个主题&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#start-from-scratch&quot; id=&quot;markdown-toc-start-from-scratch&quot;&gt;白手起家(Start from scratch)&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#ph-pages&quot; id=&quot;markdown-toc-ph-pages&quot;&gt;创建一个ph-pages分支&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;使其成为默认分支&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#indexhtml&quot; id=&quot;markdown-toc-indexhtml&quot;&gt;创建一个index.html&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#hello-world-1&quot; id=&quot;markdown-toc-hello-world-1&quot;&gt;Hello World&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#commit&quot; id=&quot;markdown-toc-commit&quot;&gt;commit文件&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;查看你的项目站点&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;github-pages&quot;&gt;什么是GitHub Pages?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pages.github.com/&quot; title=&quot;GitHub Pages&quot;&gt;Github Pages&lt;/a&gt;是GitHub推出的一个新的服务&lt;br /&gt;
可以用来为你的&lt;a href=&quot;https://pages.github.com/&quot; title=&quot;GitHub 首页&quot;&gt;GitHub&lt;/a&gt;账户和你的每一个托管在&lt;a href=&quot;https://pages.github.com/&quot; title=&quot;GitHub 首页&quot;&gt;GitHub&lt;/a&gt;的项目建立一个web站点,show you and show your projects&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;两种站点服务&lt;/h3&gt;
&lt;p&gt;GitHub提供两种类型的站点服务:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;User or organization Site – 个人或组织站点&lt;/li&gt;
  &lt;li&gt;Project Site – 项目站点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每一个GitHub用户只可以创建一个个人站点，同时，你可以建立多个项目站点&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;好处不言而喻&lt;/h3&gt;
&lt;p&gt;建立个人或组织站点，让更多的人更好的认识你或你的组织&lt;br /&gt;
建立项目站点，你可以可视化的展示你的每一个项目，而不是让你的partner(或者更多喜欢这个项目的人)看着一堆源代码而手足无措&lt;/p&gt;

&lt;p&gt;你可以很轻松建立一个网站(尽管它是static),有专门的主机托管，还可以通过git进行版本控制，那不是很酷吗？&lt;/p&gt;

&lt;p&gt;好了，该做出你的选择了…&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;建站开始&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;user-or-organization-site&quot;&gt;User or organization Site&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;githubrepository&quot;&gt;&lt;a href=&quot;https://github.com/new&quot; title=&quot;新建一个GitHub仓库&quot;&gt;创建一个仓库&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;从&lt;a href=&quot;https://pages.github.com/&quot; title=&quot;GitHub 首页&quot;&gt;GitHub&lt;/a&gt;开始，&lt;a href=&quot;https://github.com/new&quot; title=&quot;新建一个GitHub仓库&quot;&gt;创建&lt;/a&gt;一个名为&lt;strong&gt;username.github.io&lt;/strong&gt;的仓库&lt;br /&gt;
其中,仓库名的第一部分&lt;em&gt;username&lt;/em&gt;是你在GitHub上的用户名(或组织名)&lt;br /&gt;
假如&lt;em&gt;username&lt;/em&gt;和你的用户名不匹配，站点将不能工作，因此，请确保它正确&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/user-repo@2x.png&quot; alt=&quot;在GirHub上新建一个仓库&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;git&quot;&gt;选择你正在使用的git客户端&lt;/h4&gt;

&lt;p&gt;这里讲述三种客户端：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Terimal – 这种经常用在Unix或类Unix系统下(Linux,mac当然也可以)&lt;/li&gt;
  &lt;li&gt;GitHub for Windows – 一看就知道，这是windows下的客户端&lt;/li&gt;
  &lt;li&gt;GitHub for Mac – 这个是Mac下的客户端&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好了，开始咯&lt;/p&gt;

&lt;h5 id=&quot;terimal&quot;&gt;Terimal(终端)&lt;/h5&gt;

&lt;h6 id=&quot;section-3&quot;&gt;克隆刚创建的仓库&lt;/h6&gt;

&lt;p&gt;在terimal下转到你想存放你项目的地方，然后clone这个新的仓库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/username/username.github.io  
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;hello-world&quot;&gt;Hello World&lt;/h6&gt;

&lt;p&gt;进入项目目录，新建一个&lt;em&gt;index.html&lt;/em&gt;,如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd username.github.io
$ echo &quot;Hello World&quot; &amp;gt; index.html  
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;pushgithub&quot;&gt;push你的项目到github&lt;/h6&gt;

&lt;p&gt;添加，提交，推送你对项目做出的改变&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add --all
$ git commit -m &quot;Initial commit&quot;
$ git push
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h5 id=&quot;github-for-windows-or-mac&quot;&gt;GitHub for Windows or Mac&lt;/h5&gt;

&lt;h6 id=&quot;clone&quot;&gt;Clone仓库&lt;/h6&gt;

&lt;p&gt;点击绿色的”Set up in Desktop”按钮&lt;br /&gt;
当GitHub桌面app打开，保存这个项目&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/setup-in-desktop@2x.png&quot; alt=&quot;从GitHub上启动桌面app&quot; /&gt;&lt;br /&gt;
假如app没有启动，那么双击的桌面app启动它，并且在app里克隆你的项目&lt;/p&gt;

&lt;h6 id=&quot;createindexhtml&quot;&gt;Create一个index.html文件&lt;/h6&gt;

&lt;p&gt;使用你最喜欢的编辑器，新建index.html,内容如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;I&#39;m hosted with GitHub Pages.&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，添加到你的项目&lt;/p&gt;

&lt;h6 id=&quot;commit--sync&quot;&gt;commit &amp;amp;&amp;amp; Sync&lt;/h6&gt;

&lt;p&gt;进入你的仓库(app里),commit你的变化，然后按下sync(同步)按钮&lt;br /&gt;
假如你在Windows下：&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/sync-windows@2x.png&quot; alt=&quot;windows提交并同步变化到项目&quot; /&gt;&lt;br /&gt;
假如你在Mac下：&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/sync-mac.png&quot; alt=&quot;Mac提交并同步变化到项目&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-4&quot;&gt;未知区域&lt;/h5&gt;

&lt;p&gt;假如你不知道你的平台，额，我无能为力了&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;浏览你的网站吧&lt;/h4&gt;

&lt;p&gt;启动你的浏览器，输入&lt;em&gt;http://username.github.io&lt;/em&gt;,然后，回车，接着，404，哈哈&lt;br /&gt;
等一下吧，新生成一个网站需要一段时间滴&lt;br /&gt;
时间也不是很长，大概10分钟吧&lt;br /&gt;
未来可能会做的更好，期待吧&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;project-site&quot;&gt;project Site&lt;/h3&gt;

&lt;p&gt;创建项目站点，有两种办法&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Generate a Site&lt;/li&gt;
  &lt;li&gt;Start from scratch&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实际上两者创建了分支gh-pages，只是第一种办法是在当前项目的主分支的当前状态开辟新的分支；第二种则是开辟一个没有父节点的分支&lt;br /&gt;
说的简单点，第一种的gh-pages分支有当前项目的主分支的内容,所以被称为&lt;em&gt;半路出家&lt;/em&gt;；而第二种则没有当前项目主分支的内容，完全像一个新的仓库,所以被称为&lt;em&gt;白手起家&lt;/em&gt;(Start from scratch)&lt;/p&gt;

&lt;h4 id=&quot;generate-a-site&quot;&gt;半路出家(Generate a Site)&lt;/h4&gt;

&lt;h5 id=&quot;repository-settings&quot;&gt;Repository Settings&lt;/h5&gt;

&lt;p&gt;访问&lt;a href=&quot;https://pages.github.com/&quot; title=&quot;GitHub 首页&quot;&gt;GirHub,com&lt;/a&gt;,创建一个新的仓库或者进入一个已存在的仓库&lt;br /&gt;
然后点击右手边的&lt;em&gt;Settings&lt;/em&gt;,进入项目设置页面&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/settings@2x.png&quot; alt=&quot;Repository settings&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;automatic-generator&quot;&gt;使用Automatic Generator&lt;/h5&gt;

&lt;p&gt;滑动settings页面到&lt;em&gt;GitHub Pages&lt;/em&gt;模块&lt;br /&gt;
按下&lt;em&gt;Automatic Page Generator&lt;/em&gt;按钮&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/automatic@2x.png&quot; alt=&quot;Automatic Pages Generator&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-6&quot;&gt;添加内容&lt;/h5&gt;

&lt;p&gt;使用内置编辑器添加内容给你的网站&lt;br /&gt;
假如你已经有了&lt;em&gt;README.md&lt;/em&gt;在你的项目，你可以点击右手边&lt;em&gt;Load README.md&lt;/em&gt;进行导入&lt;br /&gt;
当你做完这些，点击&lt;em&gt;Continue to Layouts&lt;/em&gt;&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/add-content@2x.png&quot; alt=&quot;add content to your project site&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-7&quot;&gt;选择一个主题&lt;/h5&gt;

&lt;p&gt;在顶部的提供主题里，选择一个你喜欢的主题&lt;br /&gt;
当你完成，点击右手边的&lt;em&gt;Publish page&lt;/em&gt;按钮&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/choose-layout@2x.png&quot; alt=&quot;choose a theme&quot; /&gt;&lt;/p&gt;

&lt;p&gt;半路出家搞定&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;start-from-scratch&quot;&gt;白手起家(Start from scratch)&lt;/h4&gt;

&lt;h5 id=&quot;ph-pages&quot;&gt;创建一个ph-pages分支&lt;/h5&gt;

&lt;p&gt;在你的项目页面，点击左手边分支下拉菜单，输入&lt;code&gt;gh-pages&lt;/code&gt;,然后按下enter进行创建&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/create-branch@2x.png&quot; alt=&quot;create gh-pages branch&quot; /&gt;&lt;br /&gt;
这个分支用于发布你的项目站点，你可以随时添加项目的进度等&lt;/p&gt;

&lt;h5 id=&quot;section-8&quot;&gt;使其成为默认分支&lt;/h5&gt;

&lt;p&gt;假如你已经为你的项目创建了新分支&lt;em&gt;gh-pages&lt;/em&gt;&lt;br /&gt;
进入仓库设置界面&lt;br /&gt;
在顶部的模块，改变默认分支为&lt;em&gt;gh-pages&lt;/em&gt;&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/default-branch@2x.png&quot; alt=&quot;change default branch&quot; /&gt;&lt;br /&gt;
这一步并不是必须的，因为此步的意义只是让其看起来更像一个web site project&lt;/p&gt;

&lt;h5 id=&quot;indexhtml&quot;&gt;创建一个index.html&lt;/h5&gt;

&lt;p&gt;返回仓库总览界面，点击紧邻仓库名旁边的plus图标创建一个名为index.html的文件  &lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/create-file@2x.png&quot; alt=&quot;create file&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;hello-world-1&quot;&gt;Hello World&lt;/h5&gt;

&lt;p&gt;为这个index.html文件添加内容&lt;em&gt;Hello world&lt;/em&gt;&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/hello-world@2x.png&quot; alt=&quot;hello-world&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;commit&quot;&gt;commit文件&lt;/h5&gt;

&lt;p&gt;滑动到页面底部，写上提交信息，提交这个新文件&lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/commit-web@2x.png&quot; alt=&quot;commit-web&quot; /&gt;&lt;br /&gt;
呼，打完收工&lt;/p&gt;

&lt;p&gt;对咯，这种办法创建项目站点完全可以在Terimal,GitHub for Windows,还有GitHub for Mac下进行，请自行探索吧&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;查看你的项目站点&lt;/h4&gt;

&lt;p&gt;领年终奖了&lt;br /&gt;
启动你的浏览器，输入&lt;em&gt;http://username.github.io/repository&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;Repository&lt;/em&gt;是你的项目仓库名&lt;br /&gt;
然后，回车，接着，404，额，又被坑了&lt;br /&gt;
等10分钟吧，这么简单创建一个web站点，也不差这点时间对吧?&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/websites-by-github-pages</link>
                <guid>http://mwumli.github.io/websites-by-github-pages</guid>
                <pubDate>2014-08-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>LAMP 环境搭建</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#apache-&quot; id=&quot;markdown-toc-apache-&quot;&gt;apache 服务器&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;重定义工作目录&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;配置文件布局&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#apache2-&quot; id=&quot;markdown-toc-apache2-&quot;&gt;apache2 的启动和停止&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#mysql-&quot; id=&quot;markdown-toc-mysql-&quot;&gt;mysql 数据库&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#mysql--1&quot; id=&quot;markdown-toc-mysql--1&quot;&gt;mysql 服务的启动和停止&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#mysql--mysql-&quot; id=&quot;markdown-toc-mysql--mysql-&quot;&gt;mysql 客户端访问 mysql 服务&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;是否只允许本机访问&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#php&quot; id=&quot;markdown-toc-php&quot;&gt;PHP&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;测试&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#phpmyadmin&quot; id=&quot;markdown-toc-phpmyadmin&quot;&gt;phpMyadmin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在 Linux 搭建一个可运行 php, 并且可以访问 mysql 数据库的服务端环境, 服务器是 Apache&lt;br /&gt;
这就是 &lt;code&gt;LAMP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这里只是讲述了 Ubuntu 下的搭建, 并不包括所有的 Linux 发行版&lt;/p&gt;

&lt;p&gt;Linux 下 php 扩展安装 : &lt;a href=&quot;/php-extension-install/&quot;&gt;请点这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;apache-&quot;&gt;apache 服务器&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;安装&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install apache2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成，访问 &lt;code&gt;http://localhost&lt;/code&gt;&lt;br /&gt;
如果出现&lt;code&gt;It works&lt;/code&gt;,安装成功&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;重定义工作目录&lt;/h3&gt;

&lt;p&gt;不同版本的apache，工作目录有点差异&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/etc/apache2/sites-enabled/000-default.conf&lt;/code&gt; 中 &lt;code&gt;DocumentRoot&lt;/code&gt; 后就是 Apache 的工作目录&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重定义工作目录需要&lt;/strong&gt; :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;DocumentRoot /var/www/html&lt;/code&gt; 改为 &lt;code&gt;DocumentRoot /home/ya/LAMP&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加目录权限 :&lt;/p&gt;

 	&amp;lt;Directory /home/ya/LAMP &amp;gt;
    &lt;pre&gt;&lt;code&gt; 	Options Indexes FollowSymLinks
     AllowOverride None
 		Require all granted
 &amp;lt;/Directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;添加的地方有两处，任选一处即可：&lt;br /&gt;
* 刚才修改的那句之后添加&lt;br /&gt;
* 在 &lt;code&gt;/etc/apache2/apache2.conf&lt;/code&gt; 中寻找 &lt;code&gt;Directory&lt;/code&gt; 字眼，在这之后添加&lt;br /&gt;
  (其实也无所谓，只是放着之后，方便管理)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;配置文件布局&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/etc/apache2/
|-- apache2.conf
|
|-- ports.conf
|
|-- mods-enabled/
|   
|-- conf-enabled/
|   
|-- sites-enabled/
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;apache2.conf&lt;/code&gt; 主配置文件&lt;br /&gt;
当web服务器启动时，加载此文件，而此文件包含了其他配置文件&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;ports.conf&lt;/code&gt; 定制监听端口  &lt;br /&gt;
被包含在&lt;code&gt;apache2.conf&lt;/code&gt;,并且可以随时修改&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;mods-enabled/&lt;/code&gt;, &lt;code&gt;conf-enabled/&lt;/code&gt;, &lt;code&gt;sites-enabled/&lt;/code&gt; 下的配置文件分别是用来管理模块，全局配置片段，虚拟主机配置&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;apache2-&quot;&gt;apache2 的启动和停止&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ service apache2 status        # 查看apache2的状态  
$ sudo service apache2 start    # 启动
$ sudo service apache2 stop     # 停止
$ sudo service apache2 restart  # 重新启动
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;mysql-&quot;&gt;mysql 数据库&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;安装&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install mysql-server mysql-client
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时安装了服务端和客户端&lt;/p&gt;

&lt;p&gt;输入下面命令，按提示输入密码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mysql -uroot -p
Enter password: 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装成功，出现下面画面:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 53
Server version: 5.5.37-0ubuntu0.14.04.1 (Ubuntu)

Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.

mysql&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;mysql--1&quot;&gt;mysql 服务的启动和停止&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ service mysql status        # 查看mysql 服务的状态  
$ sudo service mysql start    # 启动
$ sudo service mysql stop     # 停止
$ sudo service mysql restart  # 重新启动
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;mysql--mysql-&quot;&gt;mysql 客户端访问 mysql 服务&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;root 用户, 密码为 hello, 登录 192.168.1.2 上的 mysql 数据库 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; mysql -h 192.167.1.2 -uroot -phello 	
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以 root 用户登录 127.0.0.1(默认), 密码等待输入&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ mysql -uroot -p 
 Enter Password:
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-4&quot;&gt;是否只允许本机访问&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;/etc/mysql/my.cnf&lt;/code&gt; 是 Mysql 的配置文件&lt;/p&gt;

&lt;p&gt;里面有一项 &lt;code&gt;bind-address 127.0.0.1&lt;/code&gt;, 指定 Mysql 数据库默认只允许本地访问数据库&lt;/p&gt;

&lt;p&gt;如果需要其他机器访问，应使用 &lt;code&gt;#&lt;/code&gt; 注释掉 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# bind-address 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;php&quot;&gt;PHP&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;安装&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install php5 php5-dev libapache2-mod-php5 php5-mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;php5&lt;/code&gt; : php 解释器&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;php5-dev&lt;/code&gt; : php5 module 开发的一些文件, 包含了 &lt;code&gt;phpize&lt;/code&gt; 命令&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;libapache2-mod-php5&lt;/code&gt; : Apache2 的 php5 module&lt;br /&gt;
没有或disable,会出现 &lt;code&gt;无法解析php文件，浏览器提示下载所要打开的php文件&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;a2enmod&lt;/code&gt; 和 &lt;code&gt;a2dismod&lt;/code&gt; enable or disable an apache2 module&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;php5-mysql&lt;/code&gt; : Mysql module for php&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;测试&lt;/h3&gt;

&lt;p&gt;在 apache 的工作根目录中新建文件 &lt;code&gt;phpinfo.php&lt;/code&gt; ,内容为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php phpinfo() ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问 &lt;code&gt;http://localhost/phpinfo.php&lt;/code&gt;&lt;br /&gt;
若出现 php 的相关信息，则安装成功&lt;/p&gt;

&lt;h2 id=&quot;phpmyadmin&quot;&gt;phpMyadmin&lt;/h2&gt;

&lt;p&gt;phpMyadmin 是一个基于 Web 的图形化数据库管理软件&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载 : &lt;a href=&quot;http://www.phpmyadmin.net/home_page/&quot;&gt;http://www.phpmyadmin.net/home_page/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解压, 重命名为 &lt;code&gt;phpMyAdmin&lt;/code&gt;, 移动到 apache 工作根目录下&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成配置文件 &lt;code&gt;config.inc.php&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ cd phpMyAdmin
 $ cp config.sample.inc.php config.inc.php
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改 &lt;code&gt;config.inc.php&lt;/code&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;填写 : &lt;code&gt;$cfg[&#39;blowfish_secret&#39;] = &#39;ED34DFGFF&#39;;  // 必须填写,但可以随意填写&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;添加 mysql 访问 : &lt;code&gt;$cfg[&#39;Servers&#39;][$i][&#39;extension&#39;]=&#39;mysql&#39;;&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://mwumli.github.io/lamp-build</link>
                <guid>http://mwumli.github.io/lamp-build</guid>
                <pubDate>2014-06-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Linux文件系统的创建和挂载</title>
                <description>
&lt;h3 id=&quot;section&quot;&gt;如果您想&lt;/h3&gt;
&lt;p&gt;如果您想加载一个分区（文件系统）:&lt;br /&gt;
首先您得确认文件系统的类型，然后才能挂载使用&lt;br /&gt;
比如通过mount 加载，或者通过修改 /etc/fstab来开机自动加载&lt;/p&gt;

&lt;p&gt;如果您想添加一个新的分区或者增加一个新的硬盘:&lt;br /&gt;
您要通过分区工具(&lt;code&gt;fdisk&lt;/code&gt;)来添加分区&lt;br /&gt;
然后要创建分区的文件系统 (&lt;code&gt;mkfs&lt;/code&gt;) 
然后才是挂载文件系统(mount)&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;存储设备的分区&lt;/h3&gt;
&lt;p&gt;存储设备主要是本地硬盘、移动硬盘&lt;br /&gt;
由于磁盘很大并且为了满足我们各种需要，所以把硬盘分成若干个分区&lt;br /&gt;
比如我们可以用这个分区来安装Linux系统，那个分区用来 安装Windows系统…&lt;/p&gt;

&lt;p&gt;Linux中进行硬盘分区操作,可以使用fdisk&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;文件系统&lt;/h3&gt;
&lt;p&gt;对存储设备分区，这个新的分区还不能正常使用，我们需要对其格式化&lt;br /&gt;
即存储设备的格式化就是建立文件系统的过程&lt;/p&gt;

&lt;p&gt;Windows下的文件系统,熟知有NTFS, msdos …
Linux下的文件系统，熟知的有ext2、ext3、swap 交换分区… … &lt;br /&gt;
U盘的文件系统，有FAT32, fat16 … 
还有一些咱们不熟悉的操作系统的文件系统等&lt;/p&gt;

&lt;p&gt;我们通常使用文件系统格式化工具进行&lt;em&gt;文件系统的建立&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;文件系统的建立&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;mkfs&lt;/code&gt;就是Linux下常用的建立文件系统的工具&lt;br /&gt;
&lt;code&gt;mkfs.nefs&lt;/code&gt;, &lt;code&gt;mkfs.vfat&lt;/code&gt;, &lt;code&gt;mkfs.ext2&lt;/code&gt;, &lt;code&gt;mkfs.ext3&lt;/code&gt;, &lt;code&gt;mkfs.ext4&lt;/code&gt;等工具，也是Linux下建立文件系统常用工具&lt;br /&gt;
事实上，&lt;code&gt;mkfs&lt;/code&gt;也是更具提供的格式化文件系统类型参数，来调用这些工具实现指定文件系统的建立&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mkfs&lt;/code&gt;的命令格式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkfs -t 文件系统类型 存储设备 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，查看Linux下所有分区，确定分区的存储设备&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo fdsik -l
Disk /dev/sda: 120.0 GB, 120034123776 bytes
255 heads, 63 sectors/track, 14593 cylinders, total 234441648 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes
Disk identifier: &amp;lt;0x000d9852&amp;gt;	&amp;lt;/0x000d9852&amp;gt;

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1            2048    15624191     7811072   82  Linux swap / Solaris
/dev/sda2   *    15624192   234440703   109408256   83  &amp;lt;Linux&amp;gt;	&amp;lt;/Linux&amp;gt;

Disk /dev/sdb: 500.1 GB, 500107862016 bytes
255 heads, 63 sectors/track, 60801 cylinders, total 976773168 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes
Disk identifier: &amp;lt;0x5be4a3f9&amp;gt;	&amp;lt;/0x5be4a3f9&amp;gt;

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1   *        2048   409602047   204800000    7  HPFS/NTFS/exFAT
/dev/sdb2       409602048   593922047    92160000    7  HPFS/NTFS/exFAT
/dev/sdb3       593922048   778242047    92160000    7  HPFS/NTFS/exFAT
/dev/sdb4       778244094   976771071    99263489    5  Extended
Partition 4 does not start on physical sector boundary.
/dev/sdb5       778244096   797773823     9764864   82  Linux swap / Solaris
/dev/sdb6       797775872   976771071    89497600   83  &amp;lt;Linux&amp;gt;	&amp;lt;/Linux&amp;gt;

Disk /dev/sde: 16.4 GB, 16358768640 bytes
255 heads, 63 sectors/track, 1988 cylinders, total 31950720 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: &amp;lt;0xcad4ebea&amp;gt;	&amp;lt;/0xcad4ebea&amp;gt;

   Device Boot      Start         End      Blocks   Id  System
/dev/sde4   *          63    31950719    15975328+   c  W95 FAT32 (LBA)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/dev/sde4&lt;/code&gt;是我U盘，以此为实验&lt;br /&gt;
接着，为存储设备重新建立文件系统，即格式化一个新的文件系统&lt;br /&gt;
那么，建立ext4文件系统&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo mkfs -t ext4 /dev/sde4  
mke2fs 1.42.9 (4-Feb-2014)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
999424 inodes, 3993832 blocks
199691 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=4093640704
122 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks: 
	32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208
 
Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (32768 blocks): done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样，我们使用下面这条命令，也可以达到一样的效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo mkfs.ext4 /dev/sde4  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;swap&quot;&gt;关于swap分区&lt;/h4&gt;
&lt;p&gt;创建此分区为swap 交换分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkswap /dev/sda6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加载交换分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ swapon /dev/sda6 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭交换分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ swapoff /dev/sda6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看交换分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ swapon -s		或者  
$ cat /proc/swaps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以考虑下下面这种情况:内存不足，swap交换分区爆满,您的硬盘不能再分区&lt;br /&gt;
此时怎么办呢? 你可以创建一个swap文件,并把其当作格式化swap来使用&lt;/p&gt;

&lt;p&gt;创建一个大小为512M 的swap 文件，在/tmp目录中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dd if=/dev/zero of=/tmp/swap bs=1024 count=524288
$ mkswap /tmp/swap
$ swapon /tmp/swap
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;文件系统的挂载&lt;/h3&gt;
&lt;p&gt;当我们需要访问某个文件系统时，必须要进行文件系统的挂载&lt;br /&gt;
挂载文件系统，目前有两种方法:&lt;br /&gt;
1. 通过 mount 来挂载&lt;br /&gt;
2. 通过/etc/fstab文件来开机自动挂载&lt;/p&gt;

&lt;h4 id=&quot;mount-&quot;&gt;通过mount 来挂载磁盘分区（或存储设备）&lt;/h4&gt;
&lt;p&gt;mount的命令格式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mount -t type device dir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;参数说明:&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;-t&lt;/strong&gt; 指定文件系统的类型&lt;br /&gt;
一般的情况下不必指定有时也能识加 &lt;br /&gt;
&lt;code&gt;-t &lt;/code&gt;后面是&lt;code&gt;type&lt;/code&gt;,&lt;code&gt;type&lt;/code&gt;是文件系统类型( ext3 、ext2 、reiserfs、vfat 、ntfs 等)&lt;br /&gt;
如果你忘记了文件系统，&lt;code&gt;type&lt;/code&gt;就是 &lt;code&gt;auto&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;&lt;em&gt;需要注意的是:&lt;/em&gt; mount挂载文件系统,当挂载目录在挂载文件系统之前有文件存在,挂载之后文件消失(实际存在，只是看不见),只能看见当前挂载文件系统下的文件;当然，在卸载后，则会恢复&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;device&lt;/strong&gt; 指存储设备&lt;br /&gt;
比如/dev/hda1， /dev/sda1 ，cdrom 等… &lt;br /&gt;
你可以通过&lt;code&gt;fdisk -l&lt;/code&gt;查看存储设备&lt;br /&gt;
一般的情况下光驱设备是/dev/cdrom ；&lt;br /&gt;
软驱设备是/dev/fd0 ；&lt;br /&gt;
硬盘及移动硬盘以 fdisk -l 的输出为准；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;dir&lt;/strong&gt; 挂载点&lt;br /&gt;
一般是个目录,这个目录通常被使用&lt;code&gt;chmod&lt;/code&gt;改写权限为&lt;code&gt;777&lt;/code&gt;，这样任何用户都能写入了&lt;br /&gt;
假如&lt;code&gt;dir&lt;/code&gt;为空，那么会自动寻找挂载点&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;查看已挂载的分区&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用df&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ df -lh
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用mount&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ mount
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;你也可以通过显示/proc/mounts 或 /etc/mtab 来查看类似信息&lt;/p&gt;

&lt;h4 id=&quot;etcfstab&quot;&gt;通过/etc/fstab文件来开机自动挂载文件系统&lt;/h4&gt;
&lt;p&gt;这个文件中存在的文件系统，是开机自动挂载&lt;br /&gt;
因此，当我们需要开机挂载某些文件系统的话，就直接在此文件后面添加（当然，按照固定格式）&lt;/p&gt;

&lt;p&gt;此文件每条记录的格式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;file system&amp;gt;  &amp;lt;mount point&amp;gt; &amp;lt;type&amp;gt; &amp;lt;options&amp;gt; &amp;lt;dump&amp;gt;  &amp;lt;pass&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;一共6个字段:&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;file system&lt;/code&gt;: 设备名，即文件系统，例如/dev/sda1&lt;br /&gt;
&lt;code&gt;mount point&lt;/code&gt;: 文件系统挂载点&lt;br /&gt;
&lt;code&gt;type&lt;/code&gt;: 文件系统类型&lt;br /&gt;
&lt;code&gt;options&lt;/code&gt;: mount挂载文件时，使用-o指定的选项,具体查阅man手册&lt;br /&gt;
&lt;code&gt;dump&lt;/code&gt;: 文件系统是否需要dump 备份，1是需要，0 是不需要&lt;br /&gt;
&lt;code&gt;pass&lt;/code&gt;: 是否在系统启动时，通过fsck磁盘检测工具来检查文件系统，1是需要，0是不需要，2是跳过&lt;/p&gt;

&lt;p&gt;swap分区在fatab中:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LABEL=SWAP-hda7 swap swap defaults 0 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文件系统为/dev/sdd4,文件系统挂载点为~/mnt,文件系统类型vfat:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/dev/sdd4 ~/mnt vfat defaults 0 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;文件系统的卸载&lt;/h3&gt;
&lt;p&gt;使用umount来卸载&lt;br /&gt;
卸载一个已有文件系统时，指出挂载点或者设备名其中一个就足够了，没有必要&amp;gt; 都指出&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo umount device	或者  
$ sudo umount dir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;需要注意的是:&lt;/em&gt;&lt;br /&gt;
1. 当一个文件系统被卸载之后，作为挂载点的目录下的那些文件会再次出现&lt;br /&gt;
2. 如果您想卸载一个文件系统，而此时进程已打开了该文件系统上的文件，将会出现一个错误消息。&lt;br /&gt;
3. 卸载文件系统之前，您应当确认没有进程正在该文件系统的文件上运行(&lt;code&gt;lsof -w device&lt;/code&gt; 或者 &lt;code&gt;lsof -w dir&lt;/code&gt;再或者&lt;code&gt;lsof -w single_file&lt;/code&gt;)&lt;br /&gt;
4. &lt;code&gt;umount&lt;/code&gt;使用&lt;code&gt;-l&lt;/code&gt;参数进行懒卸载(直接从文件系统树分离文件系统，然后，在文件系统空闲时，清理文件系统附加项)&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;两个比较特殊的文件&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;/dev/null&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  它是空设备，也称为位桶（bit bucket）。
  任何写入它的输出都会被抛弃。
  如果不想让消息以标准输出显示或写入文件，那么可以将消息重定向到位桶。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般用于错误信息或者垃圾信息重定向&lt;br /&gt;
* /dev/zero&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	该设备无穷尽地提供0  
	它可以用于向设备或文件写入字符串0。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般用于初始化某个文件和分区,例如&lt;code&gt;dd if=/dev/zero of=/tmp/heihei&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-8&quot;&gt;相关链接&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://os.51cto.com/art/201012/239233_all.htm&quot; title=&quot;Linux文件系统的安装和卸载&quot;&gt;《Linux文件系统的安装和卸载》&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/l-lpic1-v3-104-1/&quot; title=&quot;学习 Linux，101: 创建分区和文件系统&quot;&gt;《学习 Linux，101: 创建分区和文件系统》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://mwumli.github.io/linux-file-system</link>
                <guid>http://mwumli.github.io/linux-file-system</guid>
                <pubDate>2014-06-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Sublime Text 2 的使用</title>
                <description>
&lt;p&gt;假如你还没安装ST2,那么去&lt;a href=&quot;/记录/2014/06/08/st2_install_config/&quot; title=&quot;Sublime Text 2的安装与配置&quot;&gt;安装它&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;多项选择，多项编辑&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;鼠标选中多行，按下 Ctrl+Shift+L (Command+Shift+L) 即可同时编辑这些行；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;鼠标选中文本，反复按 CTRL+D (Command+D) 即可继续向下同时选中下一个相同的文本进行同时编辑；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;鼠标选中文本，按下 Alt+	F3 (Win) 或 Ctrl+Command+G(Mac) 即可一次性选择全部的相同文本进行同时编辑；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Shift+鼠标右键 (Win) 或 Option+鼠标左键 (Mac) 或使用鼠标中键可以用鼠标进行竖向多行选择；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ctrl+鼠标左键(Win) 或 Command+鼠标左键(Mac) 可以手动选择同时要编辑的多处文本&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;command-palette&quot;&gt;命令行面板(Command Palette)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Ctrl+Shift+P&lt;/strong&gt;唤醒Command Palette　　　
输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sspy	---&amp;gt;set the syntax of the current file to Python
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，还有很多命令，使用过程中慢慢发现吧&lt;/p&gt;

&lt;h2 id=&quot;goto-anything&quot;&gt;快速导航面板(Goto Anything)&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;快速切换文件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Ctrl+p&lt;/strong&gt;唤醒&lt;em&gt;Goto Anything&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;输入文件名，面板下拉框将出现所有匹配的文件名(当然，在这之前必须线打开一个目录作为搜索根目录)&lt;/p&gt;

&lt;p&gt;可以试着在使用Up和Down滚动条目，会有意外的发现哦&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;在指定文件中快速查找函数，文本，跳转指定行&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;查找函数，或者id（HTML）&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  file@func
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查找文本&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  file#text
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;跳转指定行&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  file:num
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当&lt;em&gt;file&lt;/em&gt;省略时，默认当前编辑文件&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;打开一个项目&lt;/h2&gt;
&lt;p&gt;使用ST2可以打开一个项目，这样我们就可以很方便的对一个项目进行编辑，修改了&lt;br /&gt;
打开的项目文件会展示在左侧的&lt;code&gt;side bar&lt;/code&gt;&lt;br /&gt;
当我们编辑某文件时，希望&lt;code&gt;Side bar&lt;/code&gt;在我们需要时候展示，在我们不需要的时候消失，你可以这样做&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ctrl + k Ctrl + b   --&amp;gt;隐藏时显示，显示时隐藏 for Side bar 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，你也可以使用鼠标进行选择，但是那样不可避免降低你的速度&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;模糊匹配&lt;/h2&gt;

&lt;p&gt;无论是Command Palette还是Goto Anything,他们都采用模糊匹配，故不需要输入全命令和全文件名&lt;br /&gt;
例如:在文件shiluodechenai.c中查找func_word&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sldca@fw  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;甚至可能更短&lt;/p&gt;

&lt;h2 id=&quot;package-control&quot;&gt;Package Control(扩展包管理器)&lt;/h2&gt;
&lt;p&gt;用来管理（安装，卸载）插件，皮肤的管理器，和vim中Vundle差不多，不过看起来更简单&lt;br /&gt;
默认不含有此管理器，我们需要自己手动安装&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;安装&lt;/h3&gt;

&lt;h4 id=&quot;section-6&quot;&gt;手动版(复杂点)&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在 SublimeText2 的目录里面找到 &lt;code&gt;Data &amp;gt; Installed Packages&lt;/code&gt; 的文件夹 (如没有请手动新建)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在这里下载 &lt;a href=&quot;http://dl.iplaysoft.com/files/1774.html#download_list&quot;&gt;Package Control.sublime-package&lt;/a&gt; 文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将下载到的文件放进去 Installed Packages 里面&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重新启动 Sublime Text 即可&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-7&quot;&gt;自动版(保持网络，简单)&lt;/h4&gt;

&lt;p&gt;如果你按照上面的方法确实搞不定，&lt;br /&gt;
可以试试按键盘 Ctrl+~ （数字1左边的按键）调出控制台，&lt;br /&gt;
然后拷贝下面的代码进去并回车，  它会自动帮你新建文件夹并下载文件的，与上面的方法最终效果是一样的&lt;br /&gt;
代码如下：　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import urllib2,os; pf=&#39;Package Control.sublime-package&#39;; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),&#39;wb&#39;).write(urllib2.urlopen(&#39;http://sublime.wbond.net/&#39;+pf.replace(&#39; &#39;,&#39;%20&#39;)).read()); print &#39;Please restart Sublime Text to finish installation&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-8&quot;&gt;使用&lt;/h3&gt;

&lt;p&gt;如果 Package Control 已经安装成功，&lt;br /&gt;
那么 Ctrl+Shift+P 调用命令面板，我们就会找到一些以“Package Control:”开头的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Install Package	---&amp;gt;(安装扩展)
 List Packages 		---&amp;gt;(列出全部扩展)
 Remove Package		---&amp;gt;(移除扩展)
 Upgrade Package	---&amp;gt;(升级扩展)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在命令面板输入 “Package Control: Install Package“即会列出全部可以安装的扩展&lt;br /&gt;
从列表可以看到，4GL、AAAPackageDev 那些就是插件的名称  &lt;br /&gt;
选择它们就可以进行下载安装了&lt;/p&gt;

&lt;p&gt;此外，你还可以&lt;a href=&quot;https://sublime.wbond.net/&quot;&gt;在这里看到 Web 版的扩展列表和详细的说明&lt;/a&gt; （这俩列表的数据应该是同步的)&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;一些比较好的插件&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Emmet&lt;/strong&gt;: 以前被称作为Zen Coding,如果你从事Web前端开发的话，对该插件一定不会陌生。&lt;br /&gt;
它使用仿CSS选择器的语法来快速开发HTML和CSS,在一个扩展框中输入符合规范的表达式，它会动态生成相应的代码 ,或者直接在文本中使用表达式，按扩展键(Tab)进行扩展&lt;/p&gt;

&lt;p&gt;具体使用见:&lt;a href=&quot;http://www.w3cplus.com/tools/emmet-cheat-sheet.html&quot;&gt;表达式语法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Gits&lt;/strong&gt;： 可以轻松集成 GitHub&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SFTP&lt;/strong&gt;： 直接编辑 FTP 或 SFTP 服务器上的文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ConvertToUTF8&lt;/strong&gt;： ST2只支持utf8编码，该插件可以显示与编辑 GBK, BIG5, EUC-KR, EUC-JP, Shift_JIS 等编码的文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Clipboard History&lt;/strong&gt;： 剪切板历史&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WordPress&lt;/strong&gt;： 集成一些WordPress的函数，对于像我这种经常要写WP模版和插件的人特别有用！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HtmlTidy&lt;/strong&gt;： 清理与排版你的HTML代码&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PHPTidy&lt;/strong&gt;： 整理与排版PHP代码&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;YUI Compressor&lt;/strong&gt;： 压缩JS和CSS文件&lt;/p&gt;
</description>
                <link>http://mwumli.github.io/st2-some-usage</link>
                <guid>http://mwumli.github.io/st2-some-usage</guid>
                <pubDate>2014-06-08T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Vim 下的 fancy 插件</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;简要声明&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#taglist&quot; id=&quot;markdown-toc-taglist&quot;&gt;TagList&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;简述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vundle&quot; id=&quot;markdown-toc-vundle&quot;&gt;添加到Vundle管理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vimrc&quot; id=&quot;markdown-toc-vimrc&quot;&gt;.vimrc中的一些配置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#echofunc&quot; id=&quot;markdown-toc-echofunc&quot;&gt;echofunc&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;简述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vundle-1&quot; id=&quot;markdown-toc-vundle-1&quot;&gt;添加到Vundle管理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#winmanager&quot; id=&quot;markdown-toc-winmanager&quot;&gt;WinManager&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;简述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vundle-2&quot; id=&quot;markdown-toc-vundle-2&quot;&gt;加入Vundle管理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vimrc-1&quot; id=&quot;markdown-toc-vimrc-1&quot;&gt;.vimrc中的一些配置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#minibufexpl&quot; id=&quot;markdown-toc-minibufexpl&quot;&gt;minibufexpl&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;简述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vundle-3&quot; id=&quot;markdown-toc-vundle-3&quot;&gt;加入Vundle管理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vimrc-2&quot; id=&quot;markdown-toc-vimrc-2&quot;&gt;.vimrc中的一些配置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#minibufexpl-1&quot; id=&quot;markdown-toc-minibufexpl-1&quot;&gt;minibufexpl引发的血案(窗口大小变化)&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#vimrc-3&quot; id=&quot;markdown-toc-vimrc-3&quot;&gt;在.vimrc进行设置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;设置快捷键&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tagsfiles&quot; id=&quot;markdown-toc-tagsfiles&quot;&gt;使用之前的分开显示tags和files的方式&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#powerline&quot; id=&quot;markdown-toc-powerline&quot;&gt;Powerline&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-10&quot; id=&quot;markdown-toc-section-10&quot;&gt;简述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vundle-4&quot; id=&quot;markdown-toc-vundle-4&quot;&gt;添加到Vundle管理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vimrc-4&quot; id=&quot;markdown-toc-vimrc-4&quot;&gt;.vimrc中的一些配置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#themes-and-colorschemes&quot; id=&quot;markdown-toc-themes-and-colorschemes&quot;&gt;Themes and ColorSchemes&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tmuxvim&quot; id=&quot;markdown-toc-tmuxvim&quot;&gt;在tmux中的vim状态栏不颜色并不那么好看？&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#markdown&quot; id=&quot;markdown-toc-markdown&quot;&gt;Markdown&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-11&quot; id=&quot;markdown-toc-section-11&quot;&gt;简述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vundle-5&quot; id=&quot;markdown-toc-vundle-5&quot;&gt;添加到Vundle管理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vimrc-5&quot; id=&quot;markdown-toc-vimrc-5&quot;&gt;.vimrc中的一些配置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-12&quot; id=&quot;markdown-toc-section-12&quot;&gt;一些默认快捷键&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#with-&quot; id=&quot;markdown-toc-with-&quot;&gt;生成目录 with ‘#’&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#fencview&quot; id=&quot;markdown-toc-fencview&quot;&gt;fencview&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-13&quot; id=&quot;markdown-toc-section-13&quot;&gt;简述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vundle-6&quot; id=&quot;markdown-toc-vundle-6&quot;&gt;添加到Vundle管理&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-14&quot; id=&quot;markdown-toc-section-14&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tohtml&quot; id=&quot;markdown-toc-tohtml&quot;&gt;tohtml&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-15&quot; id=&quot;markdown-toc-section-15&quot;&gt;简述&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ubuntu&quot; id=&quot;markdown-toc-ubuntu&quot;&gt;ubuntu下的位置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-16&quot; id=&quot;markdown-toc-section-16&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;简要声明&lt;/h2&gt;

&lt;p&gt;以下介绍的插件的安装，均使用&lt;code&gt;Vundle管理&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;taglist&quot;&gt;TagList&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;简述&lt;/h3&gt;

&lt;p&gt;TagList是一个标签浏览器&lt;br /&gt;
所谓标签，就是那些具有表示意义的标示符，像变量，函数名，宏等&lt;br /&gt;
TagList通过一个简单窗口，展示了当前文件下的所有相关的标签&lt;br /&gt;
&lt;code&gt;PS&lt;/code&gt;: &lt;strong&gt;TagsList依赖于ctags产生的tags文件&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;vundle&quot;&gt;添加到Vundle管理&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Plugin &#39;vim-scripts/taglist.vim&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;vimrc&quot;&gt;.vimrc中的一些配置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;let Tlist_Ctags_Cmd=&#39;ctags&#39;         &quot;taglist依赖于ctags,设置ctags位置
let Tlist_Use_Right_Window=0        &quot;窗口显示:1--右边，0--左边
let Tlist_Show_One_File=1           &quot;显示一个文件:1--是 0--否
let Tlist_File_Fold_Auto_Close=1    &quot;非当前文件，函数列表折叠隐藏
let Tlist_GainFocus_On_ToggleOpen = 1  &quot;打开taglist时，光标保留在taglist窗口
let Tlist_Exit_OnlyWindow=1         &quot;当taglist是最后一个分割窗口时，自动退出vim
let Tlist_Process_File_Always=1     &quot;实时更新tags 1--是　0--否
let Tlist_Inc_Winwidth=0
nmap &amp;lt;leader&amp;gt;tl :Tlist&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;使用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;打开Taglist窗口&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  :Tlist	或者 	使用定义的快捷键 &#39;\+t+l&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;跳跃到某一item定义处&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  选中item，点击&#39;Enter&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;仅仅查看item原型&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  选中要查看的item,点击&#39;Space&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原型结果会显示在Vim命令行&lt;/p&gt;

&lt;h2 id=&quot;echofunc&quot;&gt;echofunc&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;简述&lt;/h3&gt;

&lt;p&gt;echofunc可以帮助我们在插入函数的时候,提示当前输入函数的原型&lt;br /&gt;
提示结果显示在command line里&lt;/p&gt;

&lt;h3 id=&quot;vundle-1&quot;&gt;添加到Vundle管理&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Plugin &#39;mbbill/echofunc&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;使用&lt;/h3&gt;

&lt;p&gt;需要tags文件的支持, 并且在创建tags文件的时候要加选项”–fields=+lS”（OmniCppComplete创建的tag文件也能用）&lt;br /&gt;
整个创建tags文件的命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ctags -R --fields=+lS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你在vim插入(insert)模式下紧接着函数名后输入一个”(“的时候, 这个函数的声明就会自动显示在命令行中。&lt;/p&gt;

&lt;p&gt;如果这个函数有多个声明, 则可以通过按键&lt;em&gt;Alt + -&lt;/em&gt;和&lt;em&gt;Alt + =&lt;/em&gt;向前和向后翻页&lt;br /&gt;
这个两个键可以通过设置&lt;code&gt;g:EchoFuncKeyNext&lt;/code&gt;和&lt;code&gt;g:EchoFuncKeyPrev&lt;/code&gt;参数来修改&lt;/p&gt;

&lt;p&gt;如果你在编译vim时加上了”+balloon_eval”特性&lt;br /&gt;
那么当你把鼠标放在函数名上的时候会有一个tip窗口弹出, 该窗口中也会有函数的声明&lt;/p&gt;

&lt;h2 id=&quot;winmanager&quot;&gt;WinManager&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;简述&lt;/h3&gt;

&lt;p&gt;WinManager是一个窗口管理器 &lt;br /&gt;
在Vim中，通常使用其管理文件浏览器(netrw)和缓冲区(buffer)&lt;br /&gt;
2.0以上的版本还可以管理其他IDE类型插件,不过，需要我们在插件中增加一些辅助变量和hook来支持WinManager&lt;/p&gt;

&lt;p&gt;这里，我们就用WinManager来管理文件浏览器netrw和标签浏览器Taglist。&lt;br /&gt;
netrw是标准的vim插件, 已经随vim一起安装进系统里了, 不需要我们自行下载安装。&lt;br /&gt;
而Taglist我们刚刚已经安装完成了&lt;/p&gt;

&lt;h3 id=&quot;vundle-2&quot;&gt;加入Vundle管理&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Plugin &#39;MwumLi/WinManager&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;vimrc-1&quot;&gt;.vimrc中的一些配置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&quot; 设置我们要管理的插件
let g:winManagerWindowLayout=&#39;FileExplorer|TagList&#39; 	&quot;FileExplorer和TagList同时在左边窗口显示
let g:winManagerWindowLayout=&#39;FileExplorer,TagList&#39; 	&quot;FileExplorer和TagList同时仅有一个在左边窗口显示,使用Ctrl+n/p切换
let g:persistentBehaviour=0 &quot; 如果所有编辑文件都关闭了，退出vim
nmap wm :WMToggle&amp;lt;cr&amp;gt; 	&quot; 打开/关闭WinManager
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;个人觉得&lt;code&gt;let g:winManagerWindowLayout=&#39;FileExplorer,TagList&#39;&lt;/code&gt;看起来比较好点,大气&lt;br /&gt;
虽然&lt;code&gt;let g:winManagerWindowLayout=&#39;FileExplorer|TagList&#39;&lt;/code&gt;可能看起来更像是一个IDE&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;使用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;打开WinMananger&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  &#39;w + m&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;假如采用第二种分开显示tags和files，则按以下方式切换:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  &#39;Ctrl + n&#39; 	---&amp;gt;下一页
  &#39;Ctrl + p&#39; 	---&amp;gt;前一页
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;假如还没有安装minibufexpl(即将安装),则使用一下方式在不同窗口切换:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  &#39;Ctrl + w + w&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;假如安装了minibufexpl,则切换窗口变得很简单:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  &#39;Ctrl + h/j/k/l&#39;  ==  &#39;Ctrl + Arrow left/down/up/right&#39;  //左-下-上-右移动
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;minibufexpl&quot;&gt;minibufexpl&lt;/h2&gt;

&lt;h3 id=&quot;section-7&quot;&gt;简述&lt;/h3&gt;

&lt;p&gt;minibufexpl,一个缓冲区显示器，假如仅仅看它的效果，更像是浏览器的多个标签页&lt;br /&gt;
这个往往在编辑多个文件时显示&lt;/p&gt;

&lt;h3 id=&quot;vundle-3&quot;&gt;加入Vundle管理&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Plugin &#39;vim-scripts/minibufexpl.vim&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;vimrc-2&quot;&gt;.vimrc中的一些配置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;let g:miniBufExplMapWindowNavVim = 1    &quot; 按下Ctrl+h/j/k/l，可以切换到当前窗口的上下左右窗口
let g:miniBufExplMapWindowNavArrows = 1 &quot; 按下Ctrl+箭头，可以切换到当前窗口的上下左右窗口
let g:miniBufExplMapCTabSwitchBufs = 1  &quot;Ubuntu不适用
let g:miniBufExplModSelTarget = 1   &quot; 不要在不可编辑内容的窗口（如TagList窗口）中打开选中的buffer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-8&quot;&gt;使用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&#39;Ctrl + h/j/k/l&#39;	---&amp;gt;左/下/上/右窗口切换
&#39;Ctrl + Arrow&#39;		---&amp;gt;same as &#39;Ctrl + h/j/k/l&#39;
&#39;Tab&#39;				---&amp;gt;缓冲区间切换
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;minibufexpl-1&quot;&gt;minibufexpl引发的血案(窗口大小变化)&lt;/h2&gt;

&lt;p&gt;在这之前，我们一切都感觉很好(真像一个IDE)&lt;br /&gt;
但是在安装了minibufexpl后，我们的美好感觉破灭了(毕竟还不是IDE)&lt;br /&gt;
文件浏览器的窗口显得异常小，在打开多个文件时，更小，哎，愁…&lt;br /&gt;
还好，有解决办法，不过都不是很完美  a&lt;/p&gt;

&lt;h3 id=&quot;vimrc-3&quot;&gt;在.vimrc进行设置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;let g:bufExplorerMaxHeight=30
let g:miniBufExplorerMoreThanOne=0 这样倒是可以解决问题，但是也引来一些新的问题(至于什么，你试试呗),所以果断启用  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-9&quot;&gt;设置快捷键&lt;/h3&gt;

&lt;p&gt;对WinManager设置快捷键,比如&lt;code&gt;nmap wm :WMToggle&amp;lt;cr&amp;gt;&lt;/code&gt;&lt;br /&gt;
然后，我们只要在文件浏览器变小的时候，按动&lt;em&gt;两次wm&lt;/em&gt;即可(先关闭，在开启)&lt;br /&gt;
这个方法还是可以接收的&lt;/p&gt;

&lt;h3 id=&quot;tagsfiles&quot;&gt;使用之前的分开显示tags和files的方式&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;powerline&quot;&gt;Powerline&lt;/h2&gt;

&lt;h3 id=&quot;section-10&quot;&gt;简述&lt;/h3&gt;

&lt;p&gt;Powerline,一个终极Vim状态栏工具&lt;/p&gt;

&lt;h3 id=&quot;vundle-4&quot;&gt;添加到Vundle管理&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Plugin &#39;Lokaltog/vim-powerline&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;vimrc-4&quot;&gt;.vimrc中的一些配置&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;$HOME/.vimrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set laststatus=2    &quot;一直展示两行状态
set t_Co=256        &quot;告诉vim这个终端支持256色
let g:Powerline_symbols = &#39;unicode&#39;
set encoding=utf8
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;themes-and-colorschemes&quot;&gt;Themes and ColorSchemes&lt;/h3&gt;

&lt;p&gt;主题在目录&lt;code&gt;autoload/Powerline/Themes&lt;/code&gt;下,配色在&lt;code&gt;autoload/Powerline/Colorschemes&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;tmuxvim&quot;&gt;在tmux中的vim状态栏不颜色并不那么好看？&lt;/h3&gt;

&lt;p&gt;确保你在.tmux.conf中启用了256color:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set -g default-terminal &quot;screen-256color&quot; 确保你在.vimrc中启用了终端256color:  

set t_Co=256  
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;markdown&quot;&gt;Markdown&lt;/h2&gt;

&lt;h3 id=&quot;section-11&quot;&gt;简述&lt;/h3&gt;

&lt;p&gt;为vim下.md文件设置语法高亮，规则匹配,方便md文档的撰写&lt;/p&gt;

&lt;h3 id=&quot;vundle-5&quot;&gt;添加到Vundle管理&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Plugin &#39;plasticboy/vim-markdown&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;vimrc-5&quot;&gt;.vimrc中的一些配置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;let g:vim_markdown_folding_disabled=1  			&quot;禁用折叠
let g:vim_markdown_initial_foldlevel=1
&quot;let g:vim_markdown_no_default_key_mappings=1   &quot;禁用默认键
&quot;对文件名后缀为md,mdown,mkd,mkdn,markdown,mdwn的文件，使用markdown语法
au BufRead,BufNewFile *.{md,mdown,mkd,mkdn,markdown,mdwn} set filetype=mkd
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-12&quot;&gt;一些默认快捷键&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;]]&lt;/code&gt;: go to next header. &lt;code&gt;&amp;lt;Plug&amp;gt;(Markdown_MoveToNextHeader)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;[[&lt;/code&gt;: go to previous header. Contrast with &lt;code&gt;]c&lt;/code&gt;. &lt;code&gt;&amp;lt;Plug&amp;gt;(Markdown_MoveToPreviousHeader)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;][&lt;/code&gt;: go to next sibling header if any. &lt;code&gt;&amp;lt;Plug&amp;gt;(Markdown_MoveToNextSiblingHeader)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;[]&lt;/code&gt;: go to previous sibling header if any. &lt;code&gt;&amp;lt;Plug&amp;gt;(Markdown_MoveToPreviousSiblingHeader)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;]c&lt;/code&gt;: go to Current header. &lt;code&gt;&amp;lt;Plug&amp;gt;(Markdown_MoveToCurHeader)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;]u&lt;/code&gt;: go to parent header (Up). &lt;code&gt;&amp;lt;Plug&amp;gt;(Markdown_MoveToParentHeader)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;with-&quot;&gt;生成目录 with ‘#’&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;:Toc 	---&amp;gt;创建一个快速垂直窗口显示文档目录  
:Toch	---&amp;gt;创建一个快速水平窗口显示文档目录  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hit &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt; on a line to jump to the corresponding line of the markdown file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:Toch	---&amp;gt;Same as `:Toc` but in an horizontal window.
:Toct	---&amp;gt;Same as `:Toc` but in a new tab.
:Tocv	---&amp;gt;Same as `:Toc` for symmetry with `:Toch` and `Tocv`.   
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;fencview&quot;&gt;fencview&lt;/h2&gt;

&lt;h3 id=&quot;section-13&quot;&gt;简述&lt;/h3&gt;

&lt;p&gt;不同系统，不同平台下，文件编码往往不太一样&lt;br /&gt;
故在一个系统下为gb2312的文件，放在另一个系统下以utf-8的方式打开,往往会产生乱码&lt;br /&gt;
好了，我(fencview)来了,fencview应运而生&lt;/p&gt;

&lt;h3 id=&quot;vundle-6&quot;&gt;添加到Vundle管理&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Plugin `Mwumli/fencview`  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-14&quot;&gt;使用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;自动探测文件编码，以合适的编码方式显示&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  :FencAutoDetect
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;打开编码列表窗口,选择合适编码，重新加载文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  :Fencview
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tohtml&quot;&gt;tohtml&lt;/h2&gt;

&lt;h3 id=&quot;section-15&quot;&gt;简述&lt;/h3&gt;

&lt;p&gt;我们往往需要把我们的代码展示给别人看，但是直接copy代码，可能查看效果并不如意&lt;br /&gt;
现在有这么一个插件，可以把你的代码转化成html,并且如在你的vim中格式那样显示(&lt;em&gt;代码高亮&lt;/em&gt;)&lt;br /&gt;
当然，此插件不仅仅可以转化代码，还可以转化其他文字&lt;br /&gt;
不过对于程序员来说，此功能就已足够&lt;/p&gt;

&lt;p&gt;此插件已经内置在vim的最新版本，故不需要手动安装&lt;/p&gt;

&lt;h3 id=&quot;ubuntu&quot;&gt;ubuntu下的位置&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/usr/share/vim/vim74/autoload/tohtml.vim  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-16&quot;&gt;使用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;转化整片文章成html&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  :TOhtml    工作目录下会生成以文件名为前缀，以html为后缀的文件  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;转化指定行成html&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  :num1,num2TOhtml   把此篇文章的num1到num2行的文本转化成html文件  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;假如此前vim显示行号，生成的html文件中也显示行号&lt;/strong&gt;&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/vim-some-plugins</link>
                <guid>http://mwumli.github.io/vim-some-plugins</guid>
                <pubDate>2014-06-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Vim的一些操作</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#vim&quot; id=&quot;markdown-toc-vim&quot;&gt;vim编程常用命令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;常用命令&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;快速查找单词&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;撤销和反撤销&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;相关帮助文档&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vim-1&quot; id=&quot;markdown-toc-vim-1&quot;&gt;Vim中文文档&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;缩进设置&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#vimrc&quot; id=&quot;markdown-toc-vimrc&quot;&gt;.vimrc选项&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tab&quot; id=&quot;markdown-toc-tab&quot;&gt;根据文件类型来设置 tab：&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tab-1&quot; id=&quot;markdown-toc-tab-1&quot;&gt;用特殊符号设置tab制表符&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;　折叠&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;6种方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;常见设置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;常用快捷键&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vim-2&quot; id=&quot;markdown-toc-vim-2&quot;&gt;vim加密文件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vim-3&quot; id=&quot;markdown-toc-vim-3&quot;&gt;Vim的多文件操作&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vim-4&quot; id=&quot;markdown-toc-vim-4&quot;&gt;vim的多窗口操作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;vim&quot;&gt;vim编程常用命令&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;常用命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;%  		| 	跳转到配对的括号去
[[ 		| 	跳转到代码块的开头去
gD 		| 	跳转到局部变量定义处  
gg 		| 	跳转到文件开始位置
G  		| 	跳转到文件结束位置  
mx 		| 	设置书签，x只能是[a---z]的26个字母
`x 		| 	跳转到书签处(`是１旁边的键)
&amp;gt;  		| 	增加缩进，&quot;x&amp;gt;&quot;表示增加以下x行的缩进
&amp;lt;  		| 	减少缩进，&quot;x&amp;gt;&quot;表示减少以下x行的缩进
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;快速查找单词&lt;/h3&gt;

&lt;p&gt;当光标移动到相应单词，按下 &lt;code&gt;shift + #&lt;/code&gt;, 就会在文件中快速查找改单词&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;撤销和反撤销&lt;/h3&gt;

&lt;p&gt;按下 &lt;code&gt;u&lt;/code&gt; 撤销上一步保存的操作&lt;/p&gt;

&lt;p&gt;按下 &lt;code&gt;ctrl + r&lt;/code&gt; 回退上一步撤销的操作&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;相关帮助文档&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;:help usr_29
:help usr_30
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;vim-1&quot;&gt;Vim中文文档&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;vim中文文档不会覆盖原英文文档，安装后vim默认使用中文文档。若想使用英文文档，可在vim中执行以下命令：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; set helplang=en
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;同理，使用以下命令可重新使用中文文档：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; set helplang=cn
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;帮助文件的文本是utf-8编码的, 如果想用vim直接查看, 需要在~/.vimrc中设置:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; set encoding=utf-8
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-4&quot;&gt;缩进设置&lt;/h2&gt;

&lt;h4 id=&quot;vimrc&quot;&gt;.vimrc选项&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;set tabstop=4
set softtabstop=4
set shiftwidth=4
set noexpandtab / expandtab
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;做一些说明&lt;/strong&gt;:&lt;br /&gt;
其中 &lt;code&gt;tabstop&lt;/code&gt; 表示一个 &lt;code&gt;tab&lt;/code&gt; 显示出来是多少个空格的长度，默认 8&lt;/p&gt;

&lt;p&gt;&lt;code&gt;softtabstop&lt;/code&gt; 表示在编辑模式的时候按退格键的时候退回缩进的长度，当使用 &lt;code&gt;expandtab&lt;/code&gt; 时特别有用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shiftwidth&lt;/code&gt; 表示每一级缩进的长度，一般设置成跟 &lt;code&gt;softtabstop&lt;/code&gt; 一样&lt;/p&gt;

&lt;p&gt;当设置成 &lt;code&gt;expandtab&lt;/code&gt; 时，缩进用空格来表示，&lt;code&gt;noexpandtab&lt;/code&gt; 则是用制表符表示一个缩进。&lt;/p&gt;

&lt;h4 id=&quot;tab&quot;&gt;根据文件类型来设置 tab：&lt;/h4&gt;

&lt;p&gt;有些时候想为某些类型的文件设置不同的 tab 表现&lt;br /&gt;
如 python 用四个空格来表示一个缩进，javascript 约定也是用四个空格来表示缩进&lt;br /&gt;
而 HTML 和 CSS 则喜欢用 tab 制表符来缩进，那么可以做如下设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if has(&quot;autocmd&quot;)
    autocmd FileType javascript setlocal ts=4 sts=4 sw=4 expandtab
	autocmd FileType python setlocal ts=4 sts=4 sw=4 expandtab
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样当开打的文件是 .js .py 的，都会用四个空格来缩进&lt;/p&gt;

&lt;h4 id=&quot;tab-1&quot;&gt;用特殊符号设置tab制表符&lt;/h4&gt;

&lt;p&gt;在 Vim 中可以用特殊的符号来表示一个 tab 制表符，这样 tab 制表符和空格就可以很容易的区分看来了&lt;br /&gt;
在.vimrc加入这些就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set list
set listchars=tab:▸\ ,eol:¬
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;　折叠&lt;/h2&gt;

&lt;h4 id=&quot;section-6&quot;&gt;6种方法&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;manual	---	手工定义折叠  
indent	---	更多的缩进表示更高级别的折叠
expr	---	用表达式来定义折叠
syntax	---	用语法高亮来定义折叠
diff	---	对没有更改的文本进行折叠
marker	---	对文中的标志折叠
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，每一种折叠方式不兼容，当前时刻，有且只能使用一种&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;常见设置&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;设置折叠方法&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; set foldmethod=syntax	//其他几种也可以
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置折叠级别&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; set foldlevel=num
 num为0时，所有的折叠关闭  
 num为正数时，一些折叠关闭
 num很大时，所有的折叠打开
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置折叠栏宽度&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; set foldcolumn=num
 num的取值[0----12]
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一个打开的折叠由一栏来表示，顶端是’-‘,其下方是’|’,这栏在折叠结束的地方结束&lt;br /&gt;
一个关闭的折叠由’+’表示&lt;br /&gt;
折叠栏太窄而不能显示所有折叠时，显示一数字来表示嵌套的级别&lt;br /&gt;
当设置&lt;code&gt;set mouse=a&lt;/code&gt;时,在折叠栏点击鼠标，可以打开和关闭折叠&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;光标所在，自动打开折叠&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; set foldopen=all  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;光标移开，自动关闭折叠&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; set foldclose=all
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-8&quot;&gt;常用快捷键&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;za  打开/关闭在光标下的折叠
zA  循环地打开/关闭光标下的折叠
zo  打开 (open) 在光标下的折叠
zO  循环打开 (Open) 光标下的折叠
zc  关闭 (close) 在光标下的折叠
zC  循环关闭 (Close) 在光标下的所有折叠
zM  关闭所有折叠
zR  打开所有的折叠
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;vim-2&quot;&gt;vim加密文件&lt;/h2&gt;

&lt;p&gt;Command mode下使用:X命令为文件设定一个密码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:X
Enter encryption key: ******
Enter same key again: ******
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要取消加密，可以设置密码为空&lt;br /&gt;
可以禁用交换文件，以免泄密&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim -x -n file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你已在经编辑这个文件了，那么交换文件可以用下面的命令禁止:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:setlocal noswapfile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于没了交换文件，文件复原就不可能了。为了避免失去编辑的成果，要比平时更勤快地存盘你的文件&lt;/p&gt;

&lt;p&gt;现在你可以像平时一样编辑这个文件并把你所有的秘密放进去。当你编完文件要退出 Vim 时，这个文件就被加密存盘了&lt;br /&gt;
当你下次用 Vim 编辑这个文件时，它就会询问你密码&lt;/p&gt;

&lt;p&gt;如果你试图用另一个程序来阅读这个文件，你将读到一堆垃圾。如果你用 Vim 来编辑这个文件，但输入了错误的密码，你也只能得到垃圾.&lt;br /&gt;
Vim 并不具备检验密码正确性的机制 (这一点使得破译密码更为困难)&lt;/p&gt;

&lt;h2 id=&quot;vim-3&quot;&gt;Vim的多文件操作&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;打开file1, file2, file3 …&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ vim file1 file2 file3
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文件之间的跳转&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; :n	跳转到下一个文件
 :N	跳转到上一个文件
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;列出目前这个vim打开的所有文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; :files
 1 %a   &quot;a.v&quot;                          line 1
 2      &quot;cvim_use.md&quot;                  line 0
 3      &quot;test.md&quot;                      line 0
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一次退出，全部退出编辑&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; :q
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;vim-4&quot;&gt;vim的多窗口操作&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;分割窗口&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  :sp [file]
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;[ ]&lt;/code&gt;代表可选，file是可选的&lt;br /&gt;
若是不输入file，则分割后的创建窗口显示当前窗口文件&lt;br /&gt;
若是输入file,则分割后的窗口打开文件file&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;切换窗口&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  [Ctrl]+[w]+[j] == [Ctrl]+[w]+[ArrowDown]	跳转到当前窗口下方的窗口
  [Ctrl]+[w]+[k] == [Ctrl]+[w]+[ArrowUp]	跳转到当前窗口上方的窗口
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://mwumli.github.io/vim-some-operations</link>
                <guid>http://mwumli.github.io/vim-some-operations</guid>
                <pubDate>2014-06-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>ctags 在 Vim 中的使用</title>
                <description>
&lt;h2 id=&quot;ctags&quot;&gt;Ctags&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;简述&lt;/h3&gt;

&lt;p&gt;Ctags,为源码建立标签文件&lt;code&gt;tags&lt;/code&gt; ,以帮助在源文件中定位 &lt;br /&gt;
vim往往可以通过其他插件实现函数，变量等的查找，或者实现源码间切换&lt;br /&gt;
而这些插件依赖于&lt;code&gt;tags&lt;/code&gt;文件&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;安装&lt;/h3&gt;

&lt;p&gt;Ubuntu上可以通过一下命令安装:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install ctags  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他平台，待续&lt;/p&gt;

&lt;h3 id=&quot;tags&quot;&gt;tags中对象列表&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;用#define定义的宏  
枚举型变量的值  
函数的定义、原型和声明  
名字空间(namespace)  
变量(包括定义和声明)  
类(class)、结构(struct)、枚举类型(enum)和联合(union)  
类、结构和联合中成员变量或函数  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;tags-1&quot;&gt;用参数生成我们需要的tags文件　　&lt;/h3&gt;

&lt;p&gt;具体详细的参数，就不再写了，直接使用下面这条略显完备commmand:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ctags -R -c++-kinds=+px --fields=+ialS --extra=+q
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;每个参数解释如下:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-R		|		ctags递归生成子目录的tags（在项目的根目录下很有意义）  
-c++-kinds=+px	|	ctags记录c++文件中的函数声明,各种外部和前向声明  
--fields=+ials	|	ctags要求描述的信息，其中：　　
	i	--&amp;gt;表示如果有继承，则表示出父类  
	a	--&amp;gt;表示如果元素是类成员的话，要标明其调用权限(即public或者private)  
	l	--&amp;gt;表示包含标记源文件的语言  
	S	--&amp;gt;表示函数的签名(即函数原型或者参数列表)  
--extra=+q		|	强制要求ctags做如下操作:  
	如果某个语法元素是类的一个成员，ctags默认会给其记录一行，
	以要求ctags对同一个语法元素再记一行，这样可以保证在VIM中多个同名函数可以通过路径不同来区分。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;插件和使用&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;很多插件依赖于tags文件,例如omnicppcomplete,tagslist,echofunc&lt;br /&gt;
关于这些插件的安装，可以查看之前的&lt;a href=&quot;/记录/2014/06/02/vim-some-plugins/&quot; title=&quot;Vim下的fancy的插件&quot;&gt;《Vim下的fancy的插件》&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Vim中的简单使用&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Ctrl + ]		|		cursor移动到某个元素,按下此组合键,就会跳转到对应定义  
 Ctrl + o		|		按下此组合键，即可返回原来的地方  
 g + d			|		cursor在局部变量出，按下此组合键,就会跳转到局域变量定义处  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://mwumli.github.io/ctags</link>
                <guid>http://mwumli.github.io/ctags</guid>
                <pubDate>2014-06-02T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用 Vundle 对 Vim 插件进行管理及安装</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#github&quot; id=&quot;markdown-toc-github&quot;&gt;Github地址&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vundle-&quot; id=&quot;markdown-toc-vundle-&quot;&gt;Vundle 的安装&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vundle--vimrc-&quot; id=&quot;markdown-toc-vundle--vimrc-&quot;&gt;Vundle 在 .vimrc 的配置&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vim--vundle-&quot; id=&quot;markdown-toc-vim--vundle-&quot;&gt;将 Vim 插件纳入 Vundle 的管理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vundle--1&quot; id=&quot;markdown-toc-vundle--1&quot;&gt;使用 Vundle 安装插件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vundle--2&quot; id=&quot;markdown-toc-vundle--2&quot;&gt;Vundle 的其他操作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vundle – Vim 的一个强大的管理插件的插件 &lt;br /&gt;
可以很方便地管理 Vim 其他插件的安装、卸载和禁用&lt;/p&gt;

&lt;p&gt;用起来很简单, 只需要一丁点的配置&lt;/p&gt;

&lt;h2 id=&quot;github&quot;&gt;Github地址&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;https://github.com/gmarik/vundle.git 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;vundle-&quot;&gt;Vundle 的安装&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;vundle--vimrc-&quot;&gt;Vundle 在 .vimrc 的配置&lt;/h2&gt;

&lt;p&gt;把下面这些放在你的 &lt;code&gt;.vimrc&lt;/code&gt; 中去使用 &lt;code&gt;Vundle&lt;/code&gt;&lt;br /&gt;
移除下面不必要的插件，他们仅仅是为了演示效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set nocompatible              &quot; be iMproved, required
filetype off                  &quot; required

&quot; set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
&quot; alternatively, pass a path where Vundle should install plugins
&quot;call vundle#begin(&#39;~/some/path/here&#39;)
&quot;所有的插件管理必须被添加在以上这行之后

&quot; let Vundle manage Vundle, required
Plugin &#39;gmarik/Vundle.vim&#39;

&quot; Powerline---&amp;gt;The ultimate vim statusline utility  
&quot; https://github.com/Lokaltog/vim-powerline
Plugin &#39;Lokaltog/vim-powerline

&quot; Markdown--Syntax highlighting, matching rules and mappings for .md file
&quot; https://github.com/plasticboy/vim-markdown/
Plugin &#39;plasticboy/vim-markdown&#39;

&quot; echofunc---&amp;gt;automatically display function 
&quot; https://github.com/mbbill/echofunc 
Plugin &#39;mbbill/echofunc&#39;

&quot; taglist---&amp;gt; 列出当前文件中所有标签(宏，全局变量，函数名) 
&quot; https://github.com/vim-scripts/taglist.vim 
Plugin &#39;vim-scripts/taglist.vim&#39;  

&quot; 所有的插件必须被添加在以下这行之前
call vundle#end()            &quot; required
filetype plugin indent on    &quot; required
&quot; To ignore plugin indent changes, instead use:
&quot;filetype plugin on
&quot;
&quot;
&quot; see :h vundle for more details or wiki for FAQ
&quot; Put your non-Plugin stuff after this line
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;vim--vundle-&quot;&gt;将 Vim 插件纳入 Vundle 的管理&lt;/h2&gt;

&lt;p&gt;有 4 种方式, 下面一一列举 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;指定 Github 中用户仓库的插件，使用“用户名/插件名称”的方式指定&lt;br /&gt;
插件名中的空格使用“-”代替&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Plugin &#39;tpope/vim-fugitive&#39;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;插件名中的空格使用“-”代替&lt;br /&gt;
 当插件位于仓库的某一子目录时，需用rtp指定子目录&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Plugin &#39;rstacruz/sparkup&#39;, {&#39;rtp&#39;: &#39;vim/&#39;}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定 Github 中 &lt;a href=&quot;http://vim-scripts.org/vim/scripts.html&quot;&gt;vim-scripts 仓库&lt;/a&gt;的插件
直接指定插件名称即可&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Plugin &#39;L9&#39;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;避免插件名称与L9有冲突&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Plugin &#39;user/L9&#39;, {&#39;name&#39;: &#39;newL9&#39;}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定非 Github 的 Git 仓库的插件，需要使用 git 地址&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Plugin &#39;git://git.wincent.com/command-t.git&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定本地 Git 仓库中的插件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Plugin &#39;file:///home/gmarik/path/to/plugin&#39;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;vundle--1&quot;&gt;使用 Vundle 安装插件&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;启动 vim ,并且运行:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; :PluginInstall
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从命令行安装:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ vim +PluginInstall +qall
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;vundle--2&quot;&gt;Vundle 的其他操作&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;预览模式列出已配置的 Plugins&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; :PluginList          - list configured plugins
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装(更新)插件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; :PluginInstall(!)	- install plugins
 :PluginInstall!		- update all plugins
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;搜索(首先刷新缓存)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; :PluginSearch(!) foo - search (or refresh cache first) for foo
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;清除未使用的插件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; :PluginClean(!)      - confirm (or auto-approve) removal of unused plugins
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
                <link>http://mwumli.github.io/vim-plugin-manage</link>
                <guid>http://mwumli.github.io/vim-plugin-manage</guid>
                <pubDate>2014-06-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>不早不晚，当下最好(转载)</title>
                <description>
&lt;p&gt;人生苦短，大概三件事对我重要。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;锻炼身体 — 为活得久&lt;/h3&gt;

&lt;p&gt;无论当年在潮湿黑暗的地下室做笼中兽，还是如今在凉风习习的操场上腿毛飘飘，都是为了锻炼身体。&lt;/p&gt;

&lt;p&gt;锻炼身体是为了活得更好一点，活得更长一点。&lt;/p&gt;

&lt;p&gt;另外一个私心，就是体悟。身体是灵魂与外部沟通的媒介，对媒介的敏感度越高，便越发能感悟世界。&lt;/p&gt;

&lt;p&gt;无论是在山间小溪旁观察叶脉纹路，还或在人流涌动地铁里轻嗅香水味道，都是感悟。而身体是灵魂行走的壳子，就好比RPG里的任务装备一样。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;阅读&lt;/h3&gt;

&lt;p&gt;无论是当年的模电数电单片机，还是如今的摄影户外文史哲，看书只是想体验更多人的思想与感悟。&lt;/p&gt;

&lt;p&gt;阅读与吃饭一样，要吞食天地。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;记录&lt;/h3&gt;

&lt;p&gt;学习学习，看再多书，只是学。变成自己的东西记录写下来，才是习得。经历再多事，只能是经历，记录并思考，才能成感悟。知道不一定明白，温故知新才能有智慧。&lt;/p&gt;

&lt;p&gt;能说的话，写成博客。不能说的话，写成日记。语言能表达的用文字，语言无法表达的用影响。&lt;/p&gt;

&lt;p&gt;硬要极简主义走偏激路线的话，大体是看书锻炼写日记。&lt;/p&gt;

&lt;p&gt;这一年，我在做几件事。成与不成，此生无悔。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;李洛语&lt;/h3&gt;
&lt;p&gt;这三件事儿，是最简单的事儿，也是最难的事儿&lt;br /&gt;
可能陪伴一辈子，用一生去做&lt;br /&gt;
不过，这样才有意思,我要做这三件事儿&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;备注&lt;/h3&gt;
&lt;p&gt;此文属于转载，在阅读基础上，做了些许修改&lt;br /&gt;
原文链接：&lt;a href=&quot;http://www.xingzhekui.com/archives/6442&quot;&gt;http://www.xingzhekui.com/archives/6442&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://mwumli.github.io/three-big-things</link>
                <guid>http://mwumli.github.io/three-big-things</guid>
                <pubDate>2014-05-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>如何改变世界(转载)</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;改变世界，回归自身&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;是自我的呈现还是善其身，济天下?&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;艺术家—内心具现化&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;穷则独善其身，达则兼济天下&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;鱼和熊掌，兼得之&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;大道万千，殊途同归—完善自己&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;认识世界就是认识自己&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;李洛语&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;备注&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;改变世界，回归自身&lt;/h2&gt;

&lt;p&gt;我已经见过太多嚷嚷着要改变世界的人，若问他们要改变世界什么，换来的不过是支支吾吾。&lt;br /&gt;
改变世界这么苍白的理想是如何泛滥的呢？&lt;br /&gt;
这是产品经理中二病，与廉价的成功学并无二致。&lt;/p&gt;

&lt;p&gt;不幸的是，我也是此病的重度患者，晚期。&lt;/p&gt;

&lt;p&gt;三个月前，与 @forresty 聊天，我却说，我对于改变世界什么的越发丧失兴趣，只想要回归到自身。&lt;/p&gt;

&lt;p&gt;这当然是骗人的。因自己的努力，让许多人的生活有一些不同，并且是朝向更好的方向。我怎么可能抛弃这份理想（写作理想，读作野心）。&lt;/p&gt;

&lt;p&gt;改变世界实在太过虚幻，我不过是寻得了一条具体的道路，即回归到自身。&lt;/p&gt;

&lt;p&gt;这可以有多重的诠释。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;是自我的呈现还是善其身，济天下?&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;艺术家—内心具现化&lt;/h3&gt;

&lt;p&gt;有这样一群人，他们沉浸于自己的世界，内心肿胀，被魔鬼驱使着将自己的内心具现化投影于现实世界。&lt;br /&gt;
这些投影，具现化的形态各不相同，可能是文字，可能是绘画，可能是音乐，当然也可能是某个产品。&lt;br /&gt;
他们纯粹为自己而创作，却偏偏能感染许多人。愈是个人的，愈能打动人。&lt;br /&gt;
他们被世人称为艺术家。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;穷则独善其身，达则兼济天下&lt;/h3&gt;

&lt;p&gt;另外一种诠释就无趣许多，却也安全许多。所谓「穷则独善其身，达则兼济天下」，又或者「内圣外王]。无论如何，想要改变世界，首先需要改变自己。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;鱼和熊掌，兼得之&lt;/h3&gt;

&lt;p&gt;至于我选择的是哪一种诠释，我也没有想明白。&lt;br /&gt;
不，这么说未免自欺欺人，我只是没有办法放弃任何一种可能性而已。在&lt;a href=&quot;http://lightory.net/uncompleted-man/692/&quot;&gt;「尚未完成的人」&lt;/a&gt;一文中，我就充分表述过自己的贪婪了。&lt;br /&gt;
是的，鱼与熊掌，我全都想要，只是存在着先后顺序罢了。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;大道万千，殊途同归—完善自己&lt;/h2&gt;

&lt;p&gt;若选择的是第一种诠释，要做的是「认识自己」；&lt;br /&gt;
而第二种诠释要求的则是「改变自己」。&lt;br /&gt;
只认识自己而不改变自己是不可能的，无论具有何等的天赋，也不过是块璞玉，不持续打磨便无法成型。而想要改变自己，首先要做的便是认识自己。&lt;br /&gt;
正如刘未鹏所言，一个程序若想改变自身，首先它要能够指向自身。&lt;/p&gt;

&lt;p&gt;两条道路看似分叉，实则紧密交织，汇作一条大道。大道名为「完善自己」，而入口处的小径是「认识自己」。&lt;/p&gt;

&lt;p&gt;可是，如何才能认识自己？这远比想像中困难，许多东西一直就存在于那儿，可一旦试图诉诸于言语，便立马失去了踪影，简直比薛定谔的猫还要狡猾。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;认识世界就是认识自己&lt;/h2&gt;

&lt;p&gt;在禅房中冥想？偶尔为之尚可，充分的宁静中或许存在纯净的思考。但若长久如此，只会变做空想，未免太过愚蠢。&lt;/p&gt;

&lt;p&gt;认识自己，钥匙从来就不在于自身。&lt;/p&gt;

&lt;p&gt;认识自己是困难的，但在别人身上也能看到自己。结识足够多的人，见贤思齐，见不贤而自省。读足够多的书，真正经典的书，那是历史上最优秀一批人的思考，读书如见人。&lt;/p&gt;

&lt;p&gt;认识自己是困难的，但在周边万物都能看到自己。&lt;br /&gt;
游历足够多的地方，用脚丈量大地，抵达世界的尽头，看潮起潮落。保持初心探索日常的居所，陶醉在夜风的吹拂，用心去看小草的生长，以及枯萎。&lt;/p&gt;

&lt;p&gt;认识世界多一点，便认识自己多一点，两者的界限变得混沌。在这种混沌状态中，仿佛接近于神灵。&lt;/p&gt;

&lt;p&gt;改变世界什么的，一点也不重要了。&lt;/p&gt;

&lt;p&gt;但实在是想为这个美丽的世界，留下一点什么。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-7&quot;&gt;李洛语&lt;/h2&gt;

&lt;p&gt;我们身出世界，故被世界所影响，我们是世界的一部分，我们的变化，也影响着了世界 ,虽然这可能微不足道&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;备注&lt;/h3&gt;

&lt;p&gt;看到此文，受益良多，故转载之&lt;br /&gt;
为了便于阅读，特加些标题,也是自己的感悟&lt;/p&gt;

&lt;p&gt;原文链接：&lt;a href=&quot;http://lightory.net/how-to-change-the-world/&quot;&gt;http://lightory.net/how-to-change-the-world/&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://mwumli.github.io/how-to-change-world</link>
                <guid>http://mwumli.github.io/how-to-change-world</guid>
                <pubDate>2014-05-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>来自Linux内核的hello,world</title>
                <description>
&lt;h2 id=&quot;linux&quot;&gt;Linux内核模块&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;内核模块是什么&lt;/h3&gt;

&lt;p&gt;内核模块是Linux内核向外部提供的一个插口,其全程为动态可加载内核模块(LVM,Loadable Kernel Module),简称模块&lt;/p&gt;

&lt;p&gt;内核模块是具有独立功能的程序，可以被单独编译，但不能独立运行&lt;br /&gt;
它在运行时被链接到内核作为内核的一部分在内核空间，这和我们平时在用户空间的进程不同&lt;/p&gt;

&lt;p&gt;内核模块通常由一组函数和数据结构构成&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;内核模块的来由&lt;/h3&gt;

&lt;p&gt;Linux是一个单内核操作系统&lt;br /&gt;
它有着单内核的优点&lt;strong&gt;效率高&lt;/strong&gt;,因为所有内容都集成在一起&lt;br /&gt;
同样，缺点也是显而易见的，可扩展性和可维护性相对较差，模块机制正是为了弥补这一缺陷&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;内核模块可以做什么&lt;/h3&gt;

&lt;p&gt;模块作为内核功能的一个扩展,是为了在保持内核体积较小的情况下，增强其功能&lt;br /&gt;
内核只需要完成必要的功能即可，其他的功能都可以通过模块进行增强，类似于Vim的插件机制&lt;/p&gt;

&lt;p&gt;内核模块用来实现一种文件系统，一个驱动程序和其他内核上层的功能&lt;/p&gt;

&lt;h2 id=&quot;helloworld&quot;&gt;来自内核的hello,world&lt;/h2&gt;

&lt;h3 id=&quot;helloworld-1&quot;&gt;内核版本的hello,world&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/*hello_world.c*/&lt;/span&gt;
	&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;linux/init.h&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;linux/module.h&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;linux/kernel.h&amp;gt;&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;MODULE_LICENSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;GPL&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__init&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KERN_ALERT&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;Hllo,kernel world&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__exit&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KERN_ALERT&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;goodbye,kernel&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;module_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;module_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello_exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;MODULE_AUTHOR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;MwumLi&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;MODULE_DESCRIPTION&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Hello World&amp;#39;s kernel version!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一些说明:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&amp;lt;linux/module.h&amp;gt;，&amp;lt;linux/init.h&amp;gt;,&amp;lt;linux/kernel.h&amp;gt;是Linux内核模块程序必不可少的三个头文件
    &lt;ul&gt;
      &lt;li&gt;&amp;lt;linux/module.h&amp;gt;包含模块的结构定义以及模块的版本控制&lt;/li&gt;
      &lt;li&gt;&amp;lt;linux/init.h&amp;gt;包含了宏__init和__exit,函数module_init(),module_exit()&lt;/li&gt;
      &lt;li&gt;&amp;lt;linux/kernel.h&amp;gt;包含了常用的内核函数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;__init告诉编译器此函数仅用于初始化，编译器将__init的所有代码存储到特殊的内存区域,初始化完毕之后，这段内存将被释放掉;__exit表示此段函数是模块卸载清理函数,当模块卸载之时，将执行此函数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MODULE_*系列宏，是一些模块程序的说明信息，可选；但是，要注意的是MODULE_LICENSE(“GPL”)宏，如果模块中无此宏，编译的时候会出现警告(假如你特别在意此问题，那么加上即可)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;module_init()是模块加载函数，当模块加载时，会执行此函数参数指向的函数；module_exit()是模块卸载函数，当卸载模块的时候，会执行此函数参数指向的函数,必须&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;makefile&quot;&gt;编写Makefile文件&lt;/h3&gt;

&lt;p&gt;对于一般的Ｃ程序，我们只需要gcc就可以了，然后直接运行&lt;br /&gt;
但是内核模块程序，我们必须使用内核中makefile文件，里面包含了内核库的位置&lt;br /&gt;
因此，我们需要编写makefile文件来实现内核模块的编译&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-mf&quot; data-lang=&quot;mf&quot;&gt;&lt;span class=&quot;c&quot;&gt;# this is a Makefile&lt;/span&gt;
	obj-m +&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; hello_world.o
&lt;span class=&quot;c&quot;&gt;	#generate the path&lt;/span&gt;
	CURRENT_PATH:&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;shell &lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;	#the current kernel version number&lt;/span&gt;
	LINUX_KERNEL:&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;shell uname -r&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;	#the absolute path&lt;/span&gt;
	LINUX_KERNEL_PATH:&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/src/linux-headers-&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;LINUX_KERNEL&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;	#complie object&lt;/span&gt;
	all:
		make -C &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;LINUX_KERNEL_PATH&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;CURRENT_PATH&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; modules
&lt;span class=&quot;c&quot;&gt;	#clean&lt;/span&gt;
	clean:
		make -C &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;LINUX_KERNEL_PATH&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;CURRENT_PATH&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt; clean&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后，在命令行下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ sudo make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以成功编译(报错的话，根据错误信息debug)&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;模块的加载，卸载，查看&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;模块加载到内核&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ sudo insmod hello_world.ko
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看内核中已经加载的内核模块&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ sudo lsmod | head
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;你会发现hello_word在第一行,okay,加载成功&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;从内核卸载模块&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ sudo rmmod hello_world
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看编译成功的内核模块信息&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ sudo modinfo hello_world.ko
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://mwumli.github.io/kernel-hello</link>
                <guid>http://mwumli.github.io/kernel-hello</guid>
                <pubDate>2014-05-13T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>只管开始做(转载)</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;流逝的绝大多数时光&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;奇妙的惰性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;无法不去写，写完之后，甚为舒畅&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;清闲罪恶感&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;不仅有爱，还要有饥渴感&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#no-time-to-do&quot; id=&quot;markdown-toc-no-time-to-do&quot;&gt;一种自我蛊惑&amp;lt;—-&amp;gt;No time to do&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#just-do-it&quot; id=&quot;markdown-toc-just-do-it&quot;&gt;清空大脑，简单粗暴—&amp;gt;just do it&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;流逝的绝大多数时光&lt;/h2&gt;

&lt;p&gt;每天24小时：8小时睡觉时间，8小时工作时间，4小时饮食、回家等的时间，那么还剩余4小时呢？&lt;/p&gt;

&lt;p&gt;刷微信；要和朋友聊天；要看朋友转来的有趣图片；要慢慢消磨时光看肥皂剧；要打游戏；要发呆；要胡思乱想；以及更多情况是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;“好吧，我已经决定今天的4小时看完《编程之美》这剩下的一章....等等，看得有点瞌睡啊...不如我先做点别的轻松东西吧，要不玩会《愤怒的小鸟》？“  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;绝大多数时光，就是这样流逝了…&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;奇妙的惰性&lt;/h2&gt;

&lt;p&gt;这样做当然没什么可指责的，因为人类的天性，总会停留在让自己舒服的领域之中。&lt;/p&gt;

&lt;p&gt;那些微小时光的浪费，比如看微信、刷社交网络、慢悠悠听音乐、赖床，都是自我疗愈，是补充元气。&lt;/p&gt;

&lt;p&gt;但人们又有一种奇妙的惰性，不像机器那样，输满能量就能立刻开始运作：人是会贪恋舒服的动物，补充完汽油了，还不愿意出站，哪怕“我再听完加油站里这首歌吧。”&lt;/p&gt;

&lt;p&gt;想读一本书，买下来；买完之后，不读，放着;&lt;br /&gt;
时候久了，越告诉自己该读，就越不想读;&lt;br /&gt;
每当想起，从书架上拿起，翻几页，又放回去:“我已经读过了，过几天再说”。&lt;br /&gt;
反复的自我轻施压，有了逆反情绪，觉得这是苦差事，越不想做。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;无法不去写，写完之后，甚为舒畅&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;海明威说，艾略特的巨作《荒原》是在银行工作时写的，但没名没钱之前，艾略特就是不敢辞职，当时在巴黎的庞德，虽然诗稿卖不出去，穷得想去当翻译算了，但还是伙同诸友捐款，“把艾略特从银行拯救出来！”艾略特，一直描述：那些东西，他无法不去写。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;村上春树的第一二部小说，是在经营酒吧的间隙写完的。非常辛苦，辛苦到他写完第二部小说后就决定不再开店了。但他还是撑下来了。他自陈说自己写《且听风吟》时，甚至没有当小说家的念想，仅仅是必须写完这篇小说，他甚至没有考虑过写完之后怎么处理（最后投给了群像新人奖），但至少是：写完之后，甚为舒畅。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一直有着想写的欲望，就犹如日常吃饭那样，不可残缺，不得不做。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;清闲罪恶感&lt;/h2&gt;

&lt;p&gt;当你有选择的余地，不去做一件事时，便多少会想法子推诿；&lt;br /&gt;
但当你被限期勒令做这件事时，你还是会推诿一阵，你会觉得“这样实在太难受了，想起来就是地狱啊”，但压力之下，便会进入一种疯狂的工作节奏。&lt;/p&gt;

&lt;p&gt;你高速劳作，极为顺手，等做完后回看才发现自己有多大的潜力，“我居然做完了！”&lt;/p&gt;

&lt;p&gt;而在做完这档子事之后的一段时间，你会有些茫然若失；你会带着惯性，继续高效劳作，就像一辆刹不住的车子。&lt;/p&gt;

&lt;p&gt;你会习惯于这种紧张而高效的岁月，甚至对自己的清闲产生罪恶感；而促使你继续劳作的，就是这种罪恶感。&lt;/p&gt;

&lt;p&gt;人许多时候，就是这么种”贱骨头”：总会以为许多心结，自己无法克服；&lt;br /&gt;
但时候到了，心理会自然把曾经厌恶的一切，归化为自己可接纳的部分，并自动从完成度上寻找快感&lt;/p&gt;

&lt;p&gt;许多工作狂大多如此，靠着连续不断的自我施压、击破压力来获得快感，终于欲罢不能。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;不仅有爱，还要有饥渴感&lt;/h2&gt;

&lt;p&gt;所谓巧妙的读书方法，所谓巧妙的工作方法，许多仅仅是变着法的自我激励和自我暗示，是对心绪的谄媚，绕着弯哄自己&lt;br /&gt;
“put your FXXX ass down in front of the desk and keep on working”&lt;/p&gt;

&lt;p&gt;所以许多法子，能有用于一时，却无法持续刺激自己，除了少数天才。&lt;/p&gt;

&lt;p&gt;事情的成效在于你投入的时间，而投入的时间，必然受制于拖延症=懒，要击破这一点，就必须对所做的事情，不只有爱，而且有饥渴感，许多时候的爱慕，只是将之当成一种仪式&lt;/p&gt;

&lt;p&gt;只有真正从中获得了乐趣，才会有上瘾般的偏好，才会有一种“我一空下来就得做这个”，而不是“我是要做这个的，不过等等我先看会儿闲书吧”。&lt;/p&gt;

&lt;h2 id=&quot;no-time-to-do&quot;&gt;一种自我蛊惑&amp;lt;—-&amp;gt;No time to do&lt;/h2&gt;

&lt;p&gt;每个人都会想：我周末要回家看爸妈；我每天回家要给爸妈打个电话问平安……但这心思总存不了太久；总得要父母说得了病，去日无多，有了个期限，人才会一股脑儿，把久已储藏的情感倾泻而出。&lt;/p&gt;

&lt;p&gt;将这里的父母和你从来想做，又从来没开始着手的业余爱好做个替换，道理相去不远。&lt;/p&gt;

&lt;p&gt;成就来自经年累月的累积，累积来自于坚持，坚持受着快感的鼓励，快感则是可以通过自我压迫+释放来获得的（人是有受虐倾向的）；而许多时候，自我压迫，就来自于永不得到或即将逝去的恐惧。&lt;/p&gt;

&lt;p&gt;所以，一种自我蛊惑的心情是：“如果我现在不做某事，也许以后也没时间了。”&lt;/p&gt;

&lt;h2 id=&quot;just-do-it&quot;&gt;清空大脑，简单粗暴—&amp;gt;just do it&lt;/h2&gt;

&lt;p&gt;到最后，当你把心理深层那些欺软怕硬、好吃懒做的东西都摸明白了，也就没必要自我蛊惑了。&lt;/p&gt;

&lt;p&gt;你能够洞悉所谓拖延症，也只是耽于舒适领域，所以便只剩干脆的一点，不要前思后想，只清空大脑，然后简单粗暴的给自己一下：&lt;/p&gt;

&lt;p&gt;“别多想，只管开始做！”&lt;/p&gt;
</description>
                <link>http://mwumli.github.io/just-do-it</link>
                <guid>http://mwumli.github.io/just-do-it</guid>
                <pubDate>2014-05-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Vim的安装与配置</title>
                <description>
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#debianubuntu&quot; id=&quot;markdown-toc-debianubuntu&quot;&gt;Debian/ubuntu下安装&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;编写配置文件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vim&quot; id=&quot;markdown-toc-vim&quot;&gt;查看vim做过什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vim-1&quot; id=&quot;markdown-toc-vim-1&quot;&gt;Vim的四大模式&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#normal-mode----press-esc-to-enter&quot; id=&quot;markdown-toc-normal-mode----press-esc-to-enter&quot;&gt;Normal mode	—-	Press [Esc] to enter&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#visual-mode----press-escv-to-enter&quot; id=&quot;markdown-toc-visual-mode----press-escv-to-enter&quot;&gt;Visual mode	—-	press [Esc]+v to enter&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#insert-mode----press-escioa-to-enter&quot; id=&quot;markdown-toc-insert-mode----press-escioa-to-enter&quot;&gt;Insert mode	—-	press [Esc]+[i,o,a] to enter&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#command-line-mode----press-esc-to-enter&quot; id=&quot;markdown-toc-command-line-mode----press-esc-to-enter&quot;&gt;Command-line mode	—-	press [Esc]+[:] to enter&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#vim-2&quot; id=&quot;markdown-toc-vim-2&quot;&gt;vim的环境设定参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;debianubuntu&quot;&gt;Debian/ubuntu下安装&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$sudo apt-get install vim
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;编写配置文件&lt;/h2&gt;

&lt;p&gt;vim用户自定义配置文件&lt;code&gt;$(HOME)/.vimrc&lt;/code&gt;(若没有,请自行创建)&lt;br /&gt;
vim系统级配置文件/usr/share/vim/vimrc&lt;br /&gt;
而我们一般只修改~/.vimrc&lt;/p&gt;

&lt;h2 id=&quot;vim&quot;&gt;查看vim做过什么&lt;/h2&gt;

&lt;p&gt;~/.viminfo：记录了你曾经在vim上做过的操作(vim会自动创建)&lt;/p&gt;

&lt;h2 id=&quot;vim-1&quot;&gt;Vim的四大模式&lt;/h2&gt;

&lt;h3 id=&quot;normal-mode----press-esc-to-enter&quot;&gt;Normal mode	—-	Press [Esc] to enter&lt;/h3&gt;

&lt;p&gt;此mode是进入其他mode的基础&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	[Ctrl]+[f]	==	[PgDn]
	[Ctrl]+[b]	==	[PgUp]
	[Ctrl]+[d]		向下翻半页
	[Ctrl]+[u]		向上翻半页
	[Ctrl]+[g]  	显示位置信息
	[g]+[Ctrl]+[g]	统计字数
	[d]+[d]			删除光标所在行
	[W]				跳转到下一个单词的开头
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;visual-mode----press-escv-to-enter&quot;&gt;Visual mode	—-	press [Esc]+v to enter&lt;/h3&gt;

&lt;p&gt;选择区域：移动光标选择区域&lt;/p&gt;

&lt;p&gt;复制：选中区域后，按下y,选中的区域就被复制到剪贴板&lt;/p&gt;

&lt;p&gt;粘贴：移动光标到想要粘贴的位置，按下p,剪贴板的内容就被复制到该位&lt;/p&gt;

&lt;p&gt;区块选择：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;光标移动到想复制区域的左上角，然后按下[Ctrl-v],进入区块选择模式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;移动光标选择矩形区域，选定之后，选择的区域会反白，按下[y],反白区域消失，内容已进入vim复制缓冲区&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;移动光标到你想开始粘贴位置的起点，按下[p],刚才复制内容就会以矩形形式粘贴下来&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;insert-mode----press-escioa-to-enter&quot;&gt;Insert mode	—-	press [Esc]+[i,o,a] to enter&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	[Ctrl]+[n]和[Ctrl][p]	单词补全
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;command-line-mode----press-esc-to-enter&quot;&gt;Command-line mode	—-	press [Esc]+[:] to enter&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	:help	进入vim帮助文档
	:set all	查看vim的素有原始设置
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;vim-2&quot;&gt;vim的环境设定参数&lt;/h2&gt;

&lt;p&gt;两种设置方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在配置文件vimrc中写入(永久有效)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在vim的命令行模式下设置(只在此次打开的vim中有效)&lt;br /&gt;
展示一些常用参数：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &quot;设置高亮搜索
 set hlsearch	&quot;high light search,默认

 &quot;设置backspace按键的工作方式
 &quot;0,1表示只删除当前输入的字符
 &quot;2表示可任意删除字符,默认
 set backspace=[0,1,2]
	
 &quot;设置不自动缩进，自动缩进set autoindent
 set noautoindent	&quot;默认
                                                                       
 &quot;设置不显示行号	set nonumber显示行号
 set nonumber

 &quot;设置不自动储存备份,set backup	自动备份
 &quot;更改一个文件file时，会自动在当前路径生成一个file~的文件，记录上一步状态
 set nobackup
    
 &quot;语法高亮,syntax off 取消语法高亮
 syntax on
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
                <link>http://mwumli.github.io/vim-install-config</link>
                <guid>http://mwumli.github.io/vim-install-config</guid>
                <pubDate>2014-05-03T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
