
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        
        <title>倘若微小 - Docker 的安装与使用</title>
        
        <meta name="description" content="Docker 的介绍, 安装, 命令使用，镜像构建，容器互联, 数据共享以及相关概念">
        
        <meta name="author" content="MwumLi">

        <!-- -Site Icon -->
        <link rel="shortcut icon" href="/assets/imgs/favicon.ico" type="image/vnd.microsoft.icon">
        <!-- Custom CSS -->
	
        <link rel="stylesheet" href="/assets/themes/custom-me/css/main.css" type="text/css" media="all" />
        
        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
          <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
          <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        <!-- Fav and touch icons -->
        <!-- Update these with your own images
          <link rel="shortcut icon" href="images/favicon.ico">
          <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
          <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
          <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
        -->

        <!-- atom & rss feed -->
        <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
        <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

    </head>
    <body>
        <div id="all">
            <div id="header">
                <div id="title">
					<h1 ><a href="/">倘若微小<span class="title-tagline">---人生最美妙的风景就是内心的淡定和从容</span></a>                           
					</h1>
                </div>

                <div id="top-nav">
                    <ul>
                    


<li><a href="/pages/micro-say/2016.html">微语</a></li>



<li><a href="/pages/articles/">文章</a></li>



<li><a href="/pages/categories/">分类</a></li>



<li><a href="/pages/tags/">标签</a></li>



<li><a href="/rss.xml">订阅</a></li>


	


                    </ul>   
                </div>
            </div> 

            <div class="content">
                
<div class="page-header">
    <h1>Docker 的安装与使用 <small></small></h1>
    <div id="article_header">
        
        
        <div>
            <span>分类: </span>
            <a href="/pages/categories/#软件-ref" class="tag">软件</a> 
            
                <span>标签: </span>
            
            
                <a href="/pages/tags/#Docker-ref" class="tag">Docker</a>
            
                <a href="/pages/tags/#运行环境-ref" class="tag">运行环境</a>
            
                <a href="/pages/tags/#Dockerfile-ref" class="tag">Dockerfile</a>
            
                <a href="/pages/tags/#容器-ref" class="tag">容器</a>
            
        </div>      
        <div>
            Last Modify in
            
            <span>2016-03-14</span>,
            
            published in <span>2016-03-14</span> 
            by <span> MwumLi</span>
        </div>

        
        
    </div>
</div>

<div id="page-content">
    
<ul id="markdown-toc">
  <li><a href="#what-is-docker" id="markdown-toc-what-is-docker">What is Docker?</a></li>
  <li><a href="#section" id="markdown-toc-section">安装</a>    <ul>
      <li><a href="#mac-os-x" id="markdown-toc-mac-os-x">Mac OS X</a></li>
      <li><a href="#windows" id="markdown-toc-windows">Windows</a></li>
      <li><a href="#linux" id="markdown-toc-linux">Linux</a></li>
      <li><a href="#root--docker" id="markdown-toc-root--docker">非 root 用户使用 docker</a></li>
    </ul>
  </li>
  <li><a href="#docker-" id="markdown-toc-docker-">Docker 基本命令</a>    <ul>
      <li><a href="#docker--1" id="markdown-toc-docker--1">Docker 容器</a></li>
      <li><a href="#docker--2" id="markdown-toc-docker--2">Docker 镜像的命令</a></li>
    </ul>
  </li>
  <li><a href="#section-1" id="markdown-toc-section-1">构建镜像</a>    <ul>
      <li><a href="#docker-registry" id="markdown-toc-docker-registry">登录 Docker Registry</a></li>
      <li><a href="#docker-commit" id="markdown-toc-docker-commit">docker commit</a></li>
      <li><a href="#docker-build" id="markdown-toc-docker-build">docker build</a>        <ul>
          <li><a href="#section-2" id="markdown-toc-section-2">构建缓存是什么</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#dockefile" id="markdown-toc-dockefile">Dockefile</a></li>
  <li><a href="#volume-" id="markdown-toc-volume-">VOLUME 与数据共享</a>    <ul>
      <li><a href="#section-3" id="markdown-toc-section-3">容器与宿主机</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">容器之间</a></li>
    </ul>
  </li>
  <li><a href="#section-5" id="markdown-toc-section-5">容器互联</a>    <ul>
      <li><a href="#docker--3" id="markdown-toc-docker--3">docker 局域网</a></li>
      <li><a href="#link-" id="markdown-toc-link-">link 互联</a></li>
    </ul>
  </li>
  <li><a href="#section-6" id="markdown-toc-section-6">一些概念</a></li>
  <li><a href="#section-7" id="markdown-toc-section-7">相关链接</a></li>
</ul>

<h2 id="what-is-docker">What is Docker?</h2>

<p><code>Docker 就是容器</code>(类似虚拟机), 在很多人眼里, Docker 就是这么一个印象  <br />
在这之前, 我也是这样认为的</p>

<p>事实上, Docker 不仅仅是容器, 它是一系列 Docker 组件的集合, 包括 :</p>

<ul>
  <li>Docker 客户端和服务端</li>
  <li>Docker 镜像</li>
  <li>Docker 容器</li>
  <li>Docker Registry</li>
</ul>

<p><a href="http://www.docker.com/what-docker" title="What is Docker?">官方文档说</a> :</p>

<pre><code>Docker allows you to package an application with all of its dependencies into a standardized unit for software development.  
</code></pre>

<p>简而言之, Docker 可以打包应用以及相关依赖到一个相对独立的单元( Docker 镜像)</p>

<p>因此, 我们只需要构建一次 Docker 镜像, 就可以在以后的开发和部署环境中保证一致的应用运行环境  <br />
从而避免环境不一致引发应用的兼容性错误  <br />
(前提是宿主机上已经安装了 Docker)</p>

<h2 id="section">安装</h2>

<h3 id="mac-os-x">Mac OS X</h3>

<p>Mac OS 下安装见这里: <a href="https://docs.docker.com/engine/installation/mac/">https://docs.docker.com/engine/installation/mac/</a></p>

<h3 id="windows">Windows</h3>

<p>Windows 下安装见这里 : <a href="https://docs.docker.com/engine/installation/windows/">https://docs.docker.com/engine/installation/windows/</a></p>

<h3 id="linux">Linux</h3>

<p>Docker 支持多种 Linux 的发行版本的安装  <br />
具体见这里 : <a href="https://docs.docker.com/engine/installation/linux/">https://docs.docker.com/engine/installation/linux/</a></p>

<h3 id="root--docker">非 root 用户使用 docker</h3>

<p>假如你想以非 root 用户的身份使用 docker , 你应该考虑添加你的用户到 <code>docker</code> 用户组  <br />
命令如下 :</p>

<pre><code>$ sudo usermod -aG docker your-user
</code></pre>

<p>记住 : 只有 log out, 然后 back in 才能使之生效</p>

<h2 id="docker-">Docker 基本命令</h2>

<h3 id="docker--1">Docker 容器</h3>

<ol>
  <li>
    <p>查看 docker 是否存在</p>

    <pre><code> $ sudo docker info
</code></pre>

    <p>返回所有容器和镜像的数量, 以及 docker 所使用的执行驱动和存储驱动</p>
  </li>
  <li>
    <p>创建和启动容器, 并运行指定命令</p>

    <pre><code> $ sudo docker run  ubuntu ls
</code></pre>

    <p><code>docker run</code> 命令首先在本地寻找命令指定的镜像 <code>ubuntu</code>  <br />
假如没有找到, 那么会在 Docker 官方维护的 Docker Hub Registry 上寻找,一旦找到镜像, 就会下载该镜像并存储到本地  <br />
接着, <code>docker run </code> 会以此镜像为基础, 创建并启动一个容器  <br />
最后在容器中执行命令 <code>ls</code></p>

    <p>创建一个具有交互 Shell 的容器</p>

    <pre><code> $ sudo docker run -i -t ubuntu /bin/bash
</code></pre>

    <p><code>-i</code> 保证容器中 <code>STDIN</code> 是开启的  <br />
<code>-t</code> 告诉 Docker 为创建的容器分配一个伪 tty 终端  <br />
然后指定运行命令 <code>/bin/bash</code>, 这样新创建的容器才会有一个交互式的 shell</p>

    <p>如果通过管道与 shell 进行交互,仅仅使用 <code>-i</code></p>

    <pre><code> echo "Hello,world" | sudo docker run -i ubuntu cat
</code></pre>
  </li>
  <li>
    <p>为容器指定主机名 :</p>

    <pre><code> $ sudo docker run --rm -h MwumLi ubuntu hostname
 MwumLi
</code></pre>

    <p><code>-h</code> 或者 <code>--hostname</code> 指定容器的主机名</p>
  </li>
  <li>
    <p>端口映射 :</p>

    <pre><code> # 随机分配宿主机的端口到 docker 指定端口
 # 从宿主机的端口 `49153~65535` 中随机选一个映射到容器的 80 端口  
 $ sudo docker -d -p 80 ubuntu nginx -g "daemon off;"
 
 # 指定容器与宿主机之间的端口映射关系 `-p 宿主端口:容器端口`  
 # 把宿主机的 8080 端口映射到 Docker 容器的 80 端口上  
 $ sudo docker -d -p 8080:80 ubuntu nginx -g "daemon off;"  
</code></pre>

    <p><code>-p</code> 指定要暴露的容器端口号, 这个端口号是创建镜像的时候使用 <code>EXPOSE</code> 指定的端口号(<code>EXPOSE 可以指定多次</code>)</p>
  </li>
  <li>
    <p>查看容器 <code>ps</code>  <br />
<code>docker ps</code> – 列出当前处于运行状态的 docker container  <br />
<code>docke ps -l</code> – 列出最后一次运行的容器(包括正在运行和已停止)  <br />
<code>docker ps -a</code> – 列出所有的容器（包括正在运行和已停止的）  <br />
<code>docker ps -n x</code> – 列出最后 X 个容器(包括运行和停止)</p>
  </li>
  <li>
    <p>为容器命名 <code>--name</code></p>

    <pre><code> $ docker run --name your-name -i -t ubuntu bash
</code></pre>

    <p>这会创建一个容器名为 <code>your-name</code> 的容器  <br />
如果你不使用 <code>--name</code> 指定，它会随机生成一个名字  <br />
名称必须在当前环境唯一，如果已经存在同名容器，那么会创建失败, 除非删除原有的容器</p>
  </li>
  <li>
    <p>重新启动已经停止的容器 :</p>

    <pre><code> $ sudo docker start container_name/container_id
 $ sudo docker restart container_name/container_id
</code></pre>
  </li>
  <li>
    <p>附着到容器的会话中 :</p>

    <pre><code> $ sudo docker attach container_name/container_id
</code></pre>

    <p>(你可能还需要按下回车键才能进入会话)   <br />
这个和 <code>tmux attach</code> 很相似, 都是重新进入之前的会话</p>
  </li>
  <li>
    <p>创建一个守护式容器</p>

    <pre><code> $ sudo docker run -d  --name mwum-daemon ubuntu /bin/sh -c "while true; do echo hello,world!; sleep 1; done"
</code></pre>

    <p><code>-d</code> 表示后台运行</p>
  </li>
  <li>
    <p>查看容器日志 <code>logs</code></p>

    <pre><code>$ sudo docker logs container_name/container_id
</code></pre>

    <p>如果想监控 docker 的日志, 和 <code>tail -f</code> 命令非常相似,按 <code>Ctrl+C</code> 退出日志跟踪</p>

    <pre><code>$ sudo docker logs -f container_name/container_id
</code></pre>

    <p>查看最后 10 行内容 :</p>

    <pre><code>$ sudo docker logs --tail 10 container_name/container_id
</code></pre>

    <p>始终读取最新 10 行日志 :</p>

    <pre><code>$ sudo docker logs --tail 10 -f container_name/container_id
</code></pre>
  </li>
  <li>
    <p>查看容器内部的进程 :</p>

    <pre><code>$ sudo docker top container_name/container_id
</code></pre>
  </li>
  <li>
    <p>在运行状态的容器内部运行新进程 :</p>

    <pre><code># 在 docker 容器内部建了个新文件 /etc/new_file
$ sudo docker exec -d container_name/container_id touch /etc/new_file             

# 启动交互式shell
$ sudo docker exec -i -t container_name/container_id bash    
</code></pre>
  </li>
  <li>
    <p>停止容器</p>

    <pre><code>$ sudo docker stop container_name/container_id        # 发送 SIGTERM 信号
$ sudo docker kill container_name/container_id        # 发送 SIGKILL 信号(快速停止容器)
</code></pre>

    <p><code>stop</code> 和 <code>kill</code> 都是通过发送信号来实现停止容器  <br />
<code>kill -s </code> 指定发送的信号</p>
  </li>
  <li>
    <p>自动重启容器 <code>--restart</code></p>

    <pre><code># 无论容器退出代码是什么，都会一直重启
$ sudo docker run --restart=always -d ubuntu command          
	
# 当容器退出代码为非0时，才会自动重启  
$ sudo docker run --restart=on-failure -d ubuntu command  


# 当容器退出代码为非0时，Docker 会尝试重启该容器, 最多重启 5 次  
$ sudo docker run --restart-on-failure:5 -d ubuntu command 
</code></pre>
  </li>
  <li>
    <p>获取某个容器的详细信息 <code>inspect</code></p>

    <pre><code>$ sudo docker inspect container_name/container_id
$ sudo docker inspect --format='' container_name/container_id     # 返回是否运行, --format 可用来选择查询
</code></pre>

    <p>一次也可指定多个容器  <br />
<code>--format</code> 可以指定打印某一项信息</p>
  </li>
  <li>
    <p>删除容器</p>

    <pre><code># 容器必须是停止运行状态
$ sudo docker rm container_name/container_id  
</code></pre>
  </li>
</ol>

<h3 id="docker--2">Docker 镜像的命令</h3>

<ol>
  <li>
    <p>列出镜像</p>

    <pre><code> $ sudo docker images  # 列出所有的镜像  
</code></pre>
  </li>
  <li>
    <p>删除镜像</p>

    <pre><code> $ sudo docker rmi image_name/image_id 
 # 删除所有的镜像
 $ sudo docker rmi `docker images -a -q` 
</code></pre>

    <p>镜像删除之前, 必须保证没有使用此镜像的容器; 否则, 删除失败</p>
  </li>
  <li>
    <p>拉取仓库中的镜像(比如Ubuntu)</p>

    <pre><code> # 会把顶级仓库中所有 ubuntu 镜像拉下来
 $ sudo docker pull ubuntu     
 # 会把顶级仓库中 tag 为 12.04 的 ubuntu 镜像拉取下来  
 $ sudo docker pull ubuntu:12.04 
</code></pre>
  </li>
  <li>
    <p>搜索镜像(仓库名或用户名)</p>

    <pre><code> $ sudo docker search chef
</code></pre>
  </li>
  <li>
    <p>查看镜像详细情形 :</p>

    <pre><code> $ sudo docker inspect image
</code></pre>
  </li>
  <li>
    <p>查看镜像的构建历史 :</p>

    <pre><code> $ sudo docker history image
</code></pre>
  </li>
</ol>

<h2 id="section-1">构建镜像</h2>

<p>这里所说的构建镜像不是真正的创建镜像, 而是基于一个已有的基础镜像构建镜像而已  <br />
如果想从零开始, 那么参考 : <a href="https://docs.docker.com/engine/userguide/eng-image/baseimages/">https://docs.docker.com/engine/userguide/eng-image/baseimages/</a></p>

<p>两种构建办法 :</p>

<ul>
  <li>
    <p>使用 <code>docker commit</code></p>
  </li>
  <li>
    <p>使用 <code>docker build</code> 配合 <code>Dockerfile</code> 文件</p>
  </li>
  <li>
    <p>Docker hub 与 Github 的自动化构建(请自行搜索)</p>
  </li>
</ul>

<h3 id="docker-registry">登录 Docker Registry</h3>

<p>对于一般用户来说，我们都会选择使用 Docker 公司提供的 Registry : Docker Hub 来作为我们的远程 docker 仓库  <br />
因此，需要注册一个 Docker Hub 账户</p>

<p>命令行登录 Docker Hub : <code>sudo docker login</code></p>

<p>认证信息会保存在 <code>~/.docker/config.json</code>, 以共后面推送使用</p>

<p>命令行退出 Docker hub : <code>sudo docker logout</code></p>

<h3 id="docker-commit">docker commit</h3>

<ol>
  <li>创建一个具有命令交互式的容器</li>
  <li>在其中修改某些东西后, 安装新软件、修改配置等, 然后 <code>exit</code></li>
  <li>
    <p>把当前已修改容器打包成镜像 :</p>

    <pre><code> $ sudo docker commit container username/repository_name
 # 可以指定一些描述信息 :  
 $ sudo docker commit -m "new custom images" --author="MwumLi" container username/repository_name
</code></pre>
  </li>
  <li>
    <p>提交过程暂停容器</p>

    <pre><code> $ docker commit --pause=false &lt;container_id&gt; .
</code></pre>
  </li>
</ol>

<p>在一个运行中的容器中执行提交动作是不被推荐的，这会导致文件处于不一致的状态  <br />
  现在你可以在提交过程中暂停容器的运行</p>

<h3 id="docker-build">docker build</h3>

<p><code>docker build</code> 指令需要配合一个 <code>Dockerfile</code> 文件  <br />
<code>Dockerfile</code> 是对一个构建过程的描述, 类似于 <code>Vagrant</code> 的 <code>Vagrantfile</code>  <br />
只要建立这个文件，再加上要求的基础镜像, 使用 <code>docker build</code> 命令就可以构建出一个新的镜像</p>

<ol>
  <li>
    <p>新建目录 <code>static_web</code>,进入目录，新建文件<code>Dockerfile</code></p>

    <pre><code> $ mkdir static_web &amp;&amp; cd static_web &amp;&amp; touch Dockerfile
</code></pre>

    <p>这个目录会存储你的构建上下文, 构建的时候，Docker 的守护进程就可以访问到这个目录下的文件了</p>
  </li>
  <li>
    <p>根据需求, 在 <code>Dockefile</code> 中写上你的指令  <br />
Dockefile 指令看目录 : Dockefile</p>
  </li>
  <li>
    <p>开始构建 :</p>

    <pre><code> static_web $ sudo docker build -t="username/repository_name:tag" .
</code></pre>
  </li>
  <li>
    <p>不使用构建缓存 :</p>

    <pre><code> static_web $ sudo docker build --no-cache -t="username/repository_name:tag"
</code></pre>
  </li>
  <li>
    <p>新建 <code>.dockerignore</code>, 在里面添加不需要发送给 <code>docker daemon</code> 的文件, 类似于 <code>.gitignore</code>  <br />
在构建开始时中,会首先把构建目录下的所有文件发送给 <code>docker daemon</code>  <br />
我们可以指定某些文件不用被发送到 <code>docker daemon</code>, 这样可以加快构建速度</p>
  </li>
</ol>

<h4 id="section-2">构建缓存是什么</h4>

<p>构建过程是一步一步的, 每一条指令的执行都会进行一次提交, 这样会形成一系列镜像层</p>

<p>修改 <code>Dockerfile</code> 中某条指令后再次构建, 那条指令之前的指令就不需要再次执行</p>

<p>这就是构建缓存</p>

<p>构建缓存可以说是加快了我们重新构建镜像的速度</p>

<h2 id="dockefile">Dockefile</h2>

<p>使用数组方式作为命令的参数的时候，请使用双引号，不要使用单引号</p>

<pre><code># 指定基础镜像
FROM ubuntu:14.04  
# 触发器
# 当此镜像作为基础镜像构建新镜像的时候,执行下面 ONBUILD 紧跟的 ADD 命令
# 但是构建生成的子镜像作为基础镜像构建新的镜像的时候, 就不在起作用
# 在子镜像构建过程中紧跟 FROM 指令之后执行
ONBUILD ADD . /app/src

# 添加镜像作者以及email等信息
MAINTAINER MwumLi mwumli@hotmail.com

# 添加环境变量 refreshed
ENV refreshed 2016-03-02

# 指定卷  
# 具体见下文 : 数据共享
VOLUME /opt/data

# 指定镜像会以什么样的用户执行
# 有以下 6 种使用方式
# 默认用户为 root
USER user
USER user:group
USER uid
USER uid:gid
USER user:gid
USER uid:group

# ADD 和 COPY 指令用来把构建上下文目录下的东西复制到镜像中  
# 区别在于 ADD 在复制压缩文件时, 会自动解压  

# 指定镜像构建时要运行的命令: 命令会被执行成 `bash -c "apt-get update"`
# 更新了软件源
RUN apt-get update

# 指定构建时要运行的命令: 命令会直接执行 
# 推荐这种方式, 之后的 CMD 指定也推荐这种语法
# 安装 nginx
RUN ["apt-get", "install", "nginx"]

# 告诉 Docker 80 端口将会被容器的应用程序所使用
# 可以指定多次来指定多个端口
# 但 Docker 并不会自动打开这些端口, 需要在使用 docker run 的使用 -p 参数来指定      
EXPOSE 80

# 指定容器被启动时要运行命令  
# 如果 `docker run` 并没有指定要运行的命令，那么会运行 CMD 指定的命令
# 如果 `docker run` 指定运行的命令，那么就执行指定的命令，CMD 就会被忽略
# CMD 只能指定一条运行的命令，如果指定多次，以最后一次为准  
# 默认输出 "Welcome, Here is docker"
CMD ["echo", "Welcome, Here is docker"]

# 指定容器被启动时要运行的执行
# 但这个和 CMD 有点不一样  
# 如果 `docker run` 命令指定运行的命令，指定命令会被添加到把 ENTRYPOINT 所有参数后面执行
# 如果没有指定, 会把 CMD 中指定的参数添加到 ENTRYPOINT 中参数末尾执行
ENTRYPOINT ["echo", "进入点"]
CMD ["cmd 作为 ENTRYPOINT 参数"]

# 更改工作目录
# WORKDIR 命令之后的命令执行都在这个 WORKDIR 指定目录下
# 包括最终容器的工作目录(不是用户主目录)
# 默认在 `/root` 下
WORKDIR /home
RUN mkdir MwumLi
</code></pre>

<h2 id="volume-">VOLUME 与数据共享</h2>

<p><code>VOLUME</code> 是 Dockerfile 中的指令, 用来在 docker 中指定一个卷</p>

<p>Docker 中的卷类似于虚拟机共享文件夹的概念  <br />
因此可以通过卷来实现 docker 容器之间, docker 容器与宿主机之间的数据共享</p>

<h3 id="section-3">容器与宿主机</h3>

<p>通过指定卷来实现容器与宿主机之间的数据共享</p>

<p>有两种方式指定卷 :</p>

<ol>
  <li>
    <p>在 Dockerfile 使用 <code>VOLUME</code> 指令 : <code>VOLUME /opt/data</code>  <br />
使用此 Dockerfile 构建镜像, 并以此镜像创建的容器, 会自动在宿主机的 <code>/var/lib/docker/volumes/</code> 下新建一个文件夹(文件夹名是一串随机字符串)  <br />
这个文件夹会被挂载在这个容器的 <code>/opt/data</code> 下  <br />
如果 <code>/opt/data</code> 不存在, 那么会自动创建  <br />
当使用 <code>docker run --rm</code> 创建容器的时候, 一旦容器停止, 会自动删除容器及其卷</p>
  </li>
  <li>
    <p>命令行中使用 <code>-v</code> 参数</p>

    <pre><code> # 这种方式和 `VOLUME` 指令的效果一样
 $ sudo docker run -it -v /opt/data ubuntu bash

 # 宿主机当前目录下的 `data/` 被挂载到容器 `/opt/data` 下
 $ sudo docker run -it -v $PWD/data:/opt/data ubuntu bash
</code></pre>
  </li>
</ol>

<h3 id="section-4">容器之间</h3>

<p>容器之间只要共享卷, 就可以实现数据共享</p>

<p>使用 <code>--volumes-from</code> :</p>

<pre><code>$ docker run -it --volumes-from container debian /bin/bash
</code></pre>

<p>这样创建的容器会共享容器 container 的卷, 达到了数据共享的目的</p>

<h2 id="section-5">容器互联</h2>

<p>Docker 想要达到的目标是一个容器最好只允许运行一个应用  <br />
然而目前互联网的应用都是多个应用组合在一起的应用程序栈</p>

<p>因此，我们需要让每个 docker 容器运行一个单独的应用(比如nginx, mysql, redis 等), 然后通过某种技术实现容器间的互联</p>

<h3 id="docker--3">docker 局域网</h3>

<p>在安装 Docker 时, 会创建一个新的网络接口 <code>docker0</code>  <br />
每个 docker 容器都会在这个接口上分配一个 ip 地址  <br />
接口 <code>docker0</code> 是一个虚拟的以太网桥, 用于连接容器和本地宿主网络</p>

<p>如果进一步查看 Docker 宿主机的其他网络接口, 会发现一系列以 <code>veth*</code> 接口</p>

<p>Docker 每创建一个容器就会创建一组互联的网络接口,这组接口就像管道的两端  <br />
这组接口其中一端作为容器里的 <code>eht0</code> 接口  <br />
而另一端命名为 <code>veth*</code>, 作为宿主机的一个端口  <br />
这个虚拟网线一端插在名为 <code>docker0</code> 的网桥上, 另一端插在容器里</p>

<p>通过把每个 <code>veth*</code> 接口绑定到 docker0 网桥, Docker 创建了一个虚拟子网  <br />
这个子网由宿主机和所有的 docker 容器共享</p>

<h3 id="link-">link 互联</h3>

<p>从上面我们可以得到一个结论 : 宿主机和docker 容器组成了一个虚拟子网, 在这个子网内可以互相访问</p>

<p>那么互联的方案就可以得到 : 直接通过 子网 IP 相互访问</p>

<p>但是这样存在这么几个问题 :</p>

<ol>
  <li>应用程序需要对容器的 IP 做硬编码</li>
  <li>如果重启容器, Docker 会改变容器的 IP 地址</li>
</ol>

<p>因此, 这种方案并不时最好的方案</p>

<p>docker 提供了一个参数 <code>--link</code>, 使用 <code>--link</code> 实现容器间的互联 :</p>

<pre><code>$ sudo docker run --rm -it --name juan  --link redis:db ubuntu:14.04 bash
</code></pre>

<p>这样创建的容器与 <code>redis</code> 容器连接起来, <code>redis</code> 被称为子容器, 而新创建的这个 <code>juan</code> 容器被称为父容器  <br />
在父容器内部, 会形成这样两个动态更新的信息 :</p>

<ol>
  <li><code>/etc/hosts</code> 文件, 发现 <code>db</code>(与命令行 db 对应)对应一个 ip 地址, 即子容器的地址</li>
  <li>使用 <code>env | grep DB</code>(DB 与命令行 db 大写对应) 可以看到与子容器相关的ip、端口环境变量</li>
</ol>

<p>当被子容器重启，一旦 ip 地址发生变化，会自动更新链接容器中的 host 以及 环境变量</p>

<p>通过这些信息, 我们就可以实现父子容器之间的通信, 并且避免了硬编码的问题以及 IP 地址改变的问题</p>

<p>由于安全原因, 可以强制 Docker 只允许有连接的容器之间互相通信  <br />
需要在启动 Docker 守护进程时加上 <code>--icc=false</code> 的标志，就会关闭所有没有连接的容器间的通信</p>

<h2 id="section-6">一些概念</h2>

<ul>
  <li>Docker 是一系列 Docker 组件的集合, 是一个统称</li>
  <li>Docker 是一个 C/S 架构的程序</li>
  <li>Docker 服务端 : 一个守护进程, 管理容器以及响应 Docker 客户端的请求</li>
  <li>Docker 客户端 : 一个命令行工具, 用户通过它与 Docker 服务端交互, 来操纵和查看容器</li>
  <li>Docker 镜像 : 类似于操作系统镜像, 可以通过多种方式构建</li>
  <li>Docker 容器 : 类似一个虚拟机, Docker 镜像运行在 Docker 容器中, 形成一个完整的隔离化的应用程序运行环境</li>
  <li>Docker Registry : 类似于 git 服务器一样的存在, 代码是开源的，你可以搭建自己的私有 Registry</li>
  <li>Docker Hub : 类似于 Github 一样的存在, 是 Docker 公司搭建的 Docker Registry 服务, 和 Github 一样公共,免费</li>
  <li>Docker 仓库: 类似于 Github 上的一个个项目一样</li>
  <li>Docker 仓库下可以有很多镜像 : 类似同一个 Git 项目的不同 Tag 一样, Docker 仓库下的不同镜像是靠 tag 来区分的</li>
  <li>Docker 用户仓库命名 : <code>username/repository_name</code></li>
  <li>Docker 顶层仓库 : <code>repository_name</code>, 只包含仓库名, 顶层仓库是由 Docker 公司和选定的能提供优质基础镜像的厂商管理  <br />
用户通常基于这些基础镜像构建自己的镜像  <br />
同时顶层仓库也代表个厂商和 docker 公司的一种承诺, 即顶层仓库中的镜像是架构良好、安全且最新的</li>
  <li>
    <p>某个具体的 Docker 镜像 :  <br />
用户仓库 : <code>username/repository_name:tag</code>  <br />
顶层仓库 : <code>repository_name:tag</code></p>
  </li>
  <li>Docker 的镜像的构建和 git 仓库代码提交类似, 同样有 <code>commit</code>, <code>push</code>, <code>pull</code> 等操作，学习过程中可以类比来看</li>
</ul>

<h2 id="section-7">相关链接</h2>

<ol>
  <li>Understand the architecture : <a href="https://docs.docker.com/engine/understanding-docker/">https://docs.docker.com/engine/understanding-docker/</a></li>
  <li>Docker 官网 : <a href="https://www.docker.com/">https://www.docker.com/</a></li>
</ol>


    <hr>
    <div class="pagination">
      <ul>
      
        <li class="prev">上一篇: <a href="/css-clearfix" title="clearfix 引发的思考">clearfix 引发的思考</a></li>
      
      
        <li class="next">下一篇: <a href="/modify-hard-size-for-virtualbox" title="调整 virtualbox 虚拟机磁盘大小">调整 virtualbox 虚拟机磁盘大小</a></li>
      
      </ul>
    </div>

    <hr>

    <div id="to_comments">
    


  <div id="disqus_thread"></div>
<script type="text/javascript">
    
    var disqus_developer = 1;
    var disqus_shortname = 'ifmicro'; // required: replace example with your forum shortname
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




    </div>
 </div>

   
            </div>

            <hr />

            <div id="footer" class="footer">
                <p>
				&copy;2014-2016 <a href="http://www.ifmicro.com/">倘若微小</a><br />
Powered by <a href="https://jekyllrb.com/">jekyll</a> | Hosted by <a href="https://github.com/">github</a> | Designed by <a href="http://www.ifmicro.com/">MwumLi</a><br />
本站采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享 署名-非商业性使用 4.0 国际 许可协议</a>进行许可。

                </p>
            </div>
        </div>
        
        <!-- site top -->
        <div class="nav-bottom">
            <span class="icon icon-mid site-top" id="site-top" title="滑动到顶部"><span class="icon-arrowUp"></span></span>
            <span class="icon icon-mid .site-comment" id="site-comment" title="去评论"><span class="icon-comment-text"></span></span>
            <span class="icon icon-mid .site-bottom" id="site-bottom" title="滑动到底部"><span class="icon-arrowDown"></span></span>
        </div>

        




        <script src="/assets/themes/custom-me/js/jquery-2.1.3.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="/assets/themes/custom-me/js/jquery.zclip.js"></script>

        
        <script src="/assets/themes/custom-me/js/copy.js"></script>
        
        
        

        <script src="http://cdn.bootcss.com/underscore.js/1.8.3/underscore.js"></script>
        <script src="/assets/themes/custom-me/js/toc.js"></script>
        <script src="/assets/themes/custom-me/js/jquery.resizeEnd.js"></script>
        <script src="/assets/themes/custom-me/js/jquery.mCustomScrollbar.concat.min.js"></script>
    
        <script src="/assets/themes/custom-me/js/bigfoot.js"></script>
        <script src="/assets/themes/custom-me/js/toComments.js"></script>
        <script type="text/javascript" charset="utf-8">
            $(document).ready(function(){
                    
                
                addCopy("pre", "copy", "Copy");
                

				
                tocEffect();
				

                toComments();
                $.bigfoot({
                    preventPageScroll: true
                })

            })
        </script>   
 </div>
    </body>
</html>



