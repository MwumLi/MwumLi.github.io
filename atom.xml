<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>倘若微小</title>
 <link href="http://mwumli.github.io" rel="self"/>
 <link href="http://mwumli.github.io"/>
 <updated>2016-03-26T10:05:23+00:00</updated>
 <id>http://mwumli.github.io</id>
 <author>
   <name>MwumLi</name>
   <email>mwumli@hotmail.com</email>
 </author>

 
 <entry>
   <title>Docker 的安装与使用</title>
   <link href="http://mwumli.github.io/docker-install-and-usage"/>
   <updated>2016-03-14T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/docker-install-and-usage</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#what-is-docker&quot; id=&quot;markdown-toc-what-is-docker&quot;&gt;What is Docker?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;安装&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#mac-os-x&quot; id=&quot;markdown-toc-mac-os-x&quot;&gt;Mac OS X&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#windows&quot; id=&quot;markdown-toc-windows&quot;&gt;Windows&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#linux&quot; id=&quot;markdown-toc-linux&quot;&gt;Linux&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#root--docker&quot; id=&quot;markdown-toc-root--docker&quot;&gt;非 root 用户使用 docker&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#docker-&quot; id=&quot;markdown-toc-docker-&quot;&gt;Docker 基本命令&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#docker--1&quot; id=&quot;markdown-toc-docker--1&quot;&gt;Docker 容器&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#docker--2&quot; id=&quot;markdown-toc-docker--2&quot;&gt;Docker 镜像的命令&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;构建镜像&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#docker-registry&quot; id=&quot;markdown-toc-docker-registry&quot;&gt;登录 Docker Registry&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#docker-commit&quot; id=&quot;markdown-toc-docker-commit&quot;&gt;docker commit&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#docker-build&quot; id=&quot;markdown-toc-docker-build&quot;&gt;docker build&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;构建缓存是什么&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dockefile&quot; id=&quot;markdown-toc-dockefile&quot;&gt;Dockefile&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#volume-&quot; id=&quot;markdown-toc-volume-&quot;&gt;VOLUME 与数据共享&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;容器与宿主机&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;容器之间&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;容器互联&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#docker--3&quot; id=&quot;markdown-toc-docker--3&quot;&gt;docker 局域网&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#link-&quot; id=&quot;markdown-toc-link-&quot;&gt;link 互联&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;一些概念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;相关链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;what-is-docker&quot;&gt;What is Docker?&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Docker 就是容器&lt;/code&gt;(类似虚拟机), 在很多人眼里, Docker 就是这么一个印象  &lt;br /&gt;
在这之前, 我也是这样认为的&lt;/p&gt;

&lt;p&gt;事实上, Docker 不仅仅是容器, 它是一系列 Docker 组件的集合, 包括 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Docker 客户端和服务端&lt;/li&gt;
  &lt;li&gt;Docker 镜像&lt;/li&gt;
  &lt;li&gt;Docker 容器&lt;/li&gt;
  &lt;li&gt;Docker Registry&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://www.docker.com/what-docker&quot; title=&quot;What is Docker?&quot;&gt;官方文档说&lt;/a&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Docker allows you to package an application with all of its dependencies into a standardized unit for software development.  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简而言之, Docker 可以打包应用以及相关依赖到一个相对独立的单元( Docker 镜像)&lt;/p&gt;

&lt;p&gt;因此, 我们只需要构建一次 Docker 镜像, 就可以在以后的开发和部署环境中保证一致的应用运行环境  &lt;br /&gt;
从而避免环境不一致引发应用的兼容性错误  &lt;br /&gt;
(前提是宿主机上已经安装了 Docker)&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;安装&lt;/h2&gt;

&lt;h3 id=&quot;mac-os-x&quot;&gt;Mac OS X&lt;/h3&gt;

&lt;p&gt;Mac OS 下安装见这里: &lt;a href=&quot;https://docs.docker.com/engine/installation/mac/&quot;&gt;https://docs.docker.com/engine/installation/mac/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;windows&quot;&gt;Windows&lt;/h3&gt;

&lt;p&gt;Windows 下安装见这里 : &lt;a href=&quot;https://docs.docker.com/engine/installation/windows/&quot;&gt;https://docs.docker.com/engine/installation/windows/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;linux&quot;&gt;Linux&lt;/h3&gt;

&lt;p&gt;Docker 支持多种 Linux 的发行版本的安装  &lt;br /&gt;
具体见这里 : &lt;a href=&quot;https://docs.docker.com/engine/installation/linux/&quot;&gt;https://docs.docker.com/engine/installation/linux/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;root--docker&quot;&gt;非 root 用户使用 docker&lt;/h3&gt;

&lt;p&gt;假如你想以非 root 用户的身份使用 docker , 你应该考虑添加你的用户到 &lt;code&gt;docker&lt;/code&gt; 用户组  &lt;br /&gt;
命令如下 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo usermod -aG docker your-user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;记住 : 只有 log out, 然后 back in 才能使之生效&lt;/p&gt;

&lt;h2 id=&quot;docker-&quot;&gt;Docker 基本命令&lt;/h2&gt;

&lt;h3 id=&quot;docker--1&quot;&gt;Docker 容器&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;查看 docker 是否存在&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo docker info
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;返回所有容器和镜像的数量, 以及 docker 所使用的执行驱动和存储驱动&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建和启动容器, 并运行指定命令&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo docker run  ubuntu ls
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;code&gt;docker run&lt;/code&gt; 命令首先在本地寻找命令指定的镜像 &lt;code&gt;ubuntu&lt;/code&gt;  &lt;br /&gt;
假如没有找到, 那么会在 Docker 官方维护的 Docker Hub Registry 上寻找,一旦找到镜像, 就会下载该镜像并存储到本地  &lt;br /&gt;
接着, &lt;code&gt;docker run &lt;/code&gt; 会以此镜像为基础, 创建并启动一个容器  &lt;br /&gt;
最后在容器中执行命令 &lt;code&gt;ls&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;创建一个具有交互 Shell 的容器&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo docker run -i -t ubuntu /bin/bash
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;code&gt;-i&lt;/code&gt; 保证容器中 &lt;code&gt;STDIN&lt;/code&gt; 是开启的  &lt;br /&gt;
&lt;code&gt;-t&lt;/code&gt; 告诉 Docker 为创建的容器分配一个伪 tty 终端  &lt;br /&gt;
然后指定运行命令 &lt;code&gt;/bin/bash&lt;/code&gt;, 这样新创建的容器才会有一个交互式的 shell&lt;/p&gt;

    &lt;p&gt;如果通过管道与 shell 进行交互,仅仅使用 &lt;code&gt;-i&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; echo &quot;Hello,world&quot; | sudo docker run -i ubuntu cat
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为容器指定主机名 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo docker run --rm -h MwumLi ubuntu hostname
 MwumLi
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;code&gt;-h&lt;/code&gt; 或者 &lt;code&gt;--hostname&lt;/code&gt; 指定容器的主机名&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;端口映射 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; # 随机分配宿主机的端口到 docker 指定端口
 # 从宿主机的端口 `49153~65535` 中随机选一个映射到容器的 80 端口  
 $ sudo docker -d -p 80 ubuntu nginx -g &quot;daemon off;&quot;
 
 # 指定容器与宿主机之间的端口映射关系 `-p 宿主端口:容器端口`  
 # 把宿主机的 8080 端口映射到 Docker 容器的 80 端口上  
 $ sudo docker -d -p 8080:80 ubuntu nginx -g &quot;daemon off;&quot;  
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;code&gt;-p&lt;/code&gt; 指定要暴露的容器端口号, 这个端口号是创建镜像的时候使用 &lt;code&gt;EXPOSE&lt;/code&gt; 指定的端口号(&lt;code&gt;EXPOSE 可以指定多次&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看容器 &lt;code&gt;ps&lt;/code&gt;  &lt;br /&gt;
&lt;code&gt;docker ps&lt;/code&gt; – 列出当前处于运行状态的 docker container  &lt;br /&gt;
&lt;code&gt;docke ps -l&lt;/code&gt; – 列出最后一次运行的容器(包括正在运行和已停止)  &lt;br /&gt;
&lt;code&gt;docker ps -a&lt;/code&gt; – 列出所有的容器（包括正在运行和已停止的）  &lt;br /&gt;
&lt;code&gt;docker ps -n x&lt;/code&gt; – 列出最后 X 个容器(包括运行和停止)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为容器命名 &lt;code&gt;--name&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ docker run --name your-name -i -t ubuntu bash
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;这会创建一个容器名为 &lt;code&gt;your-name&lt;/code&gt; 的容器  &lt;br /&gt;
如果你不使用 &lt;code&gt;--name&lt;/code&gt; 指定，它会随机生成一个名字  &lt;br /&gt;
名称必须在当前环境唯一，如果已经存在同名容器，那么会创建失败, 除非删除原有的容器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重新启动已经停止的容器 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo docker start container_name/container_id
 $ sudo docker restart container_name/container_id
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;附着到容器的会话中 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo docker attach container_name/container_id
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;(你可能还需要按下回车键才能进入会话)   &lt;br /&gt;
这个和 &lt;code&gt;tmux attach&lt;/code&gt; 很相似, 都是重新进入之前的会话&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个守护式容器&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo docker run -d  --name mwum-daemon ubuntu /bin/sh -c &quot;while true; do echo hello,world!; sleep 1; done&quot;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;code&gt;-d&lt;/code&gt; 表示后台运行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看容器日志 &lt;code&gt;logs&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;$ sudo docker logs container_name/container_id
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;如果想监控 docker 的日志, 和 &lt;code&gt;tail -f&lt;/code&gt; 命令非常相似,按 &lt;code&gt;Ctrl+C&lt;/code&gt; 退出日志跟踪&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;$ sudo docker logs -f container_name/container_id
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;查看最后 10 行内容 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;$ sudo docker logs --tail 10 container_name/container_id
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;始终读取最新 10 行日志 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;$ sudo docker logs --tail 10 -f container_name/container_id
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看容器内部的进程 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;$ sudo docker top container_name/container_id
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在运行状态的容器内部运行新进程 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;# 在 docker 容器内部建了个新文件 /etc/new_file
$ sudo docker exec -d container_name/container_id touch /etc/new_file             

# 启动交互式shell
$ sudo docker exec -i -t container_name/container_id bash    
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;停止容器&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;$ sudo docker stop container_name/container_id        # 发送 SIGTERM 信号
$ sudo docker kill container_name/container_id        # 发送 SIGKILL 信号(快速停止容器)
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;code&gt;stop&lt;/code&gt; 和 &lt;code&gt;kill&lt;/code&gt; 都是通过发送信号来实现停止容器  &lt;br /&gt;
&lt;code&gt;kill -s &lt;/code&gt; 指定发送的信号&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自动重启容器 &lt;code&gt;--restart&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;# 无论容器退出代码是什么，都会一直重启
$ sudo docker run --restart=always -d ubuntu command          
	
# 当容器退出代码为非0时，才会自动重启  
$ sudo docker run --restart=on-failure -d ubuntu command  


# 当容器退出代码为非0时，Docker 会尝试重启该容器, 最多重启 5 次  
$ sudo docker run --restart-on-failure:5 -d ubuntu command 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取某个容器的详细信息 &lt;code&gt;inspect&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;$ sudo docker inspect container_name/container_id
$ sudo docker inspect --format='' container_name/container_id     # 返回是否运行, --format 可用来选择查询
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;一次也可指定多个容器  &lt;br /&gt;
&lt;code&gt;--format&lt;/code&gt; 可以指定打印某一项信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删除容器&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;# 容器必须是停止运行状态
$ sudo docker rm container_name/container_id  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;docker--2&quot;&gt;Docker 镜像的命令&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;列出镜像&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo docker images  # 列出所有的镜像  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删除镜像&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo docker rmi image_name/image_id 
 # 删除所有的镜像
 $ sudo docker rmi `docker images -a -q` 
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;镜像删除之前, 必须保证没有使用此镜像的容器; 否则, 删除失败&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拉取仓库中的镜像(比如Ubuntu)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; # 会把顶级仓库中所有 ubuntu 镜像拉下来
 $ sudo docker pull ubuntu     
 # 会把顶级仓库中 tag 为 12.04 的 ubuntu 镜像拉取下来  
 $ sudo docker pull ubuntu:12.04 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;搜索镜像(仓库名或用户名)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo docker search chef
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看镜像详细情形 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo docker inspect image
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看镜像的构建历史 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo docker history image
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;构建镜像&lt;/h2&gt;

&lt;p&gt;这里所说的构建镜像不是真正的创建镜像, 而是基于一个已有的基础镜像构建镜像而已  &lt;br /&gt;
如果想从零开始, 那么参考 : &lt;a href=&quot;https://docs.docker.com/engine/userguide/eng-image/baseimages/&quot;&gt;https://docs.docker.com/engine/userguide/eng-image/baseimages/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;两种构建办法 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code&gt;docker commit&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code&gt;docker build&lt;/code&gt; 配合 &lt;code&gt;Dockerfile&lt;/code&gt; 文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Docker hub 与 Github 的自动化构建(请自行搜索)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;docker-registry&quot;&gt;登录 Docker Registry&lt;/h3&gt;

&lt;p&gt;对于一般用户来说，我们都会选择使用 Docker 公司提供的 Registry : Docker Hub 来作为我们的远程 docker 仓库  &lt;br /&gt;
因此，需要注册一个 Docker Hub 账户&lt;/p&gt;

&lt;p&gt;命令行登录 Docker Hub : &lt;code&gt;sudo docker login&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;认证信息会保存在 &lt;code&gt;~/.docker/config.json&lt;/code&gt;, 以共后面推送使用&lt;/p&gt;

&lt;p&gt;命令行退出 Docker hub : &lt;code&gt;sudo docker logout&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;docker-commit&quot;&gt;docker commit&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;创建一个具有命令交互式的容器&lt;/li&gt;
  &lt;li&gt;在其中修改某些东西后, 安装新软件、修改配置等, 然后 &lt;code&gt;exit&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把当前已修改容器打包成镜像 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo docker commit container username/repository_name
 # 可以指定一些描述信息 :  
 $ sudo docker commit -m &quot;new custom images&quot; --author=&quot;MwumLi&quot; container username/repository_name
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提交过程暂停容器&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ docker commit --pause=false &amp;lt;container_id&amp;gt; .
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在一个运行中的容器中执行提交动作是不被推荐的，这会导致文件处于不一致的状态  &lt;br /&gt;
  现在你可以在提交过程中暂停容器的运行&lt;/p&gt;

&lt;h3 id=&quot;docker-build&quot;&gt;docker build&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;docker build&lt;/code&gt; 指令需要配合一个 &lt;code&gt;Dockerfile&lt;/code&gt; 文件  &lt;br /&gt;
&lt;code&gt;Dockerfile&lt;/code&gt; 是对一个构建过程的描述, 类似于 &lt;code&gt;Vagrant&lt;/code&gt; 的 &lt;code&gt;Vagrantfile&lt;/code&gt;  &lt;br /&gt;
只要建立这个文件，再加上要求的基础镜像, 使用 &lt;code&gt;docker build&lt;/code&gt; 命令就可以构建出一个新的镜像&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;新建目录 &lt;code&gt;static_web&lt;/code&gt;,进入目录，新建文件&lt;code&gt;Dockerfile&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ mkdir static_web &amp;amp;&amp;amp; cd static_web &amp;amp;&amp;amp; touch Dockerfile
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;这个目录会存储你的构建上下文, 构建的时候，Docker 的守护进程就可以访问到这个目录下的文件了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;根据需求, 在 &lt;code&gt;Dockefile&lt;/code&gt; 中写上你的指令  &lt;br /&gt;
Dockefile 指令看目录 : Dockefile&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开始构建 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; static_web $ sudo docker build -t=&quot;username/repository_name:tag&quot; .
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不使用构建缓存 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; static_web $ sudo docker build --no-cache -t=&quot;username/repository_name:tag&quot;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新建 &lt;code&gt;.dockerignore&lt;/code&gt;, 在里面添加不需要发送给 &lt;code&gt;docker daemon&lt;/code&gt; 的文件, 类似于 &lt;code&gt;.gitignore&lt;/code&gt;  &lt;br /&gt;
在构建开始时中,会首先把构建目录下的所有文件发送给 &lt;code&gt;docker daemon&lt;/code&gt;  &lt;br /&gt;
我们可以指定某些文件不用被发送到 &lt;code&gt;docker daemon&lt;/code&gt;, 这样可以加快构建速度&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-2&quot;&gt;构建缓存是什么&lt;/h4&gt;

&lt;p&gt;构建过程是一步一步的, 每一条指令的执行都会进行一次提交, 这样会形成一系列镜像层&lt;/p&gt;

&lt;p&gt;修改 &lt;code&gt;Dockerfile&lt;/code&gt; 中某条指令后再次构建, 那条指令之前的指令就不需要再次执行&lt;/p&gt;

&lt;p&gt;这就是构建缓存&lt;/p&gt;

&lt;p&gt;构建缓存可以说是加快了我们重新构建镜像的速度&lt;/p&gt;

&lt;h2 id=&quot;dockefile&quot;&gt;Dockefile&lt;/h2&gt;

&lt;p&gt;使用数组方式作为命令的参数的时候，请使用双引号，不要使用单引号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 指定基础镜像
FROM ubuntu:14.04  
# 触发器
# 当此镜像作为基础镜像构建新镜像的时候,执行下面 ONBUILD 紧跟的 ADD 命令
# 但是构建生成的子镜像作为基础镜像构建新的镜像的时候, 就不在起作用
# 在子镜像构建过程中紧跟 FROM 指令之后执行
ONBUILD ADD . /app/src

# 添加镜像作者以及email等信息
MAINTAINER MwumLi mwumli@hotmail.com

# 添加环境变量 refreshed
ENV refreshed 2016-03-02

# 指定卷  
# 具体见下文 : 数据共享
VOLUME /opt/data

# 指定镜像会以什么样的用户执行
# 有以下 6 种使用方式
# 默认用户为 root
USER user
USER user:group
USER uid
USER uid:gid
USER user:gid
USER uid:group

# ADD 和 COPY 指令用来把构建上下文目录下的东西复制到镜像中  
# 区别在于 ADD 在复制压缩文件时, 会自动解压  

# 指定镜像构建时要运行的命令: 命令会被执行成 `bash -c &quot;apt-get update&quot;`
# 更新了软件源
RUN apt-get update

# 指定构建时要运行的命令: 命令会直接执行 
# 推荐这种方式, 之后的 CMD 指定也推荐这种语法
# 安装 nginx
RUN [&quot;apt-get&quot;, &quot;install&quot;, &quot;nginx&quot;]

# 告诉 Docker 80 端口将会被容器的应用程序所使用
# 可以指定多次来指定多个端口
# 但 Docker 并不会自动打开这些端口, 需要在使用 docker run 的使用 -p 参数来指定      
EXPOSE 80

# 指定容器被启动时要运行命令  
# 如果 `docker run` 并没有指定要运行的命令，那么会运行 CMD 指定的命令
# 如果 `docker run` 指定运行的命令，那么就执行指定的命令，CMD 就会被忽略
# CMD 只能指定一条运行的命令，如果指定多次，以最后一次为准  
# 默认输出 &quot;Welcome, Here is docker&quot;
CMD [&quot;echo&quot;, &quot;Welcome, Here is docker&quot;]

# 指定容器被启动时要运行的执行
# 但这个和 CMD 有点不一样  
# 如果 `docker run` 命令指定运行的命令，指定命令会被添加到把 ENTRYPOINT 所有参数后面执行
# 如果没有指定, 会把 CMD 中指定的参数添加到 ENTRYPOINT 中参数末尾执行
ENTRYPOINT [&quot;echo&quot;, &quot;进入点&quot;]
CMD [&quot;cmd 作为 ENTRYPOINT 参数&quot;]

# 更改工作目录
# WORKDIR 命令之后的命令执行都在这个 WORKDIR 指定目录下
# 包括最终容器的工作目录(不是用户主目录)
# 默认在 `/root` 下
WORKDIR /home
RUN mkdir MwumLi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;volume-&quot;&gt;VOLUME 与数据共享&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;VOLUME&lt;/code&gt; 是 Dockerfile 中的指令, 用来在 docker 中指定一个卷&lt;/p&gt;

&lt;p&gt;Docker 中的卷类似于虚拟机共享文件夹的概念  &lt;br /&gt;
因此可以通过卷来实现 docker 容器之间, docker 容器与宿主机之间的数据共享&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;容器与宿主机&lt;/h3&gt;

&lt;p&gt;通过指定卷来实现容器与宿主机之间的数据共享&lt;/p&gt;

&lt;p&gt;有两种方式指定卷 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在 Dockerfile 使用 &lt;code&gt;VOLUME&lt;/code&gt; 指令 : &lt;code&gt;VOLUME /opt/data&lt;/code&gt;  &lt;br /&gt;
使用此 Dockerfile 构建镜像, 并以此镜像创建的容器, 会自动在宿主机的 &lt;code&gt;/var/lib/docker/volumes/&lt;/code&gt; 下新建一个文件夹(文件夹名是一串随机字符串)  &lt;br /&gt;
这个文件夹会被挂载在这个容器的 &lt;code&gt;/opt/data&lt;/code&gt; 下  &lt;br /&gt;
如果 &lt;code&gt;/opt/data&lt;/code&gt; 不存在, 那么会自动创建  &lt;br /&gt;
当使用 &lt;code&gt;docker run --rm&lt;/code&gt; 创建容器的时候, 一旦容器停止, 会自动删除容器及其卷&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;命令行中使用 &lt;code&gt;-v&lt;/code&gt; 参数&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; # 这种方式和 `VOLUME` 指令的效果一样
 $ sudo docker run -it -v /opt/data ubuntu bash

 # 宿主机当前目录下的 `data/` 被挂载到容器 `/opt/data` 下
 $ sudo docker run -it -v $PWD/data:/opt/data ubuntu bash
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-4&quot;&gt;容器之间&lt;/h3&gt;

&lt;p&gt;容器之间只要共享卷, 就可以实现数据共享&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;--volumes-from&lt;/code&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -it --volumes-from container debian /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样创建的容器会共享容器 container 的卷, 达到了数据共享的目的&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;容器互联&lt;/h2&gt;

&lt;p&gt;Docker 想要达到的目标是一个容器最好只允许运行一个应用  &lt;br /&gt;
然而目前互联网的应用都是多个应用组合在一起的应用程序栈&lt;/p&gt;

&lt;p&gt;因此，我们需要让每个 docker 容器运行一个单独的应用(比如nginx, mysql, redis 等), 然后通过某种技术实现容器间的互联&lt;/p&gt;

&lt;h3 id=&quot;docker--3&quot;&gt;docker 局域网&lt;/h3&gt;

&lt;p&gt;在安装 Docker 时, 会创建一个新的网络接口 &lt;code&gt;docker0&lt;/code&gt;  &lt;br /&gt;
每个 docker 容器都会在这个接口上分配一个 ip 地址  &lt;br /&gt;
接口 &lt;code&gt;docker0&lt;/code&gt; 是一个虚拟的以太网桥, 用于连接容器和本地宿主网络&lt;/p&gt;

&lt;p&gt;如果进一步查看 Docker 宿主机的其他网络接口, 会发现一系列以 &lt;code&gt;veth*&lt;/code&gt; 接口&lt;/p&gt;

&lt;p&gt;Docker 每创建一个容器就会创建一组互联的网络接口,这组接口就像管道的两端  &lt;br /&gt;
这组接口其中一端作为容器里的 &lt;code&gt;eht0&lt;/code&gt; 接口  &lt;br /&gt;
而另一端命名为 &lt;code&gt;veth*&lt;/code&gt;, 作为宿主机的一个端口  &lt;br /&gt;
这个虚拟网线一端插在名为 &lt;code&gt;docker0&lt;/code&gt; 的网桥上, 另一端插在容器里&lt;/p&gt;

&lt;p&gt;通过把每个 &lt;code&gt;veth*&lt;/code&gt; 接口绑定到 docker0 网桥, Docker 创建了一个虚拟子网  &lt;br /&gt;
这个子网由宿主机和所有的 docker 容器共享&lt;/p&gt;

&lt;h3 id=&quot;link-&quot;&gt;link 互联&lt;/h3&gt;

&lt;p&gt;从上面我们可以得到一个结论 : 宿主机和docker 容器组成了一个虚拟子网, 在这个子网内可以互相访问&lt;/p&gt;

&lt;p&gt;那么互联的方案就可以得到 : 直接通过 子网 IP 相互访问&lt;/p&gt;

&lt;p&gt;但是这样存在这么几个问题 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;应用程序需要对容器的 IP 做硬编码&lt;/li&gt;
  &lt;li&gt;如果重启容器, Docker 会改变容器的 IP 地址&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此, 这种方案并不时最好的方案&lt;/p&gt;

&lt;p&gt;docker 提供了一个参数 &lt;code&gt;--link&lt;/code&gt;, 使用 &lt;code&gt;--link&lt;/code&gt; 实现容器间的互联 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker run --rm -it --name juan  --link redis:db ubuntu:14.04 bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样创建的容器与 &lt;code&gt;redis&lt;/code&gt; 容器连接起来, &lt;code&gt;redis&lt;/code&gt; 被称为子容器, 而新创建的这个 &lt;code&gt;juan&lt;/code&gt; 容器被称为父容器  &lt;br /&gt;
在父容器内部, 会形成这样两个动态更新的信息 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;/etc/hosts&lt;/code&gt; 文件, 发现 &lt;code&gt;db&lt;/code&gt;(与命令行 db 对应)对应一个 ip 地址, 即子容器的地址&lt;/li&gt;
  &lt;li&gt;使用 &lt;code&gt;env | grep DB&lt;/code&gt;(DB 与命令行 db 大写对应) 可以看到与子容器相关的ip、端口环境变量&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当被子容器重启，一旦 ip 地址发生变化，会自动更新链接容器中的 host 以及 环境变量&lt;/p&gt;

&lt;p&gt;通过这些信息, 我们就可以实现父子容器之间的通信, 并且避免了硬编码的问题以及 IP 地址改变的问题&lt;/p&gt;

&lt;p&gt;由于安全原因, 可以强制 Docker 只允许有连接的容器之间互相通信  &lt;br /&gt;
需要在启动 Docker 守护进程时加上 &lt;code&gt;--icc=false&lt;/code&gt; 的标志，就会关闭所有没有连接的容器间的通信&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;一些概念&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Docker 是一系列 Docker 组件的集合, 是一个统称&lt;/li&gt;
  &lt;li&gt;Docker 是一个 C/S 架构的程序&lt;/li&gt;
  &lt;li&gt;Docker 服务端 : 一个守护进程, 管理容器以及响应 Docker 客户端的请求&lt;/li&gt;
  &lt;li&gt;Docker 客户端 : 一个命令行工具, 用户通过它与 Docker 服务端交互, 来操纵和查看容器&lt;/li&gt;
  &lt;li&gt;Docker 镜像 : 类似于操作系统镜像, 可以通过多种方式构建&lt;/li&gt;
  &lt;li&gt;Docker 容器 : 类似一个虚拟机, Docker 镜像运行在 Docker 容器中, 形成一个完整的隔离化的应用程序运行环境&lt;/li&gt;
  &lt;li&gt;Docker Registry : 类似于 git 服务器一样的存在, 代码是开源的，你可以搭建自己的私有 Registry&lt;/li&gt;
  &lt;li&gt;Docker Hub : 类似于 Github 一样的存在, 是 Docker 公司搭建的 Docker Registry 服务, 和 Github 一样公共,免费&lt;/li&gt;
  &lt;li&gt;Docker 仓库: 类似于 Github 上的一个个项目一样&lt;/li&gt;
  &lt;li&gt;Docker 仓库下可以有很多镜像 : 类似同一个 Git 项目的不同 Tag 一样, Docker 仓库下的不同镜像是靠 tag 来区分的&lt;/li&gt;
  &lt;li&gt;Docker 用户仓库命名 : &lt;code&gt;username/repository_name&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Docker 顶层仓库 : &lt;code&gt;repository_name&lt;/code&gt;, 只包含仓库名, 顶层仓库是由 Docker 公司和选定的能提供优质基础镜像的厂商管理  &lt;br /&gt;
用户通常基于这些基础镜像构建自己的镜像  &lt;br /&gt;
同时顶层仓库也代表个厂商和 docker 公司的一种承诺, 即顶层仓库中的镜像是架构良好、安全且最新的&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;某个具体的 Docker 镜像 :  &lt;br /&gt;
用户仓库 : &lt;code&gt;username/repository_name:tag&lt;/code&gt;  &lt;br /&gt;
顶层仓库 : &lt;code&gt;repository_name:tag&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Docker 的镜像的构建和 git 仓库代码提交类似, 同样有 &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pull&lt;/code&gt; 等操作，学习过程中可以类比来看&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;相关链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Understand the architecture : &lt;a href=&quot;https://docs.docker.com/engine/understanding-docker/&quot;&gt;https://docs.docker.com/engine/understanding-docker/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Docker 官网 : &lt;a href=&quot;https://www.docker.com/&quot;&gt;https://www.docker.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>clearfix 引发的思考</title>
   <link href="http://mwumli.github.io/css-clearfix"/>
   <updated>2015-12-24T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/css-clearfix</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;清除浮动&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#clear-&quot; id=&quot;markdown-toc-clear-&quot;&gt;clear 与块级元素&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#collapsing--margins&quot; id=&quot;markdown-toc-collapsing--margins&quot;&gt;避免 Collapsing  margins&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;参考文档　&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;.clearfix:before, 
.clearfix:after {
    content: &quot; &quot;;
    display: table;
}

.clearfix:after {
    clear: both;
}

.clearfix {
    zoom: 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;clearfix&lt;/code&gt; 这个 class 很受前端开发者欢迎  &lt;br /&gt;
主要用它来清除浮动和防止 Collapsing margins (外边距折叠), 且保证跨浏览器的兼容性  &lt;br /&gt;
简述如下 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;zoom: 1&lt;/code&gt; : 为了兼容 IE6/7&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;:before&lt;/code&gt; : 用来防止 top-margin collapse 和保证当 IE6/7 应用 &lt;code&gt;zoom:1&lt;/code&gt; 时的是视觉一致性&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;:after&lt;/code&gt; : 用来清除浮动&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于它的具体讲解可以参考这篇文章 : &lt;a href=&quot;http://nicolasgallagher.com/micro-clearfix-hack/&quot;&gt;http://nicolasgallagher.com/micro-clearfix-hack/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面是我了解 &lt;code&gt;clearfix&lt;/code&gt; 具体作用的一些思考 :&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;清除浮动&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;float: left&lt;/code&gt; 和 &lt;code&gt;float: right&lt;/code&gt; 可以让我们的元素浮动到文档左边和右边  &lt;br /&gt;
因为浮动让元素像漂在水中的叶子一样 “浮” 起来, 脱离标准文档流, 所以不占有原来流空间  &lt;br /&gt;
之后的元素就有可能和浮动元素重叠或完全遮挡消失&lt;/p&gt;

&lt;p&gt;比如，这段代码(没有浮动):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div style=&quot;background: red; width: 150px; height: 80px;&quot;&amp;gt;div1&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;background: green; width: 300px; height: 50px;&quot;&amp;gt;div2&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;background: yellow; width: 100px; height: 100px&quot;&amp;gt;div3&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;background: cyan; width: 250px; height: 60px&quot;&amp;gt;div4&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它的效果是这样的 :  &lt;br /&gt;
&lt;img src=&quot;/assets/imgs/css-clearfix/float-normal.jpg&quot; alt=&quot;float-normal&quot; /&gt;&lt;/p&gt;

&lt;p&gt;给代码增加浮动 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div style=&quot;background: red; width: 150px; height: 80px;&quot;&amp;gt;div1&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;background: green; width: 300px; height: 50px;float: left;&quot;&amp;gt;div2&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;background: yellow; width: 100px; height: 100px&quot;&amp;gt;div3&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;background: cyan; width: 250px; height: 60px&quot;&amp;gt;div4&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果是这样的 :  &lt;br /&gt;
&lt;img src=&quot;/assets/imgs/css-clearfix/float-left.jpg&quot; alt=&quot;float-left&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以很明显的看到, div3 的区域被 div2 遮挡住了&lt;/p&gt;

&lt;p&gt;因此, 清除浮动是一件很有必要的事情, 清除浮动方法很多, 可以参考: &lt;a href=&quot;https://segmentfault.com/a/1190000002616482#articleHeader3&quot;&gt;https://segmentfault.com/a/1190000002616482#articleHeader3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里主要讲述一下 &lt;code&gt;clearfix&lt;/code&gt; 中清除浮动的方法 :&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用一个容器元素包含浮动元素, 给容器元素添加 &lt;code&gt;class=&quot;clearfix&quot;&lt;/code&gt;  &lt;br /&gt;
这样主要利用 &lt;code&gt;:after&lt;/code&gt; psudo-element 给容器元素尾部添加一个空的元素  &lt;br /&gt;
&lt;code&gt;display: table&lt;/code&gt; 让其成为一个块级元素  &lt;br /&gt;
&lt;code&gt;clear:both&lt;/code&gt;保证清除前面的浮动  &lt;br /&gt;
只有块级元素的 &lt;code&gt;clear&lt;/code&gt; 属性会生效. 内联元素并不会(事实上，我并没有找到相关资料来证明，只是我实验多次下的结论)  &lt;br /&gt;
&lt;code&gt;zoom:1&lt;/code&gt; 保证跨浏览器的兼容性(IE6/7), 触发 &lt;code&gt;hasLayout&lt;/code&gt; 属性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;clear-&quot;&gt;clear 与块级元素&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;为什么上面会把 &lt;code&gt;:after&lt;/code&gt; psudo-elemnt 声明为一个块级元素呢?&lt;/strong&gt;  &lt;br /&gt;
那是因为只有块级元素设置 &lt;code&gt;clear&lt;/code&gt; 才会生效, 而内联元素并不会生效  &lt;br /&gt;
(事实上，我并没有找到相关资料来证明这个结论，但是，我实验多次，发现确实如此)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么这里要使用 &lt;code&gt;display: table&lt;/code&gt;，不使用其他的声明呢(比如 &lt;code&gt;block&lt;/code&gt;)?&lt;/strong&gt;  &lt;br /&gt;
&lt;code&gt;:before&lt;/code&gt; 中使用 &lt;code&gt;table&lt;/code&gt; 把其声明为一个 BFC, 而 &lt;code&gt;table&lt;/code&gt; 有能力表示这个元素为一个块级元素  &lt;br /&gt;
所以可能考虑到共用代码, 所以 &lt;code&gt;:after&lt;/code&gt; 中也是用了 &lt;code&gt;display: table&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;collapsing--margins&quot;&gt;避免 Collapsing  margins&lt;/h2&gt;

&lt;p&gt;有两种情况会引起 Collapsing margin :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;父子元素(不一定是直接父子) 之间会发生 margin-top 和 margin-bottom 的折叠  &lt;br /&gt;
(如果之间没有 &lt;code&gt;border、padding、inlne-content、height、min-height、max-height&lt;/code&gt; 分割的话)  &lt;br /&gt;
这篇讨论 &lt;a href=&quot;http://stackoverflow.com/questions/9519841/why-does-this-css-margin-top-style-not-work&quot;&gt;http://stackoverflow.com/questions/9519841/why-does-this-css-margin-top-style-not-work&lt;/a&gt; 很好的演示了这点&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;邻近元素同时设置 margin, 前面的 margin-bottom 和 后面的 margin-top 融合取最大的&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;clearfix&lt;/code&gt; 是这么做的 :&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;父子的话, 给父元素添加 &lt;code&gt;.clearfix&lt;/code&gt;; 紧邻的话，给前一个元素添加 &lt;code&gt;.clearfix&lt;/code&gt;  &lt;br /&gt;
这样主要利用 :before psudo-element 给元素内部前面添加一个空的元素  &lt;br /&gt;
&lt;code&gt;display: table&lt;/code&gt; 保证它是一个 BFC(BFC 可以隔断外边距折叠)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;使用 &lt;code&gt;:before&lt;/code&gt; 和 &lt;code&gt;:after&lt;/code&gt; 最大的好处应该是避免添加 HTML 代码到我们的代码, 破坏代码的整体感&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;clearfix&lt;/code&gt; 的时候, 有的时候不仅仅是为了清除浮动带来的影响，还有防止 Collapsing margins  &lt;br /&gt;
因此，当你发现布局不对的时候，可以试一试&lt;/p&gt;

&lt;p&gt;当然, 在使用前, 请确定 &lt;code&gt;clearfix&lt;/code&gt; 和本文章首部的内容一致&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;参考文档　&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhongxinWang/archive/2013/03/27/2984764.html&quot;&gt;http://www.cnblogs.com/zhongxinWang/archive/2013/03/27/2984764.html&lt;/a&gt;  &lt;br /&gt;
这篇文章主要讲了浮动的影响, 图文并茂, 但是没有 code, 但是对于初学者理解浮动的影响有很大帮助&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000002616482#articleHeader3&quot;&gt;https://segmentfault.com/a/1190000002616482#articleHeader3&lt;/a&gt;  &lt;br /&gt;
这篇文章主要讨论了清除浮动, 还算完全&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://nicolasgallagher.com/micro-clearfix-hack/&quot;&gt;http://nicolasgallagher.com/micro-clearfix-hack/&lt;/a&gt;  &lt;br /&gt;
这是 clearfix 的起源, 分析了 clearfix 的原理&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html&quot;&gt;http://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html&lt;/a&gt;  &lt;br /&gt;
  这里讲了BFC，生成一个 BFC 以及 BFC 的使用,图文并茂, 有 code&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/9519841/why-does-this-css-margin-top-style-not-work&quot;&gt;http://stackoverflow.com/questions/9519841/why-does-this-css-margin-top-style-not-work&lt;/a&gt;  &lt;br /&gt;
这里面讨论了 margin-top 与父元素的 margin-top 的折叠的危害以及解决，一个很好的例子　&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.w3.org/TR/CSS21/box.html#collapsing-margins&quot;&gt;http://www.w3.org/TR/CSS21/box.html#collapsing-margins&lt;/a&gt;  &lt;br /&gt;
英文官方文档, 讲述 collapsing margin 引发的情况&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin_collapsing&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin_collapsing&lt;/a&gt;  &lt;br /&gt;
mdn 上的文章, 讲述 collapsing margin, 中文&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Ubuntu 下搭建 go 运行环境</title>
   <link href="http://mwumli.github.io/run-go-in-ubuntu"/>
   <updated>2015-11-10T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/run-go-in-ubuntu</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#go&quot; id=&quot;markdown-toc-go&quot;&gt;二进制安装 Go&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#go-1&quot; id=&quot;markdown-toc-go-1&quot;&gt;升级 Go&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#go-2&quot; id=&quot;markdown-toc-go-2&quot;&gt;卸载 Go&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#go--helloworld&quot; id=&quot;markdown-toc-go--helloworld&quot;&gt;go 语言版的 HelloWorld&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;参考链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里介绍一下如何搭建 go 语言的编译运行环境以及一个初始 Hello 程序&lt;/p&gt;

&lt;p&gt;Go 有两种构建方式 : 源码安装和二进制安装&lt;/p&gt;

&lt;p&gt;二进制安装比较简单, 这里主要讲述二进制安装&lt;/p&gt;

&lt;h2 id=&quot;go&quot;&gt;二进制安装 Go&lt;/h2&gt;

&lt;p&gt;下载适合你系统的 Go : &lt;a href=&quot;https://golang.org/dl/#featured&quot;&gt;https://golang.org/dl/#featured&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Go 的二进制的会默认假定安装到 &lt;code&gt;/usr/local/go/&lt;/code&gt; 中&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果你 &lt;strong&gt;安装 Go 到默认位置&lt;/strong&gt; , 那么你需要这样做 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz
 $ echo &quot;export PATH=$PATH:/usr/local/go/bin&quot; &amp;gt;&amp;gt; ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你需要 &lt;strong&gt;安装 Go 到指定位置&lt;/strong&gt; (Eg: &lt;code&gt;~/go/&lt;/code&gt;), 那么这样做 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tar -C ~/ -xzf go$VERSION.$OS-$ARCH.tar.gz
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;然后在 &lt;code&gt;~/.bashrc&lt;/code&gt; 末尾添加 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; export GOROOT=$HOME/go
 export PATH=$PATH:$GOROOT/bin
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; : &lt;code&gt;GOROOT&lt;/code&gt; 仅仅在安装 go 到指定位置的时候才需要设置&lt;/p&gt;

&lt;p&gt;只要你的 &lt;code&gt;.bashrc&lt;/code&gt; 生效, 那么你可以通过 &lt;code&gt;go version&lt;/code&gt; 打印当前 go 的版本号来确定是否安装成功&lt;/p&gt;

&lt;h2 id=&quot;go-1&quot;&gt;升级 Go&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;必须卸载已存在的旧的版本&lt;/li&gt;
  &lt;li&gt;按照上述方法安装新的 Go&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;go-2&quot;&gt;卸载 Go&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;删除 go 安装目录, 默认 &lt;code&gt;/usr/local/go/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在 shell 配置文件中去掉 Go 环境变量 &lt;code&gt;GOROOT&lt;/code&gt; 以及 &lt;code&gt;PATH&lt;/code&gt; 中 go 路径的配置&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;go--helloworld&quot;&gt;go 语言版的 HelloWorld&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;hello.go&lt;/code&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello, Wolrd. 你好, 世界.&quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后命令行中直接运行 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go run hello.go
Hello,World. 你好, 世界!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;go run&lt;/code&gt; 包含编译和运行两步&lt;/p&gt;

&lt;p&gt;你可以先生成可执行文件, 然后执行可执行文件, 比如这样 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go build hello.go
$ ls
hello hello.go
$ ./hello
Hello,World. 你好, 世界!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://docscn.studygolang.com/doc/install&quot;&gt;Go 的安装起步&lt;/a&gt;  &lt;br /&gt;
这里有各种系统下 Go 的安装与配置&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://docscn.studygolang.com/doc/code.html&quot;&gt;如何使用 Go 编程&lt;/a&gt;  &lt;br /&gt;
在这里你可以看到一个简单 Go 包的开发  &lt;br /&gt;
并介绍用 go 工具来获取、 构建并安装 Go 包及命令的标准方式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://docscn.studygolang.com/&quot;&gt;Go 语言中文官方文档&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://docs.studygolang.com/&quot;&gt;Go 语言英文官方文档&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://studygolang.com/&quot;&gt;Go 语言中文网&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>Sublime Text 安装与配置的那些事</title>
   <link href="http://mwumli.github.io/sublime-text-such-things"/>
   <updated>2015-11-06T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/sublime-text-such-things</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;安装&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#sublime-text-2&quot; id=&quot;markdown-toc-sublime-text-2&quot;&gt;Sublime Text 2&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#sublime-text-3&quot; id=&quot;markdown-toc-sublime-text-3&quot;&gt;Sublime Text 3&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;系统配置&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;中文输入和搜索&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#dock-&quot; id=&quot;markdown-toc-dock-&quot;&gt;固化在左侧的 dock 里&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;设置默认打开文档&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;注册&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.sublimetext.com/&quot;&gt;Sublime Text&lt;/a&gt; 是一个很好用的编辑器, 无论对于编程还是文本编辑, 都非常不错&lt;/p&gt;

&lt;p&gt;它小巧且速度非常快，支持 &lt;code&gt;Win/Mac/Linux&lt;/code&gt; 等多种平台  &lt;br /&gt;
也同时支持 32 位与 64 位&lt;/p&gt;

&lt;p&gt;它支持各种流行编程语言的语法高亮、代码补全&lt;/p&gt;

&lt;p&gt;它可以像 vim 一样安装插件，增强本身没有的功能，而且有比 Vim 更方便的插件浏览、安装和管理方式    &lt;br /&gt;
只需要一两个命令，就可以方便下载，等待使用&lt;/p&gt;

&lt;p&gt;它收费, 但是它提供免费使用，当然无限期，无限制，只是偶尔提醒你木有购买，而且频率很低，这点让人觉得很赞&lt;/p&gt;

&lt;p&gt;好的软件, 总是要付出软件创作者的巨大的心力, 如果你有足够的金子, 不妨买一个 &lt;a href=&quot;http://www.sublimetext.com/buy&quot;&gt;key&lt;/a&gt; 赞助一下&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;安装&lt;/h2&gt;

&lt;p&gt;Sublimex Text 目前有两个版本 2 和 3, 2 应该属于 LTS(Long Term Support),而 3 是 beta, 不过也算稳定&lt;/p&gt;

&lt;p&gt;至于安装哪个, 取决于你的选择&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下载地址&lt;/strong&gt; :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Sublime Text 2 : &lt;a href=&quot;http://www.sublimetext.com/2&quot;&gt;http://www.sublimetext.com/2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Sulimex Text 3 : &lt;a href=&quot;http://www.sublimetext.com/3&quot;&gt;http://www.sublimetext.com/3&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里只写 Ubuntu 下的安装与配置&lt;/p&gt;

&lt;h3 id=&quot;sublime-text-2&quot;&gt;Sublime Text 2&lt;/h3&gt;

&lt;p&gt;两种安装方式 :  源安装 和 下载压缩包&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;源安装&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo add-apt-repository ppa:webupd8team/sublime-text-2  
$ sudo apt-get update  
$ sudo apt-get install sublime-text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;压缩包安装&lt;/strong&gt; :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下载 Sublime text 2 : &lt;a href=&quot;http://www.sublimetext.com/2&quot;&gt;http://www.sublimetext.com/2&lt;/a&gt;  &lt;br /&gt;
(提供的是一个压缩包, 暂且命名为 Sublime-Text-2.0.2-x64.tar.bz2)&lt;/li&gt;
  &lt;li&gt;解压缩到 &lt;code&gt;/opt&lt;/code&gt; 下 : &lt;code&gt;tar -xjvf Sublime-Text-2.0.2-x64.tar.bz2 -C /opt&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;建立软链接到 &lt;code&gt;/usr/bin&lt;/code&gt; 下 : &lt;code&gt;ln -s /opt/Sublime_Text_2 /usr/bin/subl&lt;/code&gt;  &lt;br /&gt;
(建立在 PATH 变量任意路径下都可以)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;sublime-text-3&quot;&gt;Sublime Text 3&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载 Sublime Text 3: &lt;a href=&quot;http://www.sublimetext.com/3&quot;&gt;http://www.sublimetext.com/3&lt;/a&gt;  &lt;br /&gt;
(提供的是一个 deb 文件, 暂且命名为为 sublime-text_build-3083_amd64.deb)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;命令安装 : &lt;code&gt;sudo dpkg -i sublime-text_build-3083_amd64.deb&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果出现依赖错误, 可以执行 : &lt;code&gt;sudo apt-get install -f&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;系统配置&lt;/h2&gt;

&lt;p&gt;在 Linux , 要想正常使用 Sublime, 你需要做些系统相关的配置&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;中文输入和搜索&lt;/h3&gt;

&lt;p&gt;Ubuntu 下, Sublimex Text 不能输入中文, 这个网上已经给出解决方案&lt;/p&gt;

&lt;p&gt;通过压缩包方式安装 Sublime, 在应用程序搜索中, 不会搜索到 Sublime  &lt;br /&gt;
(按下 Window 键, 就唤起了应用程序搜索面板)&lt;/p&gt;

&lt;p&gt;解决方法如下 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;新建文件 &lt;code&gt;sublime-imfix.c&lt;/code&gt; :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; /*
    
  * sublime-imfix.c Use LD_PRELOAD to interpose some function to fix sublime
  * input method support for linux. By Cjacker Huang &amp;lt;jianzhong.huang at
  * i-soft.com.cn&amp;gt;
  * 
  * gcc -shared -o libsublime-imfix.so sublime_imfix.c `pkg-config --libs
  * --cflags gtk+-2.0` -fPIC LD_PRELOAD=./libsublime-imfix.so sublime_text 
    
  */
    
 #include &amp;lt;gtk/gtk.h&amp;gt;        
 #include &amp;lt;gdk/gdkx.h&amp;gt;
    
 typedef GdkSegment GdkRegionBox;        
    
    
 struct _GdkRegion {
     long            size;
     long            numRects;
     GdkRegionBox   *rects;
     GdkRegionBox    extents;
 };      
 GtkIMContext   *local_context;      
    
 void gdk_region_get_clipbox(const GdkRegion * region, GdkRectangle * rectangle)
 {
    
     g_return_if_fail(region != NULL);
     g_return_if_fail(rectangle != NULL);        
        

     rectangle-&amp;gt;x = region-&amp;gt;extents.x1;
     rectangle-&amp;gt;y = region-&amp;gt;extents.y1;
     rectangle-&amp;gt;width = region-&amp;gt;extents.x2 - region-&amp;gt;extents.x1;
     rectangle-&amp;gt;height = region-&amp;gt;extents.y2 - region-&amp;gt;extents.y1;
     GdkRectangle    rect;       
        

     rect.x = rectangle-&amp;gt;x;
     rect.y = rectangle-&amp;gt;y;
     rect.width = 0;
     rect.height = rectangle-&amp;gt;height;
    
     // The caret width is 2;
     // Maybe sometimes we will make a mistake, but for most of the time, it
     // should be the caret.
     if (rectangle-&amp;gt;width == 2 &amp;amp;&amp;amp; GTK_IS_IM_CONTEXT(local_context)) {
         gtk_im_context_set_cursor_location(local_context, rectangle);
     }
 }       
    
    
 // this is needed, for example, if you input something in file dialog and
 // return back the edit area
 // context will lost, so here we set it again.      
    
    
 static GdkFilterReturn event_filter(GdkXEvent * xevent, GdkEvent * event,
                                     gpointer im_context)
 {
     XEvent         *xev = (XEvent *) xevent;        

     if (xev-&amp;gt;type == KeyRelease &amp;amp;&amp;amp; GTK_IS_IM_CONTEXT(im_context)) {

         GdkWindow      *win = g_object_get_data(G_OBJECT(im_context), &quot;window&quot;);        
    
         if (GDK_IS_WINDOW(win))
             gtk_im_context_set_client_window(im_context, win);
    
     }
    
     return GDK_FILTER_CONTINUE;
 }       
    
    
 void gtk_im_context_set_client_window(GtkIMContext * context,
                                       GdkWindow * window)
 {
    
     GtkIMContextClass *klass;       
    
     g_return_if_fail(GTK_IS_IM_CONTEXT(context));
     klass = GTK_IM_CONTEXT_GET_CLASS(context);
    
     if (klass-&amp;gt;set_client_window)
         klass-&amp;gt;set_client_window(context, window);      
            
     if (!GDK_IS_WINDOW(window))
         return;
    
     g_object_set_data(G_OBJECT(context), &quot;window&quot;, window);

     int             width = gdk_window_get_width(window);
     int             height = gdk_window_get_height(window);     
    
     if (width != 0 &amp;amp;&amp;amp; height != 0) {
    
         gtk_im_context_focus_in(context);
         local_context = context;
     }
    
     gdk_window_add_filter(window, event_filter, context);
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装编译环境 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo apt-ger install build-essential libgtk2.0-dev -y
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编译共享库 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; gcc -shared -o libsublime-imfix.so sublime-imfix.c  `pkg-config --libs --cflags gtk+-2.0` -fPIC
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;移动共享库到 &lt;code&gt;/usr/lib/&lt;/code&gt; 下 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo mv libsublime-imfix.so /usr/lib/
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试一下是否能输入中文 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; LD_PRELOAD=./libsublime-imfix.so subl
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;命令行启动，自动使用共享库 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; echo &quot;LD_PRELOAD=/usr/lib/libsublime-imfix.so subl&quot; &amp;gt;&amp;gt; ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加应用程序菜单,自动使用共享库 :  &lt;br /&gt;
新建 &lt;code&gt;/usr/share/applications/sublime_text.desktop&lt;/code&gt;, 内容如下 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [Desktop Entry]
 Version=1.0
 Type=Application
 Name=Sublime Text
 GenericName=Text Editor
 Comment=Sophisticated text editor for code, markup and prose
 Exec=bash -c 'LD_PRELOAD=/usr/lib/libsublime-imfix.so /opt/sublime_text/sublime_text %F'
 Terminal=false
 MimeType=text/plain;
 Icon=sublime-text
 Categories=TextEditor;Development;
 StartupNotify=true
 Actions=Window;Document;

 [Desktop Action Window]
 Name=New Window
 Exec=bash -c 'LD_PRELOAD=/usr/lib/libsublime-imfix.so /opt/sublime_text/sublime_text -n'
 OnlyShowIn=Unity;

 [Desktop Action Document]
 Name=New File
 Exec=bash -c 'LD_PRELOAD=/usr/lib/libsublime-imfix.so /opt/sublime_text/sublime_text --command new_file'
 OnlyShowIn=Unity;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;重启或注销生效&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;dock-&quot;&gt;固化在左侧的 dock 里&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;通过命令行或者应用程序菜单启动 Sublime&lt;/li&gt;
  &lt;li&gt;在 dock 里会出现 Sublime 的图标, 点击右键，选择&lt;code&gt;lock from Launcher&lt;/code&gt;,然后它就被锁定在 dock 中了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以后你就可以直接可以从 dock 中打开 Sublime&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;设置默认打开文档&lt;/h3&gt;

&lt;p&gt;希望使用 sublime 成为某种特定文档的默认打开方式, 可以这样做 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;右键文件，选择&lt;code&gt;Propertites&lt;/code&gt;（属性）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点击&lt;code&gt;Open With&lt;/code&gt;, &lt;code&gt;Default Application&lt;/code&gt; 下选择&lt;code&gt;Sublime Text&lt;/code&gt;, 点击 &lt;code&gt;Set as default&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样，你双击打开每一个这种类型的文件，都会自动用&lt;code&gt;Sublime Text&lt;/code&gt;打开&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;注册&lt;/h2&gt;

&lt;p&gt;虽然可以一直免费使用，但是弹出来的警告框总是令人很不爽  &lt;br /&gt;
有幸在网络上搜集到一枚 Sublimex Text 2 的注册码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;----- BEGIN LICENSE -----
Andrew Weber
Single User License
EA7E-855605
813A03DD 5E4AD9E6 6C0EEB94 BC99798F
942194A6 02396E98 E62C9979 4BB979FE
91424C9D A45400BF F6747D88 2FB88078
90F5CC94 1CDC92DC 8457107A F151657B
1D22E383 A997F016 42397640 33F41CFC
E1D0AE85 A0BBD039 0E9C8D55 E1B89D5D
5CDB7036 E56DE1C0 EFCC0840 650CD3A6
B98FC99C 8FAC73EE D2B95564 DF450523
------ END LICENSE ------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过，若是大家手头方便的话，不妨支持一下&lt;a href=&quot;http://www.sublimetext.com/buy&quot;&gt;正版&lt;/a&gt;，毕竟辛辛苦苦做一个软件不容易，何况还是这么好的软件(将来可能会更好)&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Ubuntu 下安装 nodejs</title>
   <link href="http://mwumli.github.io/install-nodejs-on-ubuntu"/>
   <updated>2015-11-03T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/install-nodejs-on-ubuntu</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ubuntu-&quot; id=&quot;markdown-toc-ubuntu-&quot;&gt;Ubuntu 下的安装&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;源安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#node-version-manager&quot; id=&quot;markdown-toc-node-version-manager&quot;&gt;Node Version Manager&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;安装&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;各大平台下 nodejs 的安装看这里 : &lt;a href=&quot;https://nodejs.org/en/download/package-manager/#windows&quot;&gt;https://nodejs.org/en/download/package-manager/#windows&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Nodejs 发展比较快, 所以版本更新迭代快&lt;/p&gt;

&lt;h2 id=&quot;ubuntu-&quot;&gt;Ubuntu 下的安装&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;源安装&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Nodejs v5.x&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sL https://deb.nodesource.com/setup_5.x | sudo -E bash -
sudo apt-get install -y nodejs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Nodejs v4.x&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -sL https://deb.nodesource.com/setup_4.x | sudo -E bash -
sudo apt-get install -y nodejs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如你在使用 Ubuntu 12.04 以及更低版本,请升级你的系统, 再进行安装  &lt;br /&gt;
至于原因，看这里 : &lt;a href=&quot;https://github.com/nodesource/distributions/blob/master/OLDER_DISTROS.md&quot;&gt;https://github.com/nodesource/distributions/blob/master/OLDER_DISTROS.md&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;node-version-manager&quot;&gt;Node Version Manager&lt;/h3&gt;

&lt;p&gt;Nodejs 升级迭代很快, 不同的 Nodejs 项目，可能使用的是不同版本的 Nodejs  &lt;br /&gt;
因此, 要维持多个 Nodejs 项目, 那就需要一种工具来管理 nodejs&lt;/p&gt;

&lt;p&gt;这就是 Node Version Manager&lt;/p&gt;

&lt;p&gt;目前, 有两个比较有名的 Node Version Manager : &lt;a href=&quot;https://github.com/tj/n&quot;&gt;n&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/creationix/nvm&quot;&gt;nvm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Github 上 nvm 的 Star 明显是 n 的 2 倍多  &lt;br /&gt;
因此, 这里讲述一下 nvm 的安装与使用&lt;/p&gt;

&lt;p&gt;nvm 项目地址 : &lt;a href=&quot;https://github.com/creationix/nvm&quot;&gt;https://github.com/creationix/nvm&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;安装&lt;/h4&gt;

&lt;p&gt;nvm 给出了自动安装的脚本, 因此你可以用过 &lt;code&gt;wget&lt;/code&gt;, &lt;code&gt;curl&lt;/code&gt; 实现自动安装, 看这里 :&lt;br /&gt;
&lt;a href=&quot;https://github.com/creationix/nvm#install-script&quot;&gt;https://github.com/creationix/nvm#install-script&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里主要讲一下手动安装  &lt;br /&gt;
手动安装可以使你明白自动安装到底做了什么&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装前的准备 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo apt-get install build-essential libssl-dev -y
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;克隆仓库到 &lt;code&gt;~/.nvm&lt;/code&gt; :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; git clone https://github.com/creationix/nvm.git ~/.nvm &amp;amp;&amp;amp; cd ~/.nvm &amp;amp;&amp;amp; git checkout `git describe --abbrev=0 --tags`
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加下面到 &lt;code&gt;~/.bashrc&lt;/code&gt;(&lt;code&gt;~/.profile&lt;/code&gt;或 &lt;code&gt;~/.zshrc&lt;/code&gt;) :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; export NVM_DIR=&quot;$HOME/.nvm&quot;
 [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;amp;&amp;amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-2&quot;&gt;使用&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装一个指定的版本 : &lt;code&gt;nvm install v0.10.32&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装最新的 0.10.x 版本 : &lt;code&gt;nvm install 0.10&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 v0.10.32 版本的 nodejs 去运行 app.js :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; nvm run 0.10.32 node app.js
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示已安装的 v0.10.32 node 的安装路径 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; nvm which v0.10.32
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;node&lt;/code&gt; 代表最新版本的 node, 因此你可以直接在 &lt;code&gt;nvm use&lt;/code&gt;, &lt;code&gt;nvm install&lt;/code&gt;, &lt;code&gt;nvm exec&lt;/code&gt;, &lt;code&gt;nvm which&lt;/code&gt; 中使用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在一个 nodejs 中集成其他版本的 &lt;code&gt;npm&lt;/code&gt; :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; nvm install v5.0 --reinstall-packages-from=4.2
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用系统安装的 node :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; nvm use system
 nvm run system --version
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;列出当前已经安装的 node :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; nvm ls
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;列出当前可以获得的 node :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; nvm ls-remote
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>构建 SSH 隧道 -- 端口转发</title>
   <link href="http://mwumli.github.io/ssh-port-forwarding"/>
   <updated>2015-09-25T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/ssh-port-forwarding</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ssh-&quot; id=&quot;markdown-toc-ssh-&quot;&gt;SSH 隧道&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ssh--1&quot; id=&quot;markdown-toc-ssh--1&quot;&gt;SSH 隧道的类型&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;参数提前说明&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#socks-&quot; id=&quot;markdown-toc-socks-&quot;&gt;动态端口转发 – SOCKS 代理&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;假设&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;命令原型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;实际使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;本地端口转发&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;假设&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;命令原型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;实际使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;远程端口转发&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;假设&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-10&quot; id=&quot;markdown-toc-section-10&quot;&gt;命令原型&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-11&quot; id=&quot;markdown-toc-section-11&quot;&gt;实际应用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ssh--2&quot; id=&quot;markdown-toc-ssh--2&quot;&gt;SSH 一些辅助参数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-12&quot; id=&quot;markdown-toc-section-12&quot;&gt;相关命令&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-13&quot; id=&quot;markdown-toc-section-13&quot;&gt;代理软件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ssh-&quot;&gt;SSH 隧道&lt;/h2&gt;

&lt;p&gt;使用 SSH 可以进行端口转发，从而实现流往某端口的数据被加密后传向另一机器,这个过程形似构造了一条通道，因此也称之为 SSH 隧道(SSH Tunnel)&lt;/p&gt;

&lt;p&gt;使用 SSH 隧道可以让数据被加密并透明地传输到远端系统&lt;/p&gt;

&lt;h3 id=&quot;ssh--1&quot;&gt;SSH 隧道的类型&lt;/h3&gt;

&lt;p&gt;SSH 隧道有三种类型 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;动态端口转发 (socks 代理)&lt;/li&gt;
  &lt;li&gt;本地端口转发&lt;/li&gt;
  &lt;li&gt;远程端口转发&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;参数提前说明&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;bind_address&lt;/code&gt; – 可选的, 监听的网卡地址
    &lt;ol&gt;
      &lt;li&gt;省略 – 取决于  &lt;code&gt;GatewayPorts&lt;/code&gt; 的设置(man 手册可以看到，但是没有在 Ubuntu 14.04中找到)&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;localhost&lt;/code&gt;/&lt;code&gt;127.0.0.1&lt;/code&gt; – 监听 127.0.0.1, 仅能用于本地&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;0.0.0.0&lt;/code&gt;/&lt;code&gt;*&lt;/code&gt; – 监听本机所有网络接口&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;hostX&lt;/code&gt; – 主机 hostX 的 ip 或 域名&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;hostX_port&lt;/code&gt; – 主机hostX 的空闲端口
    &lt;ol&gt;
      &lt;li&gt;0 - 1023 : 特权端口,只能 root 用户才能进行端口转发  &lt;br /&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports&quot;&gt;特权端口列表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;1024 - 65535 : 选择一个没被占用的端口&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;user@hostX&lt;/code&gt; – 用户名为 &lt;code&gt;user&lt;/code&gt; 可以登录主机 hostX&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;socks-&quot;&gt;动态端口转发 – SOCKS 代理&lt;/h2&gt;

&lt;p&gt;支持 SOCKS4 和 SOCKS5 代理&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;假设&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;存在两台主机 host1, host2&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host1 可以 SSH 连接 host2&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以使 host1 某端口的数据发往 host2, host2 根据其应用程序协议发出到指定地址, 就好像是从 host2 直接发出的数据&lt;/p&gt;

&lt;p&gt;可以认为我们搭建了一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_server&quot;&gt;代理服务器(Proxy Server)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;于是就有了下面这个命令 (&lt;code&gt;host1上执行&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;命令原型&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;host1 $ ssh -D [bind_address:]host1_port user@host2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;动态端口转发的过程 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;host1 申请了一个 socket 来监听 &lt;code&gt;bind_address:host1_port&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host1 与 host2 建立一条 ssh 隧道&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当 host1 有请求 &lt;code&gt;bind_address:host1_port&lt;/code&gt;, 请求数据会从 ssh 隧道发往 host2&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host2 收到数据, 根据数据的应用程序协议去发送数据到指定的地址&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;返回数据会按原有路径返还&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-3&quot;&gt;实际使用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;host1 $ ssh -D 127.0.0.1:7070 user@host2
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;chrome 上使用 proxy SwitchySharp 进行代理设置
    &lt;ol&gt;
      &lt;li&gt;新建情景模式 &lt;code&gt;proxy&lt;/code&gt;, 在 &lt;code&gt;socks代理&lt;/code&gt; 那行填入 &lt;code&gt;127.0.0.1&lt;/code&gt; 和 端口那栏填入 &lt;code&gt;7070&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;点击 proxy SwitchySharp 的头标, 勾选 &lt;code&gt;proxy&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Ubuntu 下使用 proxychains 为应用程序设置代理
    &lt;ol&gt;
      &lt;li&gt;安装 – &lt;code&gt;sudo apt-get install proxychains&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;修改配置文件(&lt;code&gt;/etc/proxychains.conf&lt;/code&gt;)的 &lt;code&gt;[ProxyList]&lt;/code&gt; 为自己的代理 : &lt;code&gt;socks4 127.0.0.1 7070&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;让程序使用代理 : &lt;code&gt;proxychains program-name&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以使用 &lt;code&gt;curl&lt;/code&gt; 进行下载验证&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ curl --socks5 localhost:7070 download-link
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-4&quot;&gt;本地端口转发&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;假设&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;存在三台主机 host1, host2, host3&lt;/li&gt;
  &lt;li&gt;host1 和 host3 不能通信&lt;/li&gt;
  &lt;li&gt;host2 可以同时和 host1 与 host3 通信&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此, 我们可以借助 host2 实现 host1 和 host3 的通信&lt;/p&gt;

&lt;p&gt;于是就有了下面这个命令原型(&lt;code&gt;host1 上执行&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;命令原型&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;host1 $ ssh -L [bind_address:]host1_port:host3:host3_port user@host2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本地端口转发的过程 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;绑定 host1 的 &lt;code&gt;bind_address:host1_port&lt;/code&gt;, 与 host2 构建一条 SSH 隧道&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当我们请求 &lt;code&gt;bind_address:host1_port&lt;/code&gt; 时, 请求的数据通过 SSH 隧道到达 host2，host2 就会把数据发送到 host3 的 &lt;code&gt;host3_port&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;返回的数据按照原路返回&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-7&quot;&gt;实际使用&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;通过访问 host1 本地 8080 端口来访问 host3 的 80 端口(host3 已经安装 Web 服务)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; host1 $ ssh -L 8080:host3:80 user@host2
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;执行完成，在 host1 浏览器中 输入 &lt;code&gt;localhost:8080&lt;/code&gt; 即可看到 host3 的 Web 页面  &lt;br /&gt;
如果使用 xshell 等工具访问 host1, 那么可以使用 &lt;code&gt;curl localhost:8080&lt;/code&gt; 来查看 Web 内容&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host1 使用 ssh 登录 host3 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; host1 $ ssh -L 2030:host3:22 user@host2
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;现在你可以在另开一个 host1 终端输入 : &lt;code&gt;ssh -p 2030 user@host3&lt;/code&gt; 去登录 host3&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-8&quot;&gt;远程端口转发&lt;/h2&gt;

&lt;h3 id=&quot;section-9&quot;&gt;假设&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;存在三台主机 host1, host2, host3&lt;/li&gt;
  &lt;li&gt;host1 和 host3 不能相互访问&lt;/li&gt;
  &lt;li&gt;host2 可以和 host3 相互访问&lt;/li&gt;
  &lt;li&gt;host2 可以 ssh 访问 host1&lt;/li&gt;
  &lt;li&gt;host1 不可以访问 host2&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样的话, host1 就不可以 ssh 连接 host2 了，所以本地端口转发就不能用了  &lt;br /&gt;
而 host2 可以 ssh 连接 host1, 那么 host1 就可以借助这条连接与 host3 进行通信&lt;/p&gt;

&lt;p&gt;这就是 SSH 的远程端口转发&lt;/p&gt;

&lt;p&gt;于是就有了下面这个命令原型 (&lt;code&gt;host2 上执行&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;命令原型&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;host2 $ ssh -R [bind_address:]host1_port:host3:host3_port user@host1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;远程端口转发的过程 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;host2 与 host1 构建了一条 ssh 隧道&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host1 申请了一个 socket 随时监听 &lt;code&gt;bind_address:host1_port&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当 host1 有请求 &lt;code&gt;bind_address:host1_port&lt;/code&gt; 时, 请求的数据会从 ssh 隧道 发往 host2&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host2 收到数据, 然后转发数据到 &lt;code&gt;host3:host3_port&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;返回数据按原路径返还&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-11&quot;&gt;实际应用&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;通过访问 host1 本地 8080 端口来访问 host3 的 80 端口(host3 已经安装 Web 服务)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; host2 $ ssh -R 8080:host3:80 user@host1
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;执行完成，在 host1 浏览器中 输入 &lt;code&gt;localhost:8080&lt;/code&gt; 即可看到 host3 的 Web 页面  &lt;br /&gt;
如果使用 xshell 等工具访问 host1, 那么可以使用 &lt;code&gt;curl localhost:8080&lt;/code&gt; 来查看 Web 内容&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host1 使用 ssh 登录 host3 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; host2 $ ssh -R 2030:host3:22 user@host1
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;现在你可以在另开一个 host1 终端输入 : &lt;code&gt;ssh -p 2030 user@host3&lt;/code&gt; 去登录 host3&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;ssh--2&quot;&gt;SSH 一些辅助参数&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;-q&lt;/code&gt; – 安静模式. 抑制警告和诊断信息&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-T&lt;/code&gt; – 不分配伪终端，只是使用隧道&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-N&lt;/code&gt; – 不运行远程命令(仅对端口转发有用)&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-f&lt;/code&gt; – 后台运行
    &lt;ul&gt;
      &lt;li&gt;配合 &lt;code&gt;-N&lt;/code&gt; 一起使用, 否则产生 &lt;code&gt;Cannot fork into background without a command to execute.&lt;/code&gt;的错误&lt;/li&gt;
      &lt;li&gt;或者在命令末尾加上一个简单的命令 : &lt;code&gt;sleep 30&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-n&lt;/code&gt; – 重定向标准输入到 &lt;code&gt;/dev/null&lt;/code&gt;(阻止从标准输入读)&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-o ServerAliveInterval=60&lt;/code&gt; – 让 SSH 每隔一段时间发送一些消息,避免隧道关闭 &lt;code&gt;Write failed: Broken pipe&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;-v&lt;/code&gt; – 打印调试信息&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  ssh -qTfnN -D 7070 xxx@yyy.com	//ssh 后台动态端口转发
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-12&quot;&gt;相关命令&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;查看端口是否占用 : &lt;code&gt;sudo lsof -i :port&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;使用 &lt;code&gt;curl&lt;/code&gt; 下载文档&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-13&quot;&gt;代理软件&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.proxycap.com/download.html&quot;&gt;proxycap&lt;/a&gt; – windows&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.proxifier.com/&quot;&gt;Proxifier&lt;/a&gt; – windows/OS – 全局代理&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://proxychains.sourceforge.net/&quot;&gt;proxychains&lt;/a&gt; – Linux&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/darkk/redsocks&quot;&gt;readsocks&lt;/a&gt; – Linux&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://tsocks.sourceforge.net/&quot;&gt;tsocks&lt;/a&gt; – Linux – 全局代理&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm?utm_source=chrome-app-launcher-info-dialog&quot;&gt;Proxy SwitchySharp&lt;/a&gt; – chrome&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;curl&lt;/code&gt; 支持 socks4/SOCKS5 等代理下载  – 太棒了, 命令行用起来很方便&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>使用 SSH 进行远程操作</title>
   <link href="http://mwumli.github.io/ssh-remote-run-cmd"/>
   <updated>2015-09-23T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/ssh-remote-run-cmd</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ssh-copy-id-&quot; id=&quot;markdown-toc-ssh-copy-id-&quot;&gt;ssh-copy-id 做了什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;做些什么(几个实例)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;远程自动化脚本的实现&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;是否允许分配伪终端&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;参考链接&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用 SSH 可以实现直接在本地对远程主机执行操作&lt;/p&gt;

&lt;h2 id=&quot;ssh-copy-id-&quot;&gt;ssh-copy-id 做了什么&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ ssh-copy-id ifmicro@remote-host  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它实现了这样一个功能 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;把 `~/.ssh/id_rsa.pub` 内容添加到 remote-host 的用户 ifmicro 的用户主目录下的文件 `~/.ssh/authorized_keys` 的末尾  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过命令组合, 我们也可以实现同样的功能 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh ifmicro@remote-host 'mkdir -p .ssh &amp;amp;&amp;amp; cat &amp;gt;&amp;gt; .ssh/authorized_keys &amp;amp;&amp;amp; chmod 600 .ssh/authorized_keys' &amp;lt; ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此, 我们可以得出这样一个结论 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SSH 可以在用户和服务器之间，建立一条通道来实现命令和数据的传输  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;做些什么(几个实例)&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;复制 &lt;code&gt;hello-cpp/&lt;/code&gt; 目录下的东西到远程主机的 &lt;code&gt;~/hello-cpp&lt;/code&gt; 目录下 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tar czv hello-cpp | ssh ifmicro@remote-host 'tar xz'
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将服务器 &lt;code&gt;~/hello-cpp/&lt;/code&gt; 下的东西复制到本地当前目录 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ ssh ifmicro@remote-host 'tar czv hello-cpp' | tar xz
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看服务器的有多少个用户 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ ssh ifmicro@remote-host 'ls .. | wc -w'
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;远程自动化脚本的实现&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
# 这只是一个远程自动化脚本的架构  
remote_auto(){
	ssh -T $1 &amp;lt;&amp;lt;&quot;EOF&quot;
	echo &quot;Hi, I'm in $1, my name is&quot;$(whoami);
	pwd;
	# 这里可以添加更多的命令
	EOF
}

# 这里可以继续添加更多其他服务器执行任务
remote_auto ifmicro@remote-host-1 &amp;amp;
remote_auto ifmicro@remote-host-1 &amp;amp;
...

# 等待所有后台进程结束
wait 
# 做些结果处理
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;自行填充这个脚本中的内容&lt;/li&gt;
  &lt;li&gt;请学习 &lt;a href=&quot;http://www.tldp.org/LDP/abs/html/here-docs.html&quot;&gt;here Document&lt;/a&gt; 的语法&lt;/li&gt;
  &lt;li&gt;根据需求使用 &lt;code&gt;ssh -T&lt;/code&gt; 或 &lt;code&gt;ssh -t&lt;/code&gt; 、&lt;code&gt;ssh -tt&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;是否允许分配伪终端&lt;/h3&gt;

&lt;p&gt;当采用 Here Document 执行命令的时候，可能会出现 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Pseudo-terminal will not be allocated because stdin is not a terminal.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意思是无法分配一个伪终端给这个 ssh 链接&lt;/p&gt;

&lt;p&gt;在伪终端中执行脚本, 可以进行交互  &lt;br /&gt;
而没有伪终端, 则不能进行交互&lt;/p&gt;

&lt;p&gt;因此对于此的解决方案就呼之欲出了 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;禁止分配伪终端 – 使用 &lt;code&gt;ssh -T&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;强制分配伪终端 – 使用 &lt;code&gt;ssh -t&lt;/code&gt;  或 &lt;code&gt;ssh -tt&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里是 &lt;code&gt;man ssh&lt;/code&gt; 中这两个参数的描述 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-T	Disable pseudo-terminal allocation.
-t	Force pseudo-terminal allocation. This can be used to execute arbitrary screen-based 
	programs on a remote machine, which can be very useful, e.g. when implementing menu 
	services. Multiple -t options force tty allocation, even if ssh has no local tty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们上面的自动化脚本框架中使用了 &lt;code&gt;ssh -T&lt;/code&gt;, 是因为对于自动化来说，基本上不用交互的  &lt;br /&gt;
当然也有可能需要交互, 可以考虑 &lt;code&gt;expect&lt;/code&gt; 来实现自动交互&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;参考链接&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.unixmantra.com/2014/03/a-simple-way-to-send-multiple-line-commands-over-ssh.html&quot;&gt;a-simple-way-to-send-multiple-line-commands-over-ssh&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.tldp.org/LDP/abs/html/here-docs.html&quot;&gt;Here Document-en&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://shouce.jb51.net/shell/here-docs.html&quot;&gt;Here Document-zh&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.open-open.com/lib/view/open1415793400445.html&quot;&gt;shell 操作之 read、cat 和 here document&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>使用 SSH 登录服务器</title>
   <link href="http://mwumli.github.io/ssh-login-server"/>
   <updated>2015-09-21T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/ssh-login-server</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#ssh-&quot; id=&quot;markdown-toc-ssh-&quot;&gt;SSH 是什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ssh&quot; id=&quot;markdown-toc-ssh&quot;&gt;安装 SSH&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;两种登陆方式&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;使用密码口令登录服务器&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;验证流程&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;使用公钥实现无密码登录&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;登录流程&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;第一次登录服务器&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;中间人攻击&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;公钥加密技术&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-10&quot; id=&quot;markdown-toc-section-10&quot;&gt;一些思考&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-11&quot; id=&quot;markdown-toc-section-11&quot;&gt;一些相关的文件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-12&quot; id=&quot;markdown-toc-section-12&quot;&gt;待补充&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ssh-&quot;&gt;SSH 是什么&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Secure_Shell&quot;&gt;SSH&lt;/a&gt; 是一个允许两台电脑之间通过安全的连接进行数据交换的网络协议  &lt;br /&gt;
它采用公钥加密技术对传输的数据进行加密, 保证了数据的保密性和完整性&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/OpenSSH&quot;&gt;OpenSSH&lt;/a&gt; 是 SSH 协议的一种实现，是一种比较 popular 的远程登录服务器的软件&lt;/p&gt;

&lt;h2 id=&quot;ssh&quot;&gt;安装 SSH&lt;/h2&gt;

&lt;p&gt;Linux 主机普遍默认安装 OpenSSH&lt;/p&gt;

&lt;p&gt;客户端安装 ssh client 去登录服务器 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install openssh-client
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务器端安装 ssh server 用以验证客户端的登录 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install openssh-server
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;两种登陆方式&lt;/h2&gt;

&lt;p&gt;SSH 提供两种登录服务器的方式 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用密码口令&lt;/li&gt;
  &lt;li&gt;使用公钥实现无密码登录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在此，做出以下假定 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;服务器上的用户名 : &lt;code&gt;ifmicro&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;服务器地址 : &lt;code&gt;remote-host&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;服务器的 SSH 服务监听端口 : &lt;code&gt;22&lt;/code&gt;(默认)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-1&quot;&gt;使用密码口令登录服务器&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;使用&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ ssh ifmicro@remote-host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果本地用户名也是 &lt;code&gt;ifmicro&lt;/code&gt; , 那么 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh ifmicro
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如你的服务器 SSH 服务监听端口是 &lt;code&gt;2222&lt;/code&gt; , 那么 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh -p 2222 ifmicro@remote-host
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-3&quot;&gt;验证流程&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;客户端想服务器发送登录请求&lt;/li&gt;
  &lt;li&gt;服务器收到请求，把自己的公钥发给用户&lt;/li&gt;
  &lt;li&gt;用户使用这个公钥，对自己的密码进行加密，然后发送给服务器&lt;/li&gt;
  &lt;li&gt;服务器用自己的私钥对收到加密后的密码进行解密，如果密码正确，就同意用户登录&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-4&quot;&gt;使用公钥实现无密码登录&lt;/h3&gt;

&lt;h4 id=&quot;section-5&quot;&gt;使用&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;生成公钥和私钥(如果存在，请忽略) :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;

 Generating public/private rsa key pair.
 Enter file in which to save the key (/home/vagrant/.ssh/id_rsa):
 Enter passphrase (empty for no passphrase):
 Enter same passphrase again:
 Your identification has been saved in /home/vagrant/.ssh/id_rsa.
 Your public key has been saved in /home/vagrant/.ssh/id_rsa.pub.
 The key fingerprint is:
 2e:a3:02:c9:f1:bd:bd:d3:2e:85:26:4c:4a:b6:d1:11 your_email@example.com
 The key's randomart image is:
 +--[ RSA 4096]----+
 |     E.          |
 |     .           |
 |    . .          |
 | . + o           |
 |..= B   S        |
 |o. + + + .       |
 | .    B +        |
 |  .  o * .       |
 |   ..  .=.       |
 +-----------------+
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;一路默认即可，生成的私钥和公钥位于 &lt;code&gt;~/.ssh/&lt;/code&gt; : &lt;code&gt;id_rsa&lt;/code&gt;(私钥) 和 &lt;code&gt;id_rsa.pub&lt;/code&gt;(公钥)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把公钥添加到服务器的 &lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt; 末尾:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ ssh-copy-id -i id_rsa.pub ifmicro@remote-host
 /usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
 /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
 ifmicro@remote-host's password:

 Number of key(s) added: 1

 Now try logging into the machine, with:   &quot;ssh 'ifmicro@remote-host'&quot;
 and check to make sure that only the key(s) you wanted were added.
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;可以看到已经成功添加&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 ssh 登录服务器 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ ssh -i ~/.ssh/id_rsa ifmicro@remote-host
 Last login: Tue Sep 22 06:39:30 2015 from 10.18.61.57
 ifmicro@remmote-host $ 
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;如果私钥是 &lt;code&gt;~/.ssh/id_rsa&lt;/code&gt; ，那么可以忽略 &lt;code&gt;-i ~/.ssh/id_isa&lt;/code&gt;  选项  &lt;br /&gt;
否则，请用 &lt;code&gt;-i private_key&lt;/code&gt; 指定私钥&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-6&quot;&gt;登录流程&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;客户端向服务器发送登录请求&lt;/li&gt;
  &lt;li&gt;服务器收到请求后, 向客户端发送一断随机字符串&lt;/li&gt;
  &lt;li&gt;客户端收到字符串，然后用自己的私钥进行加密，发送给服务器&lt;/li&gt;
  &lt;li&gt;服务器用实现客户给的公钥进行解密, 如果解密成功, 证明用户可信，登录成功&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-7&quot;&gt;第一次登录服务器&lt;/h3&gt;

&lt;p&gt;第一次登录服务器 , 系统会有如下提示 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The authenticity of host 'remote-host (10.108.79.5)' can't be established.
RSA key fingerprint is 31:51:f8:e3:53:01:c4:76:af:60:9c:3b:b3:1b:5e:37.
Are you sure you want to continue connecting (yes/no)?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段话意思是本地主机在这之前没有与服务器 remote-host 建立过链接, 无法确定服务器的真实性  &lt;br /&gt;
只知道 RSA 公钥的指纹&lt;sup id=&quot;fnref:fingerprint&quot;&gt;&lt;a href=&quot;#fn:fingerprint&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;，是否要继续连接&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;ssh-keygen&lt;/code&gt; 工具可以生成 SSH 密钥对，其中公钥的长度很长，对于用户来说不容易比较  &lt;br /&gt;
因此对其进行 MD5 计算生成的 128 位指纹进行比较就非常容易了&lt;/p&gt;

&lt;p&gt;为了确认主机的真实性，这里就要求我们事先知道服务器的公钥指纹&lt;/p&gt;

&lt;p&gt;如果你确定这是你要登录的那台服务器，那么输入 &lt;code&gt;yes&lt;/code&gt; 继续连接&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果你采用密码口令登录服务器，那么&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; Warning: Permanently added 'remote-host,10.108.79.5' (RSA) to the list of known hosts.
 Enter passphrase for key '/home/vagrant/.ssh/id_rsa':
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;输入密码，如果密码正确，那么登录成功&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你采用公钥认证登录服务器, 那么输出上面这条 &lt;code&gt;Warning&lt;/code&gt;, 就直接登录上服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一次登录成功后, 服务器的公钥会被保存到文件 &lt;code&gt;$HOME/.ssh/known_hosts&lt;/code&gt; 中  &lt;br /&gt;
下次登录服务器，&lt;code&gt;Warning&lt;/code&gt; 消失&lt;/p&gt;

&lt;p&gt;每个 SSH 用户都有自己的 &lt;code&gt;known_hosts&lt;/code&gt; 文件  &lt;br /&gt;
系统也有一个这样的文件，通常是 &lt;code&gt;/etc/ssh/ssh_known_hosts&lt;/code&gt; 保存一些对所有用户都可信赖的服务器的公钥&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;中间人攻击&lt;/h3&gt;

&lt;p&gt;SSH 之所以可以保证安全，是因为采用了公钥加密信息&lt;/p&gt;

&lt;p&gt;在上面我们可以看到，使用密码口令的真个过程本身是安全的, 但是存在这个一个风险 ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;如果有攻击者截获了用户的登录请求，然后冒充服务器，将伪造后的公钥发送给用户  
用户在不知情或难辨真伪的情况下,用这个伪造密钥进行加密，然后发送给服务器  
然后攻击者又一次截获，获得用伪造密钥加密的密码，然后用自己的私钥进行解密，就得到了用户在服务器上的账号和密码  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于使用口令进行 ssh 登录的情况下，伪造的公钥很难辨别真伪  &lt;br /&gt;
因为公钥都是自己签发的, 没有证书中心 (CA) 公正&lt;/p&gt;

&lt;p&gt;可以设想一下 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;如果攻击者在用户登录服务器时, 截获登录请求，并用伪造的公钥欺骗用户, 那么很容易获取用户在服务上的登录密码  
然后攻击者就可以在服务器上为所欲为(如果有权限的话)
这样, SSH 的安全机制就荡然无存  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是著名的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Man-in-the-middle_attack&quot;&gt;中间人攻击&lt;/a&gt;(Man-in-the-middle attack)&lt;/p&gt;

&lt;p&gt;所以，基于密码的安全认证是无法避免中间人攻击&lt;/p&gt;

&lt;h2 id=&quot;section-9&quot;&gt;公钥加密技术&lt;/h2&gt;

&lt;p&gt;公钥加密技术提供两个密钥 : 公钥(id_rsa.pub) 和 私钥(id_rsa)&lt;/p&gt;

&lt;p&gt;公钥加密技术主要是利用公钥和私钥的互相加密和解密的非对成性 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;公钥加密的文件，只能被私钥解密&lt;/li&gt;
  &lt;li&gt;私钥加密的文件，只能被公钥解密&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;普通的加密技术的加密运算和解密运算使用同样的密钥, 被称作对称密码学&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html&quot;&gt;数字签名是什么&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;一些思考&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;为什么要修改 ssh 服务的默认端口 22 ?  &lt;br /&gt;
默认情况下, ssh 服务的端口为 22, 所以那些骇客们都会先从 22 端口入手, 通过 “暴力手段” 获取登录密码  &lt;br /&gt;
所以, 建议修改 ssh 服务默认端口, 这样能一定程度上过滤掉一些不怀好意的访客  &lt;br /&gt;
(虽然说对有心者并没什么鸟用,但是多做点防护总没坏处)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;ssh-copy-id&lt;/code&gt; 到底做了什么?  &lt;br /&gt;
事实上, ssh-copy-id 做了下面脚本做的事 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ ssh ifmicro@remote-host 'mkdir -p .ssh &amp;amp;&amp;amp; cat &amp;gt;&amp;gt; .ssh/authorized_keys &amp;amp;&amp;amp; chmod 600 .ssh/authorized_keys' &amp;lt; ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-11&quot;&gt;一些相关的文件&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;id_rsa&lt;/code&gt;(私钥) 和 &lt;code&gt;id_rsa.pub&lt;/code&gt;(公钥)
    &lt;ul&gt;
      &lt;li&gt;默认情况下, 位于 &lt;code&gt;~/.ssh/id_rsa&lt;/code&gt;、&lt;code&gt;~/.ssh/id_rsa.pub&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;这是使用 &lt;code&gt;ssh-keygen&lt;/code&gt; 指定 &lt;code&gt;-t rsa&lt;/code&gt; 默认生成的私钥和公钥, 可以在过程中指定生成的文件名&lt;/li&gt;
      &lt;li&gt;默认情况下, ssh 只会读取 &lt;code&gt;~/.sss/id_rsa&lt;/code&gt; 去加密  &lt;br /&gt;
如果使用非默认的私钥, 那么需要在 &lt;code&gt;ssh -i private-key&lt;/code&gt; 或者使用 &lt;code&gt;ssh-agent&lt;/code&gt; 去管理&lt;/li&gt;
      &lt;li&gt;要保持当前文件权限为 &lt;code&gt;600&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;authorized_keys&lt;/code&gt; – 存储来自客户端的公钥
    &lt;ul&gt;
      &lt;li&gt;默认情况下, 位于 &lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;把来自客户端的公钥添加到这个文件中，就可以实现无密码登录&lt;/li&gt;
      &lt;li&gt;要保持当前文件权限为 &lt;code&gt;600&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-12&quot;&gt;待补充&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;ssh-agent 和 ssh 之间的关系&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ssh 端口转发  &lt;br /&gt;
&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html&quot;&gt;SSH原理与运用（二）：远程操作与端口转发&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://wiki.archlinux.org/index.php/Secure_Shell_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)&quot;&gt;Arch Linux&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://help.github.com/articles/generating-ssh-keys/&quot;&gt;Generating SSH keys&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;s. &lt;a href=&quot;http://www.ibm.com/developerworks/cn/aix/library/1006_lisali_sshlogon/#major6&quot;&gt;开发自动化脚本&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:fingerprint&quot;&gt;
      &lt;p&gt;对 RSA 公钥进行 MD5 计算生成的一个 128 位的指纹 &lt;a href=&quot;#fnref:fingerprint&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>用 gitbook 来写书</title>
   <link href="http://mwumli.github.io/gitbook"/>
   <updated>2015-09-07T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/gitbook</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#gitbook-&quot; id=&quot;markdown-toc-gitbook-&quot;&gt;GitBook 是什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gitbook--1&quot; id=&quot;markdown-toc-gitbook--1&quot;&gt;GitBook 能做些什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ubuntu--gitbook-&quot; id=&quot;markdown-toc-ubuntu--gitbook-&quot;&gt;Ubuntu 下 gitbook 的安装&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gitbook--2&quot; id=&quot;markdown-toc-gitbook--2&quot;&gt;用 gitbook 来写书&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gitbook--3&quot; id=&quot;markdown-toc-gitbook--3&quot;&gt;gitbook 的命令小结&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;构建和运行&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#pdfepubmobi&quot; id=&quot;markdown-toc-pdfepubmobi&quot;&gt;生成电子书(PDF、ePub和Mobi)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;指定一个版本&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;管理版本&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#css&quot; id=&quot;markdown-toc-css&quot;&gt;自定义书本的 css&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;用插件来丰富你的书&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;发现插件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;安装插件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;一些插件&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#disqus-----disqushttppluginsgitbookcomplugindisqus&quot; id=&quot;markdown-toc-disqus-----disqushttppluginsgitbookcomplugindisqus&quot;&gt;disqus 评论系统 – &lt;a href=&quot;http://plugins.gitbook.com/plugin/disqus&quot;&gt;disqus&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#autocoverhttppluginsgitbookcompluginautocover&quot; id=&quot;markdown-toc-autocoverhttppluginsgitbookcompluginautocover&quot;&gt;自动化封面 – &lt;a href=&quot;http://plugins.gitbook.com/plugin/autocover&quot;&gt;autocover&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#gitbook--4&quot; id=&quot;markdown-toc-gitbook--4&quot;&gt;GitBook 相关链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gitbook-&quot;&gt;GitBook 是什么&lt;/h2&gt;

&lt;p&gt;GitBook 是一个可以用来构建一本漂亮的电子书的命令行工具&lt;sup id=&quot;fnref:gitbook-online&quot;&gt;&lt;a href=&quot;#fn:gitbook-online&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; , 基于 Node.js&lt;/p&gt;

&lt;p&gt;可以使用 Markdown 文法来写作&lt;/p&gt;

&lt;p&gt;只要你部署好一定的目录结构并且完成书的内容，就能通过命令很方便地转化成网页和其它格式的电子书&lt;/p&gt;

&lt;p&gt;所以，用起来很简单&lt;/p&gt;

&lt;h2 id=&quot;gitbook--1&quot;&gt;GitBook 能做些什么&lt;/h2&gt;

&lt;p&gt;写一本书，听起来有点太高级，但是往往却是如此现实  &lt;br /&gt;
因此，你可以用 GitBook 来写一本属于你自己的书&lt;/p&gt;

&lt;p&gt;至于书的内容，就由你自己来定:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以是你幻想已久的一个世界&lt;/li&gt;
  &lt;li&gt;可以是平时生活中的小常识&lt;/li&gt;
  &lt;li&gt;可以是一本菜谱&lt;/li&gt;
  &lt;li&gt;可以是你整理知识的小册子&lt;/li&gt;
  &lt;li&gt;可以是…&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ubuntu--gitbook-&quot;&gt;Ubuntu 下 gitbook 的安装&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装 nodejs并建立软链接&lt;sup id=&quot;fnref:nodejs&quot;&gt;&lt;a href=&quot;#fn:nodejs&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo apt-get install nodejs -y &amp;amp;&amp;amp; sudo ln -s `which nodejs` /usr/bin/node
&lt;/code&gt;&lt;/pre&gt;

  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装 NPM&lt;sup id=&quot;fnref:npm&quot;&gt;&lt;a href=&quot;#fn:npm&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo apt-get install npm
&lt;/code&gt;&lt;/pre&gt;

  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装 gitbook(全局)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo npm install gitbook-cli -g
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;gitbook--2&quot;&gt;用 gitbook 来写书&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;新建一个项目，命名为 learn-gitbook, 并初始化&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ mkdir learn-gitbook &amp;amp;&amp;amp; cd learn-gitbook
 learn-gitbook $ gitbook init 
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;learn-gitbook 下会生成两个文件 README.md 和 SUMMARY.md&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;构建并运行服务器&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ gitbook serve ./learn-gitbook  --port 4001
 ...
 Starting server ...
 Serving book on http://localhost:4001
 ...
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在浏览器中访问 &lt;code&gt;http://localhost:4001&lt;/code&gt;, 就可以看到一个没有内容的书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改书籍名称&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; learn-gitbook $ echo &quot;#learn gitbook&quot; &amp;gt; README.md
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在浏览器中查看浏览器标签页显示内容的变化&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改书籍介绍的内容&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; learn-gitbook $ echo &quot;GitBook is a command line tool (and Node.js library) for building beautiful books using GitHub/Git and Markdown (or AsciiDoc).&quot; &amp;gt;&amp;gt; README.md
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在浏览器中查看 Introduction 页面的变化&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增加几个章节(Markdown 的列表和链接语法)  &lt;br /&gt;
在 SUMMARY.md 中增加以下内容 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; * [Part I](part1/README.md)
   * [Writing is nice](part1/writing.md)
   * [GitBook is nice](part1/gitbook.md)
 * [Part II](part2/README.md)
   * [We love feedback](part2/feedback_please.md)
   * [Better tools for authors](part2/better_tools.md)
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;重建项目页面和目录 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;learn-gitbook  $ gitbook init		
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在浏览器中查看左边侧边栏的变化：发现有了几个新的章节&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为每个页面增加内容&lt;/p&gt;

    &lt;p&gt;你只要在相应的页面用 Markdown 文法写作&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增加术语页面(GLOSSARY.md)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; learn-gitbook $ touch GLOSSARY.md &amp;amp;&amp;amp; vim GLOSSARY.md		
 # 术语
 这个术语的定义

 # 另外一个术语
 它的定义可以包含粗体和其他所有类型的内嵌式标记...
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;浏览器中你会发现 : 书中有 &lt;code&gt;术语&lt;/code&gt;、&lt;code&gt;另外一个术语&lt;/code&gt; 字样的都被高亮，而且可以点击看到它的解释&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 book.json 中指定 gitbook 版本  &lt;br /&gt;
列出已经安装的版本&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; learn-gitbook $ gitbook versions				
 Versions Installed:

      2.2.0
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;新建 book.json,并指定版本 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; learn-gitbook $ touch book.json &amp;amp;&amp;amp; vim book.json
 {
     &quot;gitbook&quot; : &quot;2.2.0&quot;
 }
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;避免运行 gitbook 时输出警告 : &lt;code&gt;warn: you should specify a gitbook version to use in your book.json, for example: 2.x.x&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定书籍所用语言风格  &lt;br /&gt;
修改 book.json 内容为 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; {
     &quot;gitbook&quot; : &quot;2.2.0&quot;,
     &quot;language&quot; : &quot;cn&quot;
 }
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在浏览器中可以看到侧边栏的 &lt;code&gt;Introduction&lt;/code&gt; 变为 &lt;code&gt;介绍&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为侧边栏顶部增加链接  &lt;br /&gt;
   修改 book.json 内容为 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;{
    &quot;gitbook&quot; : &quot;2.2.0&quot;,
    &quot;language&quot; : &quot;cn&quot;,
    &quot;links&quot; : {
        &quot;sidebar&quot; : {
            &quot;倘若微小&quot; : &quot;http://www.ifmicro.com/&quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在浏览器中可以看到侧边栏顶部增加一个链接，名为 &lt;a href=&quot;http://www.ifmicro.com/&quot;&gt;倘若微小&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后，尽情写下你奇妙的想法，分享给大家吧&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;通过网站分享：把 learn-gitbook/_book 的内容放到一个云服务器上&lt;/li&gt;
  &lt;li&gt;发布电子书到云盘: 生成 pdf、epub、mobi电子书，放到云盘进行分享&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gitbook--3&quot;&gt;gitbook 的命令小结&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;构建和运行&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;初始化项目目录:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ gitbook init
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;会自动生成 SUMMARY.md 中指定的页面目录和页面&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成网站&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ gitbook build book_path output_path
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;构建网页并运行一个小型服务器&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ gitbook serve --port 4001  
 ...
 Serving book on http://localhost:4001
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在浏览器上，访问 http://localhost:4001 , 就可以看到你的书&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;pdfepubmobi&quot;&gt;生成电子书(PDF、ePub和Mobi)&lt;/h3&gt;

&lt;p&gt;第一步 : &lt;a href=&quot;http://www.calibre-ebook.com/download&quot;&gt;安装 calibre&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;第二步 : 执行对应命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ gitbook pdf  book_path  output_path/book_name.pdf
	$ gitbook epub book_path  output_path/book_name.epub
	$ gitbook mobi book_path  output_path/book_name.mobi
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;指定一个版本&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	$ gitbook build book_path --gitbook=2.3.0
	$ gitbook help --gitbook=2.3.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;管理版本&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;查看 gitbook 使用&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ gitbook -h
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看可以获得的所有 GitBook 版本:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ gitbook versions:available  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装最新的 GitBook 版本&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo gitbook versions:install latest
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;css&quot;&gt;自定义书本的 css&lt;/h2&gt;

&lt;p&gt;一般在生成站点时，会有默认的 css (_book/gitbook/style.css)&lt;/p&gt;

&lt;p&gt;你也可以自定义 css，使你的书籍更好看&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;建立 css 文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; learn-gitbook $ mkdir -p assets/css &amp;amp;&amp;amp; cd assets/css &amp;amp;&amp;amp; touch myWebStyle.css myPdfStyle.css myMobiStyle.css myEpubStyle.css
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;在 myStyle.css 写下你的样式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 book.json 中添加&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; {
     &quot;styles&quot; : {
         &quot;website&quot; : &quot;assets/css/myWebStyle.css&quot;,
         &quot;pdf&quot; : &quot;assets/css/myPdfStyle.css&quot;,
         &quot;mobi&quot; : &quot;assets/css/myMobiStyle.css&quot;,
         &quot;epub&quot; : &quot;assets/css/myEpubStyle.css&quot;
     }
 }
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;我分别为 site, pdf, mobi, epub 指定了 css, 那么分别生成它们的时候，会在默认的 css 基础上层叠指定的 css&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;用插件来丰富你的书&lt;/h2&gt;

&lt;p&gt;gitbook 文档推荐插件(主题也是插件的一种)的命名方式:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;gitbook-plugin-X&lt;/li&gt;
  &lt;li&gt;gitbook-theme-X&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;发现插件&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/search?q=gitbook-plugin&quot;&gt;NPM-Search-gitbook-plugin&lt;/a&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; https://www.npmjs.com/search?q=gitbook-plugin
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/search?q=gitbook-theme&quot;&gt;NPM-Search-gitbook-theme&lt;/a&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; https://www.npmjs.com/search?q=gitbook-theme
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://plugins.gitbook.com/&quot;&gt;gitbook 插件官方地址&lt;/a&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; http://plugins.gitbook.com/
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-5&quot;&gt;安装插件&lt;/h3&gt;

&lt;p&gt;一旦你发现你需要的插件，在 book.json 添加:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;plugins&quot;: [&quot;myPlugin&quot;, &quot;anotherPlugin&quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于 gitbook-plugin-X 的插件，请这样安装 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;book-dir $ gitbook install  或者 npm install gitbook-plugin-X
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于 gitbook-theme-X 的插件，请这样安装 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;book-dir $ npm install gitbook-theme-X &amp;amp;&amp;amp; mv node_modules/gitbook-theme-X node_modules/gitbook-plugin-X`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;PS : 具体插件请参照具体插件的文档&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;一些插件&lt;/h3&gt;

&lt;h4 id=&quot;disqus-----disqushttppluginsgitbookcomplugindisqus&quot;&gt;disqus 评论系统 – &lt;a href=&quot;http://plugins.gitbook.com/plugin/disqus&quot;&gt;disqus&lt;/a&gt;&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装 gitbook-plugin-disqus&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo npm install gitbook-plugin-disqus -g
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 book.json 中添加 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; {
     &quot;plugins&quot;: [&quot;disqus&quot;],
     &quot;pluginsConfig&quot;: {
         &quot;disqus&quot;: {
                 &quot;shortName&quot;: &quot;XXXXXXX&quot;
             }
         }  
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;shortName&lt;/code&gt; 是你在 &lt;a href=&quot;https://disqus.com/&quot;&gt;disqus.com&lt;/a&gt; 上创建 website 指定的 shortname&lt;/p&gt;

&lt;h4 id=&quot;autocoverhttppluginsgitbookcompluginautocover&quot;&gt;自动化封面 – &lt;a href=&quot;http://plugins.gitbook.com/plugin/autocover&quot;&gt;autocover&lt;/a&gt;&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;安装 &lt;a href=&quot;https://github.com/Automattic/node-canvas/wiki/_pages&quot;&gt;node-canvas&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装 gitbook-plugin-autocover&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo npm install gitbook-plugin-autocover
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 book.json 中添加 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; {
     &quot;plugins&quot;: [&quot;autocover&quot;],
     &quot;pluginsConfig&quot;: {
         &quot;autocover&quot;: {
             &quot;title&quot;: &quot;My Book&quot;,
             &quot;author&quot;: &quot;Author&quot;,
             &quot;font&quot;: {
                 &quot;size&quot;: null,
                 &quot;family&quot;: &quot;Impact&quot;,
                 &quot;color&quot;: &quot;#FFF&quot;
             },
             &quot;size&quot;: {
                 &quot;w&quot;: 1800,
                 &quot;h&quot;: 2360
             },
             &quot;background&quot;: {
                 &quot;color&quot;: &quot;#09F&quot;
             }
         }
     }
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;gitbook--4&quot;&gt;GitBook 相关链接&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;GitBook 官方文档 : &lt;a href=&quot;https://www.gitbook.com/book/gitbookio/documentation/details&quot;&gt;https://www.gitbook.com/book/gitbookio/documentation/details&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GitBook 项目目录 : &lt;a href=&quot;https://github.com/GitbookIO/gitbook&quot;&gt;https://github.com/GitbookIO/gitbook&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gitbook-cli 项目目录 : &lt;a href=&quot;https://github.com/GitbookIO/gitbook-cli&quot;&gt;https://github.com/GitbookIO/gitbook-cli&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GitBook API Documentation : &lt;a href=&quot;http://developer.gitbook.com/&quot;&gt;http://developer.gitbook.com/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GitBook Enterprise Guide : &lt;a href=&quot;https://www.gitbook.com/book/gitbookio/enterprise-guide/details&quot;&gt;https://www.gitbook.com/book/gitbookio/enterprise-guide/details&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:gitbook-online&quot;&gt;
      &lt;p&gt;还有一个与之同名的在线创建和托管书籍的平台&lt;a href=&quot;https://www.gitbook.com/&quot;&gt;www.gitbook.com&lt;/a&gt; &lt;a href=&quot;#fnref:gitbook-online&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:nodejs&quot;&gt;
      &lt;p&gt;采用软链接解决ubuntu下 nodejs 命令名与 gitbook 内部使用 nodejs 命令名不一致&lt;br /&gt;具体看&lt;a href=&quot;http://stackoverflow.com/questions/18130164/nodejs-vs-node-on-ubuntu-12-04#answer-18130296&quot;&gt;nodejs vs node on ubuntu 12.04&lt;/a&gt; &lt;a href=&quot;#fnref:nodejs&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:npm&quot;&gt;
      &lt;p&gt;Node Package Manager , 一个 nodejs 包管理和分发工具 &lt;br /&gt;&lt;a href=&quot;https://github.com/npm/npm&quot;&gt;NPM Github项目地址&lt;/a&gt; &lt;a href=&quot;#fnref:npm&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>用 tmux 保存工作现场</title>
   <link href="http://mwumli.github.io/tmux"/>
   <updated>2015-05-05T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/tmux</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-&quot; id=&quot;markdown-toc-tmux-&quot;&gt;tmux 是什么?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux--1&quot; id=&quot;markdown-toc-tmux--1&quot;&gt;tmux 的任务会话机制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux&quot; id=&quot;markdown-toc-tmux&quot;&gt;安装 tmux&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-session&quot; id=&quot;markdown-toc-tmux-session&quot;&gt;tmux session&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-window&quot; id=&quot;markdown-toc-tmux-window&quot;&gt;tmux window&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#window&quot; id=&quot;markdown-toc-window&quot;&gt;创建 window&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#window-1&quot; id=&quot;markdown-toc-window-1&quot;&gt;切换 window&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;重命名当前窗口&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-pane&quot; id=&quot;markdown-toc-tmux-pane&quot;&gt;tmux pane&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux--2&quot; id=&quot;markdown-toc-tmux--2&quot;&gt;tmux 的复制&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#copy--&quot; id=&quot;markdown-toc-copy--&quot;&gt;Copy 模式下的复制, 然后粘贴&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;复制&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;粘贴&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#copy-&quot; id=&quot;markdown-toc-copy-&quot;&gt;推荐使用 Copy 模式&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux--3&quot; id=&quot;markdown-toc-tmux--3&quot;&gt;tmux 的配置文件&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;配置文件生效&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux--4&quot; id=&quot;markdown-toc-tmux--4&quot;&gt;一个简单的 tmux 配置文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;自动生成布局&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux--5&quot; id=&quot;markdown-toc-tmux--5&quot;&gt;tmux 在远程服务器中的表现&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;结对编程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux--6&quot; id=&quot;markdown-toc-tmux--6&quot;&gt;tmux 小技巧&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux--command-prompt&quot; id=&quot;markdown-toc-tmux--command-prompt&quot;&gt;tmux 的 command-prompt&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux--7&quot; id=&quot;markdown-toc-tmux--7&quot;&gt;tmux 快捷键帮助&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#send-prefix&quot; id=&quot;markdown-toc-send-prefix&quot;&gt;重新绑定 send-prefix&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux--8&quot; id=&quot;markdown-toc-tmux--8&quot;&gt;tmux 底部状态栏&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;显示钟表&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#pane----&quot; id=&quot;markdown-toc-pane----&quot;&gt;为 pane 显示编号—快速切换&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tmux-1&quot; id=&quot;markdown-toc-tmux-1&quot;&gt;使用tmux的一些问题&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#tmux--vimpowerline&quot; id=&quot;markdown-toc-tmux--vimpowerline&quot;&gt;tmux 和 vim的powerline插件&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;一些自言自语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tmux-&quot;&gt;tmux 是什么?&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;tmux&lt;/code&gt; 是一款非常好用的终端复用器&lt;/p&gt;

&lt;p&gt;可以认为是终端分屏软件，但远远不止…  &lt;br /&gt;
可以认为是 &lt;code&gt;nohup&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 的结合体，但远远不止…  &lt;br /&gt;
可以认为是一款结对编程 ( Pair Programming ) 的软件，但远远不止…&lt;/p&gt;

&lt;p&gt;是的，远远不止…&lt;/p&gt;

&lt;p&gt;不知道怎么去描述，且跟随使用去体会吧&lt;/p&gt;

&lt;h2 id=&quot;tmux--1&quot;&gt;tmux 的任务会话机制&lt;/h2&gt;

&lt;p&gt;当你运行 &lt;code&gt;tmux&lt;/code&gt; 之后，会启动一个 tmux server 来管理 tmux 的 sessions&lt;/p&gt;

&lt;p&gt;tmux server 有且仅有一个，并且在第一个 session 创建时启动， 当最后一个 session 销毁时销毁&lt;/p&gt;

&lt;p&gt;然后有以下几条规则:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个 tmux server 可以有多个 sessions&lt;/li&gt;
  &lt;li&gt;一个 session 可以有多个 window ， 类似终端有多个标签页&lt;/li&gt;
  &lt;li&gt;一个 window 可以有多个 pane, 即分屏&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;session&lt;/code&gt; 可译作 &lt;code&gt;会话&lt;/code&gt;  &lt;br /&gt;
&lt;code&gt;window&lt;/code&gt; 可译作 &lt;code&gt;窗口&lt;/code&gt;  &lt;br /&gt;
&lt;code&gt;pane&lt;/code&gt; 可译作 &lt;code&gt;窗格&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;tmux&quot;&gt;安装 tmux&lt;/h2&gt;

&lt;p&gt;Ubuntu下安装:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install tmux
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;tmux-session&quot;&gt;tmux session&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;快速创建:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;这样创建的 session 被自动用数字命名&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个命名的 session :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux new-session -s session-name
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看当前所有的 sessions :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux list-sessions
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;脱离当前 session : &lt;code&gt;ctrl-b + d&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;脱离当前 session , 你的工作状态依然保留&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果想重新进入之前的 session , 只需:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux attach-session -t session-name
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;这样你又回看到你之前的工作进度了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当你想退出当前 session :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 在终端中输入 `exit`, 直到所有的 window 和 pane 被关闭  
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;这时，你的 session 也被销毁了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;杀死指定的 session :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux kill-session -t session-name
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重命名 session : &lt;code&gt;ctrl-b + $&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;杀死所有的 session :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tmux kill-server
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;因为所有的 sessions 跑在一个 server 上  &lt;br /&gt;
所以只要关掉 tmux server 即可&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;tmux-window&quot;&gt;tmux window&lt;/h2&gt;

&lt;h3 id=&quot;window&quot;&gt;创建 window&lt;/h3&gt;

&lt;p&gt;当你创建一个 session 时，也自动创建一个 window , window 中也会自动创建一个 pane&lt;/p&gt;

&lt;p&gt;在 session 中创建 window :  按下&lt;code&gt;ctrl-b +c&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;window-1&quot;&gt;切换 window&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;切换到下一个窗口 : &lt;code&gt;ctrl-b + n&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切换到上一个窗口 : &lt;code&gt;ctrl-b + p&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;切换到num窗口，num为窗口编号，底部状态栏可看到 : &lt;code&gt;ctrl-b + num&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示当前会话的所有窗口 : &lt;code&gt;ctrl-b + w&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭当前窗口 : &lt;code&gt;ctrl-b + &amp;amp;&lt;/code&gt; 或者 &lt;code&gt;exit&lt;/code&gt; 或者 &lt;code&gt;ctrl + d&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section&quot;&gt;重命名当前窗口&lt;/h3&gt;

&lt;p&gt;按下 &lt;code&gt;ctrl-b + ,&lt;/code&gt;  &lt;br /&gt;
然后输入 window-name 即可&lt;/p&gt;

&lt;h2 id=&quot;tmux-pane&quot;&gt;tmux pane&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;分割一个垂直的窗格 : &lt;code&gt;ctrl-b + &quot;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分割一个水平的窗格 : &lt;code&gt;ctrl-b + %&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;移动到其他窗格 : &lt;code&gt;ctrl-b + Arrow-Up/Down/Left/Right&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭所有窗格 : &lt;code&gt;ctrl-b + !&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tmux--2&quot;&gt;tmux 的复制&lt;/h2&gt;

&lt;p&gt;在没有启动鼠标滚轮时， tmux 可以通过鼠标选中，并复制&lt;/p&gt;

&lt;p&gt;当你用了上面配置文件中的鼠标滚轮启用，那么一般的鼠标选中就不可能了:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;按下 shift, 然后使用鼠标去选中想要copy的内容进行复制操作  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;copy--&quot;&gt;Copy 模式下的复制, 然后粘贴&lt;/h3&gt;

&lt;p&gt;tmux 提供了一种 copy 模式,类似于 vim 的(Esc-v)模式&lt;/p&gt;

&lt;p&gt;按下 &lt;code&gt;ctrl-b + [&lt;/code&gt; 进入 copy 模式&lt;/p&gt;

&lt;p&gt;tmux 的 copy 模式下有两种快捷键模式: vim 和 Emacs  &lt;br /&gt;
当你在配置文件中启用 vim 模式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setw -g mode-keys vi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 copy 模式下， 我们就可以使用 &lt;code&gt;j/k/h/l&lt;/code&gt; 来移动光标了&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;复制&lt;/h4&gt;

&lt;p&gt;在 Copy 模式下，我们这样复制:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;移动光标到复制开始位置&lt;/li&gt;
  &lt;li&gt;按下 &lt;code&gt;Space&lt;/code&gt; 键进入复制模式&lt;/li&gt;
  &lt;li&gt;移动光标选择要复制的内容&lt;/li&gt;
  &lt;li&gt;按下 &lt;code&gt;Enter&lt;/code&gt; 键完成复制&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-2&quot;&gt;粘贴&lt;/h4&gt;

&lt;p&gt;到你要粘贴内容的位置， 使用快捷键 &lt;code&gt;ctrl-b + ]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;刚才复制的内容已经被完美粘贴了&lt;/p&gt;

&lt;h3 id=&quot;copy-&quot;&gt;推荐使用 Copy 模式&lt;/h3&gt;

&lt;p&gt;如果你只是想复制不超过一行文字，那么这两种方式均可，甚至第一种方式更有效率&lt;/p&gt;

&lt;p&gt;如果你想复制多行文本，那么还是使用Copy 模式&lt;/p&gt;

&lt;p&gt;这和 tmux 的实现方式有关,具体请自行探讨&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tmux--3&quot;&gt;tmux 的配置文件&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;配置文件生效&lt;/h3&gt;

&lt;p&gt;配置文件生效有两种方式:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;新建一个 session, &lt;code&gt;.tmux.conf&lt;/code&gt; 中的设置就在此 session 中生效了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在当前 session 中，按下 &lt;code&gt;ctrl-b + :&lt;/code&gt;,然后:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; : source-file ~/.tmux.conf
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;code&gt;.tmux.conf&lt;/code&gt;是 tmux 配置文件的命名，默认位于你的用户主目录下&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;tmux--4&quot;&gt;一个简单的 tmux 配置文件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# This is a tmux configure file
# 取消默认Ctrl+b的前缀绑定，绑定Ctrl+a为新的快捷发送前缀方式
unbind C-o
set -g prefix C-a

# Copy模式下使用vim快捷操作方式
setw -g mode-keys vi

# split window with s/v after C-a
bind s split-window -h
bind v split-window -v

# move into left/Down/Up/Right panes with h/j/k/l after C-a
bind h select-pane -L
bind j select-pane -D
bind k select-pane -U
bind l select-pane -R

# resize panes forward left/right/Down/Up with &amp;lt;/&amp;gt;/-/+ after C-a
bind &amp;lt; resize-pane -L 10
bind &amp;gt; resize-pane -R 10
bind - resize-pane -D 10
bind + resize-pane -U 10

# bind : to command-prompt like vim
# this is the defalut in tmux already
bind : command-prompt

#鼠标可以选中窗格
set-option -g mouse-select-pane on  
#鼠标滚轮可以使用
set-window-option -g mode-mouse on  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;自动生成布局&lt;/h3&gt;

&lt;p&gt;新建一个文件 &lt;code&gt;~/.tmux/mylayout&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;selectp -t 0 #选中第0个窗格
splitw -h -p 50 #将其分成左右两个
selectp -t 1 #选中第一个，也就是右边那个
splitw -v -p 50 #将右边那个分成上下两个
selectp -t 0 #选中第一个
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在 &lt;code&gt;.tmux.conf&lt;/code&gt;	后面添加:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind D source-file ~/.tmux/mylayout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，每次当我们启动 tmux 后， 可以使用 &lt;code&gt;ctrl-b + D&lt;/code&gt; 来生成布局&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tmux--5&quot;&gt;tmux 在远程服务器中的表现&lt;/h2&gt;

&lt;p&gt;如果通过 &lt;code&gt;ssh&lt;/code&gt; 远程登录到服务器，恰好要进行一个很耗时的任务&lt;/p&gt;

&lt;p&gt;我们不可能等待这个任务执行完毕，再去做其他工作&lt;/p&gt;

&lt;p&gt;因此，我们选择了启用一个新的终端来完成其他工作&lt;/p&gt;

&lt;p&gt;但是网络可能很不稳定，你那个耗时任务在执行过程，突然网络掉线，然后，你的 ssh 断掉，然后你的任务挂掉了&lt;/p&gt;

&lt;p&gt;但是我们的任务已经进行了80%，功亏一篑&lt;/p&gt;

&lt;p&gt;是的，你可以选择执行任务时，采用 &lt;code&gt;nohup&lt;/code&gt; ，那样，网络断掉，也不会影响你的任务&lt;/p&gt;

&lt;p&gt;但是你永远也回不到 &lt;em&gt;案发现场&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;案发现场&lt;/em&gt; 在某些情况下很重要&lt;/p&gt;

&lt;p&gt;而且费那么多心思在保证任务完成，现场保留上，实在太浪费了&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;tmux&lt;/code&gt; 完全可以解决这个问题，除非远程服务器挂了&lt;/p&gt;

&lt;p&gt;因此，远程工作的正确方式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh pi@192.168.199.114 
...
Last login: Tue May  5 02:37:14 2015 from 192.168.199.104
pi@raspberrypi ~ $ tmux new-session -s code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，你可在 session 中进行分屏来完成其他工作  &lt;br /&gt;
或者你可以脱离终端， 继续其他操作  &lt;br /&gt;
再或者网络中断，当你重新连接上服务器:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
Last login: Tue May  5 02:37:14 2015 from 192.168.199.104
pi@raspberrypi ~ $ tmux a -t code
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你会发现，哦，我的工作现场依旧完整无缺…&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;结对编程&lt;/h2&gt;

&lt;p&gt;关于结对编程的概念，可以查看维基百科:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://zh.wikipedia.org/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tmux 利用服务器上的同一账户的同一 tmux session 实现的&lt;/p&gt;

&lt;p&gt;两个人打开同一个 tmux session, 一个人所做的改变，会即时的反映到另一个人的终端上&lt;/p&gt;

&lt;p&gt;tmux 基于文本， 所以即使网速慢点也无妨&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tmux--6&quot;&gt;tmux 小技巧&lt;/h2&gt;

&lt;h3 id=&quot;tmux--command-prompt&quot;&gt;tmux 的 command-prompt&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;command-prompt&lt;/code&gt; 是用来输入 tmux 命令的&lt;/p&gt;

&lt;p&gt;tmux 的所有快捷键的功能都是通过命令来实现的&lt;/p&gt;

&lt;p&gt;因此，我们也通过键入命令来实现某种功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;按下 ctrl-b + : 即可打开 command-prompt  
然后，你输入相应命令即可  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;tmux--7&quot;&gt;tmux 快捷键帮助&lt;/h3&gt;

&lt;p&gt;tmux 的快捷键由 send-prefix 和 bind-key 组成&lt;/p&gt;

&lt;p&gt;按下 send-prefix 的同时，按下 bind-key 才唤醒相应的快捷功能&lt;/p&gt;

&lt;p&gt;&lt;code&gt;send-prefix&lt;/code&gt; 是固定的，默认是 &lt;code&gt;ctrl-b&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bind-key&lt;/code&gt; 对应不同的功能绑定了不同的 key, 可以通过以下方式查看:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;按下 `ctrl-b + ?`  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;send-prefix&quot;&gt;重新绑定 send-prefix&lt;/h3&gt;

&lt;p&gt;更换 send-prefix 为 &lt;code&gt;ctrl-a&lt;/code&gt; ,在 tmux 的配置文件(&lt;code&gt;.tmux.conf&lt;/code&gt;)中这样写:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unbind C-b
set -g prefix C-a
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;tmux--8&quot;&gt;tmux 底部状态栏&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;tmux 窗口底部就是状态栏&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;状态栏左边显示 session-name ,并且列出当前所有 window-name ,以及所有 window 当前运行的 process-name&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当前所在 window 旁边会有 &lt;code&gt;*&lt;/code&gt; 提示&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;右边会显示主机名和时间&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-6&quot;&gt;显示钟表&lt;/h3&gt;

&lt;p&gt;按下 &lt;code&gt;ctrl-b + t&lt;/code&gt;, 会在当前 window 的当前 pane 显示当前时间&lt;/p&gt;

&lt;h3 id=&quot;pane----&quot;&gt;为 pane 显示编号—快速切换&lt;/h3&gt;

&lt;p&gt;按下 &lt;code&gt;ctrl-b + q&lt;/code&gt;, 每一个 pane 都会出现一个数字  &lt;br /&gt;
按下想要切换的 pane 显示的数字， 就可以切换到那个 pane&lt;/p&gt;

&lt;h2 id=&quot;tmux-1&quot;&gt;使用tmux的一些问题&lt;/h2&gt;

&lt;h3 id=&quot;tmux--vimpowerline&quot;&gt;tmux 和 vim的powerline插件&lt;/h3&gt;

&lt;p&gt;默认情况下，启动vim, 如果使用了 powerline 插件， 那么会发现颜色显示不正常&lt;/p&gt;

&lt;p&gt;此时，只要你在每次打开 tmux 时启动256色即可，即 &lt;code&gt;tmux -2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们可以在 &lt;code&gt;.bashrc&lt;/code&gt; 末尾添加:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias tmux='tmux -2'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，每次使用 tmux 就会很方便啦&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-7&quot;&gt;一些自言自语&lt;/h2&gt;

&lt;p&gt;任何时候不要太过迷信一件东西&lt;/p&gt;

&lt;p&gt;你知道的, 服务器也会有重启的时候&lt;/p&gt;

&lt;p&gt;及时保存你的编辑，及时提交你的修改，及时备份你的收藏，永远是明智的做法&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>离去</title>
   <link href="http://mwumli.github.io/leave-beijing"/>
   <updated>2015-05-01T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/leave-beijing</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;实习&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;前端的进步&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;离去&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;回家&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;离职咯，嘿嘿，不要误会，只是实习期结束了…&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;实习&lt;/h2&gt;

&lt;p&gt;实习这段时间，我的工作主要是前端方面的(喂，是不是搞错了，我面的是后台呀…)&lt;/p&gt;

&lt;p&gt;对于此，我郁闷好一会儿。  &lt;br /&gt;
不过，未来的学习计划安排有前端，所以也就提前让它生长发芽吧&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;前端的进步&lt;/h3&gt;

&lt;p&gt;同事中有位大哥，前端很厉害，指导了我很多&lt;/p&gt;

&lt;p&gt;之前接触过一些前端 : 基础知识很简单( HTML/CSS/JS ),但是简单也意味着，在某些方面会比较麻烦，比如页面布局，比如网站框架设计&lt;/p&gt;

&lt;p&gt;前端学习阶梯:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;HTML/CSS/JS，基础知识，很必要&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JQuery 的使用 — 这是一门很流行的js框架，我想学习它，非常必要&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Bootstrap 的使用 — 想要快速开发一个响应式网站，那么学习它&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;与后台数据交互和Ajax — 与后台进行数据交互，这是一个必备技能，使用Ajax，也是必备技能&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JS的原型链继承，很重要, 这对学习框架设计(如果你只想写些效果，按照已有的框架设计，那就…)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;看源码 — 研究一下比较流行的插件源码吧,仅仅看书学习,不仅枯燥，而且你的知识只会碎片化  &lt;br /&gt;
 看源码,永远是最有效的学习方式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;写插件 — 你已经学会原型链继承，也吸收了高手们开发插件的经验，那么开始写吧(有想法的时候)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;寻找机会 — 等待一个合适机会，从一个最基本的网站进行构建&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;快速编写 — less,sass,coffeescript …&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nodejs…&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;应该还有很多，目前就只了解到这里  &lt;br /&gt;
以上这些，有些顺序可以提前，学习本无先后，有所需，就得学…&lt;br /&gt;
我也并没有完全掌握这些知识，但是要想成为一个真正的前端，这些步骤时必须的&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;离去&lt;/h2&gt;

&lt;p&gt;下雨了，没想到离去的时候，竟然会下雨&lt;/p&gt;

&lt;p&gt;长安也下雨了&lt;/p&gt;

&lt;p&gt;“青山一道同云雨，明月何曾是两乡”&lt;/p&gt;

&lt;p&gt;最后，再见，帝都…&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;回家&lt;/h2&gt;

&lt;p&gt;我要回来了&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Linux 下 php 扩展安装</title>
   <link href="http://mwumli.github.io/php-extension-install"/>
   <updated>2015-04-24T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/php-extension-install</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;碎碎念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#extensiondir--extension&quot; id=&quot;markdown-toc-extensiondir--extension&quot;&gt;extension_dir 和 extension&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#extensiondir-&quot; id=&quot;markdown-toc-extensiondir-&quot;&gt;extension_dir 实际生效值&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;检验扩展是否应用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#php&quot; id=&quot;markdown-toc-php&quot;&gt;安装并添加php扩展&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#phpize-&quot; id=&quot;markdown-toc-phpize-&quot;&gt;phpize 的安装&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;几个扩展常用扩展安装&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#mccrypt-&quot; id=&quot;markdown-toc-mccrypt-&quot;&gt;MCcrypt 扩展的安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#igbinary-&quot; id=&quot;markdown-toc-igbinary-&quot;&gt;igbinary 扩展的安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#redis-&quot; id=&quot;markdown-toc-redis-&quot;&gt;redis 扩展的安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#mongo-&quot; id=&quot;markdown-toc-mongo-&quot;&gt;mongo 扩展的安装&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;碎碎念&lt;/h2&gt;

&lt;p&gt;通过搭建 &lt;a href=&quot;/lamp-build&quot;&gt;LAMP 环境&lt;/a&gt;, 就可以使用 php 进行动态网站开发&lt;/p&gt;

&lt;p&gt;但有的时候增强 php 对某些特殊功能, 比如对 mongodb 的操纵, redis 的访问等&lt;/p&gt;

&lt;p&gt;这时候, 你就需要为 php 安装并配置相应扩展, 即 extension&lt;/p&gt;

&lt;h2 id=&quot;extensiondir--extension&quot;&gt;extension_dir 和 extension&lt;/h2&gt;

&lt;p&gt;php 有一个变量定义了 extension 在你的系统中的存放位置, 那就是 &lt;code&gt;extension_dir&lt;/code&gt;  &lt;br /&gt;
只有 extension 存放到 &lt;code&gt;extension_dir&lt;/code&gt; 的指定路径, 那么 php 才能正确读取&lt;/p&gt;

&lt;p&gt;关于 &lt;code&gt;extension_dir&lt;/code&gt; :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;默认值 : &lt;code&gt;php -i | grep extension_dir&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重新指定  &lt;br /&gt;
在  &lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt; 进行指定, 比如 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;extension_dir=&quot;/usr/share/php_extension&quot;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;extensiondir-&quot;&gt;extension_dir 实际生效值&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在你的 Apache 目录下新建文件 &lt;code&gt;phpinfo.php&lt;/code&gt;, 内容如下 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; &amp;lt;?php
     phpinfo();
 ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;访问 &lt;code&gt;phpinfo.php&lt;/code&gt;, 搜索 &lt;code&gt;extension_dir&lt;/code&gt;, 可以看到当前 php 寻找 extension 的路径&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-1&quot;&gt;检验扩展是否应用&lt;/h3&gt;

&lt;p&gt;访问 &lt;code&gt;phpinfo.php&lt;/code&gt;，搜索你的扩展，比如 &lt;code&gt;redis&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果你的扩展放到 &lt;code&gt;extension_dir&lt;/code&gt; 并且已经添加到 php 的 apache 配置文件，那么就会搜索到  &lt;br /&gt;
如果没有搜索到 :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;查看 &lt;code&gt;extension_dir&lt;/code&gt; 下有没有你的 extension&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;确认是否在 &lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt; 中添加此 extension, 比如 redis :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [redis]
 extension=redis.so
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;重启服务器 : &lt;code&gt;sudo service apache2 restart&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;可以留言共同讨论或者谷歌&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;php&quot;&gt;安装并添加php扩展&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载并安装下载相应扩展(请自行搜索)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; http://php.net/manual/zh/extensions.php  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加扩展到配置文件&lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt;  &lt;br /&gt;
 (以&lt;code&gt;redis&lt;/code&gt;为例)&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [redis]
 extension=redis.so
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;添加文件末尾即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; sudo service apache2 restart
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;phpize-&quot;&gt;phpize 的安装&lt;/h2&gt;

&lt;p&gt;用 C 开发的 PHP 扩展使用动态链接库的方式编译扩展模块，需要用到 &lt;code&gt;phpize&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个工具在使用 &lt;code&gt;apt-get install php5&lt;/code&gt; 默认情况也是没安装的&lt;/p&gt;

&lt;p&gt;执行以下命令去安装 :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install php5-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;几个扩展常用扩展安装&lt;/h2&gt;

&lt;h3 id=&quot;mccrypt-&quot;&gt;MCcrypt 扩展的安装&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装 : &lt;code&gt;sudo apt-get install php5-mcrypt&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加配置 &lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt;:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [mcrypt]
 extension=mcrypt.so
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;igbinary-&quot;&gt;igbinary 扩展的安装&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装 : &lt;code&gt;sudo pecl install igbinary&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加配置 &lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt;:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;[igbinary]
extension=igbinary.so
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;redis-&quot;&gt;redis 扩展的安装&lt;/h3&gt;

&lt;p&gt;官方文档 : &lt;a href=&quot;https://github.com/phpredis/phpredis#installingconfiguring&quot;&gt;https://github.com/phpredis/phpredis#installingconfiguring&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载, 编辑, 安装 :&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ git clone https://github.com/phpredis/phpredis.git
 $ phpize
 $ ./configure [--enable-redis-igbinary]
 $ make &amp;amp;&amp;amp; sudo make install
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;这样 redis 就被安装在合适的位置  &lt;br /&gt;
如果需要 &lt;code&gt;--enable-redis-igbinary&lt;/code&gt;, 请先进行 &lt;code&gt;igbinary 扩展的安装&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加扩展到配置文件&lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [redis]                            
 extension=redis.so
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;mongo-&quot;&gt;mongo 扩展的安装&lt;/h3&gt;

&lt;p&gt;官方文档: &lt;a href=&quot;http://php.net/manual/zh/mongo.installation.php&quot;&gt;http://php.net/manual/zh/mongo.installation.php&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载，编译，安装:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ git clone https://github.com/mongodb/mongo-php-driver-legacy.git
 $ cd mongo-php-driver-legacy
 $ phpize
 $ ./configure
 $ make all &amp;amp;&amp;amp; sudo make install
 ...
 Installing shared extensions:     
 /usr/lib/php5/20121212+lfs/
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加配置 &lt;code&gt;/etc/php5/apache2/php.ini&lt;/code&gt;:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; [mongo.so]
 extension=mongo.so
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启web服务器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Raspberry Pi安装Debian Wheezy系统</title>
   <link href="http://mwumli.github.io/raspberrypi-install"/>
   <updated>2014-12-06T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/raspberrypi-install</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;碎碎念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;系统安装&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;不同平台下的镜像写入&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;访问&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;和正常计算机一样访问&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ssh&quot; id=&quot;markdown-toc-ssh&quot;&gt;通过ssh远程访问&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;一些必要的小贴士&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vnc&quot; id=&quot;markdown-toc-vnc&quot;&gt;使用VNC远程图形化访问&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;配置&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;更换软件源&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;配置自动连接你的局域网&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;后记&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;碎碎念&lt;/h3&gt;

&lt;p&gt;Raspberry Pi，是一款基于Linux系统的、信用卡大小的单板机电脑  &lt;br /&gt;
它的出现源于一个想&lt;strong&gt;制作一套启发孩子的电脑&lt;/strong&gt;的想法  &lt;br /&gt;
看来一切美好的事情背后总是有一颗让人心动的理念，而这个理念往往才是他们获得流行的动力&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/imgs/640px-RaspberryPi.jpg&quot; alt=&quot;树莓派B2.0简图&quot; title=&quot;树莓派B2.0简图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;系统安装&lt;/h3&gt;
&lt;p&gt;可以用于Raspberry Pi的系统很多，有我们即将安装的Debian Wheezy,还有Arch Linux ARM, RISC OS等等  &lt;br /&gt;
对咯，Debian Wheezy更为常见的称呼是Raspbian,但是为了避免与Raspberry Pix形似，我特意称其为Debian Wheezy,也喜欢这样称呼(嘿嘿…)  &lt;br /&gt;
这些资源都可以送网络上获取，感谢互联网&lt;/p&gt;

&lt;p&gt;为树莓派安装系统很简单，开始咯&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先从&lt;a href=&quot;http://www.raspberrypi.org/downloads/&quot; title=&quot;RaspberryPi OS下载页&quot;&gt;树莓派官网下载页&lt;/a&gt;选择下载Debian Wheezy系统(第一个应该就是),这是树莓派专用系统&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;因为Raspberry Pi是从SD卡启动的(&lt;strong&gt;没有BIOS和其他内部存储设备，只有一个SD卡槽&lt;/strong&gt;)，所以我们需要准备一张SD卡,8G大小(&lt;strong&gt;更大更好，不过it depends&lt;/strong&gt;),把SD卡使用卡托或者读卡器接入你的计算机&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-2&quot;&gt;不同平台下的镜像写入&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Windows
    &lt;ol&gt;
      &lt;li&gt;请下载官方推荐工具&lt;a href=&quot;http://sourceforge.net/projects/win32diskimager/&quot; title=&quot;一个Windows下把原始数据写入可移动设备的工具&quot;&gt;Win32 Disk Imager&lt;/a&gt;，它是一款绿色软件，点击即可使用&lt;/li&gt;
      &lt;li&gt;运行软件，选择我们SD卡盘符，加载我们的Debian Wheezy镜像(&lt;strong&gt;像2014-09-09-wheezy-raspbian.img&lt;/strong&gt;)，最后点击”Write”,等待几分钟写入完成&lt;/li&gt;
      &lt;li&gt;哦，对了，在写入镜像前，你也可以校验镜像的完整性，可以使用&lt;code&gt;fciv&lt;/code&gt;命令生成SHA1校验码与网上公布的码值对比，如果一样，okay，没问题。不过假如你从官网下载镜像与软件以及网络环境没问题，那么应该不会有太大问题问题(&lt;strong&gt;可忽略&lt;/strong&gt;)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Linux
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;校验镜像，使用sha1sum生成SHA1校验码&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; $ sha1sum 2014-09-09-wheezy-raspbian.img 
 57a73544fab3f1163a14903647e55c3998bf9dc9  2014-09-09-wheezy-raspbian.img  
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;查看你的SD卡的准确位置，并确定是否挂载分区&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; $ df -h
 Filesystem      Size  Used Avail Use% Mounted on
 /dev/sda1       103G   37G   61G  38% /
 none            4.0K     0  4.0K   0% /sys/fs/cgroup
 udev            2.0G   12K  2.0G   1% /dev
 tmpfs           393M  1.3M  392M   1% /run
 none            5.0M     0  5.0M   0% /run/lock
 none            2.0G   58M  1.9G   3% /run/shm
 none            100M   40K  100M   1% /run/user
 /dev/sde2       3.6G  1.2G  2.4G  30% /media/mwumli/12C-3244-2342
 /dev/sde1		4.2G	0G	0G	   0% /media/mwumli/43C-2334-4354
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如果挂载，请先卸载所有分区，以免发生错误&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; $ umount /dev/sde1
 $ umount /dev/sde2
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用&lt;code&gt;dd&lt;/code&gt;写入镜像&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt; $ sudo dd bs=1M if=2014-09-09-wheezy-raspbian.img of=/dev/sde 
 [sudo] password for mwumli:
 3125+0 records in
 3125+0 records out
 3276800000 bytes (3.3 GB) copied, 406.802 s, 8.1 MB/s
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;访问&lt;/h3&gt;
&lt;p&gt;把写好的SD卡插入树莓派卡槽，连接上电源&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;和正常计算机一样访问&lt;/h4&gt;
&lt;p&gt;为树莓派配上显示器和键盘，鼠标，这样就和正常的计算机一样访问了   &lt;br /&gt;
但要注意的是USB接口在B2.0上只有两个，就算B+也只有4个  &lt;br /&gt;
同时还要注意电压不足的问题，这个问题好解决，买一个可以接入外接电源的USB集线器&lt;/p&gt;

&lt;h4 id=&quot;ssh&quot;&gt;通过ssh远程访问&lt;/h4&gt;
&lt;p&gt;Debian Wheezy系统默认已经开启ssh服务，所以我们可以通过ssh进行远程访问，对于很多操作，那已足够&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh pi@192.168.199.244
pi@192.168.199.244's password: 
Linux raspberrypi 3.12.28+ #709 PREEMPT Mon Sep 8 15:28:00 BST 2014 armv6l

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Sat Dec  6 23:08:25 2014 from mwumli-k43sa.lan
pi@raspberrypi ~ $ whoami
pi
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-5&quot;&gt;一些必要的小贴士&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;用户名为&lt;code&gt;pi&lt;/code&gt;,密码为&lt;code&gt;raspberry&lt;/code&gt;  &lt;br /&gt;
Debian Wheezy提供一个默认的用户名&lt;code&gt;pi&lt;/code&gt;和密码&lt;code&gt;raspberry&lt;/code&gt;(据说很久之前密码是&lt;code&gt;suse&lt;/code&gt;,假如你足够幸运)  &lt;br /&gt;
&lt;code&gt;raspberry&lt;/code&gt;不是一个很好的密码，因为很多地区的键盘布局并没有设置&lt;code&gt;y&lt;/code&gt;(德国)，假如你是在国外，那么你可以使用&lt;code&gt;raspberrz&lt;/code&gt;来登录&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取你的Raspberry Pi的IP   &lt;br /&gt;
请保证树莓派连接上网络，然后&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;你可以在路由器后台中查看你的树莓派的IP&lt;/li&gt;
      &lt;li&gt;你可以在Windows下使用&lt;a href=&quot;http://abel.oss.aliyuncs.com/file/PortScan.zip&quot; title=&quot;一款Windows下的端口扫描工具&quot;&gt;PortScan&lt;/a&gt;去查看,它会列出当前局域网内所有主机&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;你可以在Linux下使用&lt;code&gt;nmap&lt;/code&gt;&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  $ nmap -sP 192.168.199.0/24  
  Starting Nmap 6.40 ( http://nmap.org ) at 2014-12-07 08:51 CST
  Nmap scan report for Hiwifi.lan (192.168.199.1)
  Host is up (0.39s latency).
  Nmap scan report for mwumli-K43SA.lan (192.168.199.104)
  Host is up (0.00036s latency).
  Nmap scan report for MI2A-xiaomishouji.lan (192.168.199.137)
  Host is up (0.64s latency).
  Nmap scan report for android-e54569f466270a09.lan (192.168.199.226)
  Host is up (0.34s latency).
  Nmap scan report for raspberrypi.lan (192.168.199.244)
  Host is up (0.016s latency).
  Nmap done: 256 IP addresses (5 hosts up) scanned in 14.32 seconds
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体可参考&lt;a href=&quot;http://www.jbxue.com/LINUXjishu/10514.html&quot; title=&quot;Linux 查看局域网内所有主机IP和MAC的方法&quot;&gt;Linux 查看局域网内所有主机IP和MAC的方法&lt;/a&gt;  &lt;br /&gt;
&lt;code&gt;nmap&lt;/code&gt;的介绍可以参考&lt;a href=&quot;http://nmap.org/man/zh/&quot; title=&quot;Nmap的Man手册&quot;&gt;Nmap参考指南&lt;/a&gt;  &lt;br /&gt;
&lt;code&gt;nmap&lt;/code&gt;的使用介绍可以参考&lt;a href=&quot;http://netsecurity.51cto.com/art/200801/63660.htm&quot; title=&quot;端口扫描工具nmap使用介绍&quot;&gt;端口扫描工具namp的使用介绍&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;vnc&quot;&gt;使用VNC远程图形化访问&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Raspberry Pi安装VNC Server&lt;code&gt;tightvncserver&lt;/code&gt;&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ sudo apt-get install tightvncserver  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code&gt;vncpasswd&lt;/code&gt;设置登录密码和一个view-only密码&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ vncpasswd
 You will require a password to access your desktops.

 Password: 
 Verify:   
 Would you like to enter a view-only password (y/n)? n view-only密码仅仅用来查看，所以可以不设置  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启用VNC Server&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ tightvncserver
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在初次启动时，会提示步骤2的过程，之后就不会再提示  &lt;br /&gt;
每启动一次，就会建立一个虚拟屏幕，那个&lt;code&gt;:n&lt;/code&gt;后面的数字n就是虚拟屏幕ID，我们使用VNC Client连接时需要&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在你的计算机中使用VNC Client,客户端很多
    &lt;ul&gt;
      &lt;li&gt;安装chrome浏览器，使用VNC Viewer for Google Chrome插件&lt;/li&gt;
      &lt;li&gt;在这里下在&lt;a href=&quot;https://www.realvnc.com/download/&quot; title=&quot;一个VNC Software站点&quot;&gt;https://www.realvnc.com/download/&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Linux下可以通过命令安装&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;  $ sudo apt-get install vncviewer xtightvncviewer  
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用VNC客户端连接VNC服务端需要两个参数:&lt;code&gt;Pi的IP地址和屏幕的端口地址&lt;/code&gt;  &lt;br /&gt;
VNC端口地址：&lt;code&gt;基础端口(默认5900)+屏幕ID&lt;/code&gt;   &lt;br /&gt;
如果Pi的iP地址为:&lt;code&gt;192.168.199.227&lt;/code&gt;，屏幕ID为:&lt;code&gt;1&lt;/code&gt;  &lt;br /&gt;
那么在Linux下可以这样访问:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ xtightvncviewer 192.168.199.227:5901
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于基础端口一般默认为5901,所以我们直接通过屏幕ID访问&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	$ xtightvncviewer 192.168.199.227:1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他客户端访问一样，在输入地址区域输入:&lt;code&gt;Pi's IP:[base port]+Screen ID&lt;/code&gt;   &lt;br /&gt;
然后选择连接即可&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;配置&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;raspi-config&lt;/code&gt;进行一些重要的系统配置  &lt;br /&gt;
主要是设置合适的区域以及扩展其可用存储空间&lt;/p&gt;

&lt;p&gt;&lt;em&gt;扩展文件系统到SD卡所有空间&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo raspi-config 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了出现一个命令行设置界面，选择第一项&lt;code&gt;Expand Filesystem&lt;/code&gt;,设置完毕，然后重启即可生效&lt;/p&gt;

&lt;p&gt;Raspberry镜像在整个系统中只占用2G空间，即用户8G的SD卡，也只能被使用2G空间，那么一些大的软件将无法安装&lt;/p&gt;

&lt;p&gt;&lt;em&gt;设置区域&lt;/em&gt;   &lt;br /&gt;
每个地区的语言环境不一样，造成我们使用的键盘布局不一样，排序方法不一样，设置合适的区域，便于我们操作  &lt;br /&gt;
而且各个地方的时间并不一致，难道你想坐在大白天看的时间凌晨一点吗?&lt;/p&gt;

&lt;p&gt;当然，假如你有此癖好，就请忽略&lt;/p&gt;

&lt;p&gt;&lt;em&gt;其他设置&lt;/em&gt;  &lt;br /&gt;
按你的需求吧&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;更换软件源&lt;/h3&gt;
&lt;p&gt;树莓派的服务器在国外，在国内访问可能有点慢，额，应该很慢，还有些东西可能因为土啬的原因还下载不了  &lt;br /&gt;
还好Raspberry Pi官方提供了一个镜像列表:&lt;a href=&quot;http://www.raspbian.org/RaspbianMirrors&quot; title=&quot;树莓派软件源列表&quot;&gt;http://www.raspbian.org/RaspbianMirrors&lt;/a&gt;  &lt;br /&gt;
就近原则选择更换吧&lt;/p&gt;

&lt;p&gt;编辑&lt;code&gt;/etc/apt/sources.list&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#deb http://mirrordirector.raspbian.org/raspbian/ wheezy main contrib non-free rpi
deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ wheezy main contrib non-free rpi 
deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ wheezy main non-free contrib rpi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存，更新软件源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我注释了旧的软件源，添加一个中国的软件源&lt;/p&gt;

&lt;p&gt;对咯，使用上面地址打开的是一个目录，然后我们需要进入当前目录的&lt;code&gt;dists&lt;/code&gt;,然后可以看到&lt;code&gt;wheezy&lt;/code&gt;目录,进入&lt;code&gt;wheezy&lt;/code&gt;就可以看到&lt;code&gt;main&lt;/code&gt;,&lt;code&gt;contrib&lt;/code&gt;,&lt;code&gt;non-free&lt;/code&gt;,&lt;code&gt;rpi&lt;/code&gt;目录,每一个软件源的目录结构都是这样的，所以其他软件源的添加都这样办即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;deb http-address wheezy main contrib non-free rpi 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-8&quot;&gt;配置自动连接你的局域网&lt;/h3&gt;
&lt;p&gt;修改/etc/network/interfaces,原内容如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;auto lo 

iface lo inet loopback
iface eth0 inet dhcp

allow-hotplug wlan0
iface wlan0 inet manual
wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf
iface default inet dhcp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改如下:&lt;/p&gt;

&lt;p&gt;#使用localhost&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;auto lo

iface lo inet loopback
iface eth0 inet dhcp

allow-hotplug wlan0 #表示wlan0设备可以热插拔
iface wlan0 inet dhcp
wpa-ssid your-wifi-ssid
wpa-psk your-wifi-passwd

iface default inet dhcp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OKay，以后就会自动连接上你的wifi，假如存在&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;后记&lt;/h3&gt;
&lt;p&gt;刚看到树莓派的时候，就一块布满电路的板子，瞬间有点懵，天生对电路过敏&lt;/p&gt;

&lt;p&gt;但事实上，关于电路的部分，人家已经为你封装好了(&lt;strong&gt;多好的思想,感谢面向对象&lt;/strong&gt;),你只需要会一点软件的知识，痛快的玩就可以了&lt;/p&gt;

&lt;p&gt;文章很长，但还是觉得不够，很多东西还没讲到，但这些应该已经足够&lt;/p&gt;

&lt;p&gt;装系统其实只花费了一小会儿，而写文章却用了4个小时&lt;/p&gt;

&lt;p&gt;希望玩的愉快!…&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Linux下MASM汇编环境搭建</title>
   <link href="http://mwumli.github.io/linux-masm-built"/>
   <updated>2014-12-05T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/linux-masm-built</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;碎碎念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dosbox&quot; id=&quot;markdown-toc-dosbox&quot;&gt;安装dosbox&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#masm&quot; id=&quot;markdown-toc-masm&quot;&gt;下载MASM软件包&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dosbox-1&quot; id=&quot;markdown-toc-dosbox-1&quot;&gt;启动dosbox&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dosbox-2&quot; id=&quot;markdown-toc-dosbox-2&quot;&gt;使用脚本启动dosbox&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#helloworld&quot; id=&quot;markdown-toc-helloworld&quot;&gt;写个汇编版的HelloWorld&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#dosbox-3&quot; id=&quot;markdown-toc-dosbox-3&quot;&gt;在dosbox中编译连接&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;一些自言自语&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;推荐&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;碎碎念&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;MASM&lt;/code&gt;是Microsoft Macro Assembler的缩写，它是微软为x86微处理器家族缩写的一套宏编译器&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dosbox&lt;/code&gt;是一款x86/DOS环境模拟器，可以很好模拟DOS环境,方便我们运行DOS程序&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.asm&lt;/code&gt;是汇编代码的后缀&lt;/p&gt;

&lt;p&gt;好了，现在开始吧！&lt;/p&gt;

&lt;h2 id=&quot;dosbox&quot;&gt;安装dosbox&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install dosbox  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;masm&quot;&gt;下载MASM软件包&lt;/h2&gt;

&lt;p&gt;从这里下载&lt;a href=&quot;http://yun.baidu.com/share/link?shareid=507770005&amp;amp;uk=388194121&quot; title=&quot;masm.tar.bz2&quot;&gt;masm.tar.bz2&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~
$ mkdir -p masm/tools
$ tar xjf Download/masm.tar.bz2 -C masm/tools 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载的文件，解压到新建的文件夹masm/tools下  &lt;br /&gt;
masm即将作为dosbox的C盘&lt;/p&gt;

&lt;h2 id=&quot;dosbox-1&quot;&gt;启动dosbox&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ dosbox -c &quot;mount C: ~/masm/tools&quot; -c &quot;path %path%;C:\tools\&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，dosbox应该出现了，你可以使用&lt;code&gt;debug.exe&lt;/code&gt;,&lt;code&gt;masm.exe&lt;/code&gt;了  &lt;br /&gt;
&lt;code&gt;-c&lt;/code&gt;: 指定dosbox的启动参数  &lt;br /&gt;
&lt;code&gt;mount C: ~/masm/tools&lt;/code&gt;: 把我们用户主目录下的masm/tools作为dosbox的C盘  &lt;br /&gt;
&lt;code&gt;path %path%;C:\tools&lt;/code&gt; : 给path(&lt;em&gt;可执行文件搜索路径&lt;/em&gt;)环境变量添加值，这样，我们无论在哪个目录都可以使用masm软件包的工具了&lt;/p&gt;

&lt;h2 id=&quot;dosbox-2&quot;&gt;使用脚本启动dosbox&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;dosbox_setup.sh&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
dosbox -c &quot;mount C: ~masm&quot; -c &quot;path %path%;C:\tools\&quot; &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为dosbox_setup.sh添加执行权限&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod a+x dosbox_setup.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，你可以通过运行此脚本打开dosbox,而且路径已经配置好了&lt;/p&gt;

&lt;h2 id=&quot;helloworld&quot;&gt;写个汇编版的HelloWorld&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;hello.asm&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assume cs:codes, ds:datas
datas segment
		str db 'hello,world',13,10,'$'
datas ends
codes segment
	start:
		mov ax, datas
		mov ds, ax
		lea dx, str
		mov ah, 9
		int 21h
		mov ah, 4ch
		int 21h
codes ends
	end start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用vim写代码(当然如果你嫌影响你的心情的话，可以使用&lt;code&gt;EDIT.COM&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;dosbox-3&quot;&gt;在dosbox中编译连接&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;C:\&amp;gt; masm hello.asm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译生成hello.obj的连接文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\&amp;gt; link hello.obj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连接生成hello.exe的可执行文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C:\&amp;gt; hello.exe
hello,world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此结束&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;一些自言自语&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;为什么选择MASM呢？&lt;/em&gt;  &lt;br /&gt;
事实上，各大高校的汇编语言学习都是使用MASM的语法，而Linux下的NASM的语法和其还是有些差异的  &lt;br /&gt;
(不要问我为何在Linux下使用MASM，我能告诉你这是我的偏执吗?嘿嘿…)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;为什么还要学习汇编?&lt;/em&gt;    &lt;br /&gt;
这个各人有个人的理由吧，而我只是单纯想了解一下底层程序的运行机制&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;推荐&lt;/h2&gt;

&lt;p&gt;对于汇编学习，推荐王爽先生的《汇编语言》  &lt;br /&gt;
对于dosbox的其他用法，请使用Linux下的&lt;code&gt;man dosbox&lt;/code&gt;  &lt;br /&gt;
对于其它问题，请留言或者google&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>简单的DNS讲解</title>
   <link href="http://mwumli.github.io/dns"/>
   <updated>2014-11-05T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/dns</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#dns&quot; id=&quot;markdown-toc-dns&quot;&gt;DNS是什么&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#linuxdns&quot; id=&quot;markdown-toc-linuxdns&quot;&gt;Linux下的一些用于DNS查询的命令&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tcpdumpdns&quot; id=&quot;markdown-toc-tcpdumpdns&quot;&gt;使用tcpdump观察DNS通信过程&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#dns-1&quot; id=&quot;markdown-toc-dns-1&quot;&gt;修改DNS&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dns&quot;&gt;DNS是什么&lt;/h2&gt;

&lt;p&gt;DNS，可以看作Domain Name Service，Domain Name Server, Domain Name System的缩写，网上也没有统一的解释,说明是哪一种的缩写,我们暂且先不管它&lt;/p&gt;

&lt;p&gt;早期互联网的时代，我们使用IP地址访问网站  &lt;br /&gt;
由于IPV4(IPv6)地址的难以记忆，人们用了一种转换的思想:&lt;code&gt;使用人类容易记忆的名字来代替IP地址,然后通过某种服务把域名转化成IP&lt;/code&gt;，这样，就可以实现精确的定位  &lt;br /&gt;
而这个名字就是域名,例如耳熟能详的百度首页&lt;code&gt;www.baidu.com&lt;/code&gt;,我们学校的论坛&lt;code&gt;www.xiyoubbs.com&lt;/code&gt;  &lt;br /&gt;
这种服务就是域名解析服务，我们用来提供服务的服务器就被称作域名解析服务器&lt;/p&gt;

&lt;p&gt;事实上,我们通常把域名服务，域名服务器都可以称作DNS，理解了域名解析服务的工作原理，就很容易明白我们交流，或者其他文献中简称DNS时，它所代表的真实含义  &lt;br /&gt;
#### DNS的两种查询方式  &lt;br /&gt;
分别是递归查询和迭代查询&lt;/p&gt;

&lt;p&gt;所谓&lt;em&gt;递归查询&lt;/em&gt;：如果目标DNS服务器无法解析某个主机名,则它将向其他DNS服务器继续查询，如此递归，知道获得结果并把结果返回给客户&lt;/p&gt;

&lt;p&gt;所谓&lt;em&gt;迭代查询&lt;/em&gt;：如果目标DNS服务器无法解析某个主机名，则它将已知道的其他DNS服务器的IP地址返回给客户端，以供客户端参考&lt;/p&gt;

&lt;p&gt;一般默认都是递归查询&lt;/p&gt;

&lt;h3 id=&quot;linuxdns&quot;&gt;Linux下的一些用于DNS查询的命令&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ping命令，不仅可以判断网络是否畅通，还可以用域名ping外网时，查看域名对应的主机IP&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ ping www.baidu.com
  PING www.a.shifen.com (61.135.169.125) 56(84) bytes of data.
  64 bytes from 61.135.169.125: icmp_seq=1 ttl=53 time=19.7 ms
  64 bytes from 61.135.169.125: icmp_seq=2 ttl=53 time=21.1 ms
  64 bytes from 61.135.169.125: icmp_seq=3 ttl=53 time=20.0 ms
  ...
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;host命令,一个DNS查询工具&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ host -t A www.baidu.com  
  www.baidu.com is an alias for www.a.shifen.com.
  www.a.shifen.com has address 61.135.169.121
  www.a.shifen.com has address 61.135.169.125  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tcpdumpdns&quot;&gt;使用tcpdump观察DNS通信过程&lt;/h3&gt;
&lt;p&gt;tcpdump是Linux下的一个抓包工具  &lt;br /&gt;
(Linux下各种服务所对应的端口，可以在&lt;code&gt;/etc/services&lt;/code&gt;看到)  &lt;br /&gt;
在一个终端A输入一下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo tcpdump -i wlan0 -nt port domain 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后开启另一个终端B,输入一下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ host -t -A www.baidu.com  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以在终端A下看到:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IP 172.24.243.3.21645 &amp;gt; 172.24.243.1.53: 18340+ A? www.baidu.com. (31)
IP 172.24.243.1.53 &amp;gt; 172.24.243.3.21645: 18340 3/0/0 CNAME www.a.shifen.com., A 115.239.211.110, A 115.239.210.27 (138)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cpdump以“IP地址.端口号”的形式来描述通信的某一端；以“&amp;gt;”表示数据传输的方向，“&amp;gt;”前面是源端，后面是目的端。&lt;/p&gt;

&lt;p&gt;目标端口53是DNS服务使用的端口&lt;/p&gt;

&lt;p&gt;第一个数据包是我的机器(172.24.243.3)发送的DNS查询报文  &lt;br /&gt;
第二个数据包是服务器反馈的DNS应答报文&lt;/p&gt;

&lt;p&gt;第一个数据包中，数值18340是DNS查询报文的标识值，因此该值也出现在DNS应答报文中。  &lt;br /&gt;
“+”表示启用递归查询标志。  &lt;br /&gt;
“A”表示使用A类型的查询方式。  &lt;br /&gt;
“www.baidu.com”则是DNS查询问题中的查询名。  &lt;br /&gt;
括号中的数值31是DNS查询报文的长度（以字节为单位）。&lt;/p&gt;

&lt;p&gt;第二个数据包中，“3/0/0”表示该报文中包含3个应答资源记录、0个授权资源记录和0个额外信息记录。  &lt;br /&gt;
“CNAME www.a.shifen.com., A 115.239.211.110, A 115.239.210.27 (138)”则表示3个应答资源记录的内容。  &lt;br /&gt;
其中CNAME表示紧随其后的记录是机器的别名，A表示紧随其后的记录是IP地址。  &lt;br /&gt;
该应答报文的长度为138字节。&lt;/p&gt;

&lt;h3 id=&quot;dns-1&quot;&gt;修改DNS&lt;/h3&gt;
&lt;p&gt;我记得以前碰到过这样一见很诡异的事情：qq可以登录聊天，邮件客户端也可以正常工作，就唯独浏览器打不开网站页面&lt;/p&gt;

&lt;p&gt;当时遇到的时候，感觉可诡异，后来才知道，原来是DNS挂了&lt;/p&gt;

&lt;p&gt;我们通常上网都是直接通过网络运营商(电信，网通等)提供的网络，所以DNS也是自动获取，一定运行上的域名服务器出现了问题，那么我们也就不能正常访问网站&lt;/p&gt;

&lt;p&gt;此时，我们就得修改DNS，著名的DNS有谷歌的:&lt;code&gt;8.8.8.8&lt;/code&gt; 和 &lt;code&gt;8.8.4.4&lt;/code&gt;     &lt;br /&gt;
还有114DNS:&lt;code&gt;114.114.114.114&lt;/code&gt;和&lt;code&gt;114.114.115.115&lt;/code&gt;    &lt;br /&gt;
这两个算是比较好记的&lt;/p&gt;

&lt;p&gt;还有其他的请参考&lt;a href=&quot;www.ip.cn/dns.html&quot;&gt;公共DNS服务器&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>编译和连接</title>
   <link href="http://mwumli.github.io/compile-link"/>
   <updated>2014-09-28T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/compile-link</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;编译和连接&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;从最简单最熟悉开始&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#c-i-using-cpp&quot; id=&quot;markdown-toc-c-i-using-cpp&quot;&gt;预处理(.c-&amp;gt;.i using cpp)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#i-s-using-cc1&quot; id=&quot;markdown-toc-i-s-using-cc1&quot;&gt;编译(.i-&amp;gt;.s using cc1)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#s-o-using-as&quot; id=&quot;markdown-toc-s-o-using-as&quot;&gt;汇编(.s-&amp;gt;.o using as)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;链接&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;参考文献&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;编译和连接&lt;/h2&gt;
&lt;p&gt;对于平常的应用程序开发，我们很少关注编译和连接的过程，因为通常的开发环境都是流行的集成开发环境(IDE)&lt;/p&gt;

&lt;p&gt;而IDE往往将编译和连接的过程“一气呵成”,通常编译和连接合并到一块被称为”build”,也就是构建.&lt;/p&gt;

&lt;p&gt;即使是命令行来编译一个&lt;code&gt;hello.c&lt;/code&gt;，简单一句&lt;code&gt;gcc hello.c&lt;/code&gt;，然后你就可以&lt;code&gt;./a.out&lt;/code&gt;来得到富有盛名的&lt;code&gt;Hello,World!&lt;/code&gt;了&lt;/p&gt;

&lt;p&gt;正所谓“有一得必有一失”，我们享受与这种一键执行的快感，却忽略很多系统软件背后的运行机制和机理，程序中很多莫名其妙的错误常常令我们无所适从，面对程序运行时种种性能瓶颈我们束手无策，而为了解决这些问题，我们往往需要追根溯源&lt;/p&gt;

&lt;p&gt;因此，了解编译和连接的过程，有助于我们对软件运行的机理的了解以及对出现的各种问题能有更高效的解决途径&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;从最简单最熟悉开始&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Hello,World&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//hello.c&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样的程序，闭着眼睛，用心作笔，估计一秒钟都可以写几万次了吧  &lt;br /&gt;
在Linux下，当我们使用GCC来编译hello.c,这样做:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls 
hello.c
$ gcc hello.c
$ ls
a.out hello.c
$ ./a.out
Hello,World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，我们使用gcc编译处理hello.c之后，生成了一个a.out的文件  &lt;br /&gt;
这个文件正是我们可执行程序，运行之后，输出&lt;code&gt;Hello,World&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;整个过程很简单，但这只是表面上的，事实上，上述过程可以分解为4个步骤，分别是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;预处理(Prepressing)[.c]-&amp;gt;编译(Compilation)[.i]-&amp;gt;汇编(Assembly)[.o]-&amp;gt;链接(Linking)[可执行文件]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;c-i-using-cpp&quot;&gt;预处理(.c-&amp;gt;.i using cpp)&lt;/h3&gt;
&lt;p&gt;Linux下对c文件进行预处理，可以使用预编译器&lt;code&gt;cpp&lt;/code&gt;  &lt;br /&gt;
进行预处理之后，生成的预处理文件为&lt;code&gt;.i&lt;/code&gt;,对于C++程序而言，预编译后的文件为&lt;code&gt;.ii&lt;/code&gt;  &lt;br /&gt;
以下是预编译的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cpp hello.c &amp;gt; hello.i  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -E hello.c -o hello.i  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无论是&lt;code&gt;cpp&lt;/code&gt;还是&lt;code&gt;gcc -E&lt;/code&gt;,他们的结果(在不指定目标文件的情况下)会输出到&lt;code&gt;stdout&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;预编译的过程主要处理那些源码中以”#”开始的预编译指令，比如&lt;code&gt;#include&lt;/code&gt;，&lt;code&gt;#define&lt;/code&gt;  &lt;br /&gt;
主要做了一下处理:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;将所有&lt;code&gt;#define&lt;/code&gt;处删除，展开所有宏定义&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 在include和main之间添加“#define HELLO &quot;hello,world\n&quot; ”,
 然后把printf()中的内容改为HELLO,接着如上预处理生成目标文件hello_micro.i
 使用diff hello.i hello_micro.i,发现两个文件完全一致 
 由此证明删除定义宏，展开所有宏  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;处理所有条件预编译指令，比如&lt;code&gt;#if&lt;/code&gt;,&lt;code&gt;#ifdef&lt;/code&gt;,&lt;code&gt;#elif&lt;/code&gt;,&lt;code&gt;#else&lt;/code&gt;,&lt;code&gt;#endif&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;处理&lt;code&gt;#include&lt;/code&gt;预编译指令，将被包含的文件插入到该预编译指令的位置。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; 注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件。
 因此，在多文件程序中要注意同一文件被多次包含引起的错误  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;删除所有的注释&lt;code&gt;//&lt;/code&gt;和&lt;code&gt;/**/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;添加行号和文件名标识，比如&lt;code&gt;#2 &quot;hello.c&quot; 2&lt;/code&gt;,以便于编译时产生调试用的行号信息及用于编译时产生编译错误或警告时都能显示行号&lt;/li&gt;
  &lt;li&gt;保留所有的&lt;code&gt;#pragma&lt;/code&gt;编译器指令，因为编译器需要使用它们&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;经过预编译后的&lt;code&gt;.i&lt;/code&gt;文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中。  &lt;br /&gt;
所以当我们&lt;em&gt;无法判断宏定义是否正确&lt;/em&gt;或者&lt;em&gt;头文件是否正确引入&lt;/em&gt;的时候，可以查看预编译后的&lt;code&gt;.i&lt;/code&gt;文件来确定问题&lt;/p&gt;

&lt;h3 id=&quot;i-s-using-cc1&quot;&gt;编译(.i-&amp;gt;.s using cc1)&lt;/h3&gt;
&lt;p&gt;编译过程就是把&lt;code&gt;.i&lt;/code&gt;文件进行一系列的词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件&lt;code&gt;.s&lt;/code&gt;  &lt;br /&gt;
这个过程整个程序构建的核心部分,也是最复杂的部分，涉及到编译原理的一些内容  &lt;br /&gt;
Linux命令如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -S hello.i -o hello.s  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;据说，现在的gcc已经将预编译和编译两个步骤合并成一个步骤，使用一个叫做&lt;code&gt;cc1&lt;/code&gt;的程序  &lt;br /&gt;
&lt;code&gt;cc1&lt;/code&gt;在我的机器(Ubuntu 14.04 LTS)上的路径&lt;code&gt;/usr/lib/gcc/x86_64-linux-gnu/4.8/cc1&lt;/code&gt;   &lt;br /&gt;
因此，我这样编译：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /usr/lib/gcc/x86_64-linux-gnu/4.8/cc1 hello.i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和上面的命令效果等同  &lt;br /&gt;
但是根据资料显示，&lt;code&gt;cc1&lt;/code&gt;把预编译和编译融合，因此我使用&lt;code&gt;/usr/lib/gcc/x86_64-linux-gnu/4.8/cc1 hello.c&lt;/code&gt;,结果出错&lt;/p&gt;

&lt;p&gt;为了研究其原因，我使用&lt;code&gt;gcc -v hello.c 2&amp;gt;cp.txt&lt;/code&gt;打印gcc对其编译过程做了那些操作  &lt;br /&gt;
因为比较长，只截取有用的部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/lib/gcc/x86_64-linux-gnu/4.8/cc1 -quiet -v -imultiarch x86_64-linux-gnu hello.c -quiet -dumpbase hello.c -mtune=generic -march=x86-64 -auxbase hello -version -fstack-protector -Wformat -Wformat-security -o /tmp/cckHwTs6.s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到cc1携带了大量的参数，最终生成汇编文件保存在&lt;code&gt;/tmp/cckHwTs6.s&lt;/code&gt;  &lt;br /&gt;
我在命令行进行了验证，确实如此  &lt;br /&gt;
这里又一次证明了：IDE掩盖很多已有的参数。不过，这么多参数确实让人心烦，既然常用，默认是一个好的办法，不过，你应该了解有这么个过程&lt;/p&gt;

&lt;h3 id=&quot;s-o-using-as&quot;&gt;汇编(.s-&amp;gt;.o using as)&lt;/h3&gt;
&lt;p&gt;汇编器就是将汇编代码转变成机器可以执行的指令，每一个汇编语句都对应一条机器指令,所以汇编器的汇编过程相对于编译过程就显得简单多了。&lt;/p&gt;

&lt;p&gt;汇编过程在linux下我们调用汇编器as来完成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ as hello.s -o hello.o  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -c hello.s -o hello.o  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者使用gcc从.c文件开始，经过预编译、编译、汇编直接输出&lt;em&gt;目标文件&lt;/em&gt;(Object File)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -c hello.s -o hello.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样，我们可以在cp.txt文件中看到下面一段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;COLLECT_GCC_OPTIONS='-v' '-mtune=generic' '-march=x86-64'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;链接通常是一个让人费解的过程：  &lt;br /&gt;
为什么汇编器不直接输出可执行文件而是一个目标文件呢？  &lt;br /&gt;
链接过程到底包含了什么内容？  &lt;br /&gt;
为什么要链接?  &lt;br /&gt;
…  &lt;br /&gt;
我们通常使用ld来链接目标文件  &lt;br /&gt;
我们来看看cp.txt中的相应描述：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/lib/gcc/x86_64-linux-gnu/4.8/collect2 --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -z relro /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/4.8/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/4.8 -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/4.8/../../.. /tmp/ccfb7d3z.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/4.8/crtend.o /usr/lib/gcc/x86_64-linux-gnu/4.8/../../../x86_64-linux-gnu/crtn.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;额，好长啊，不过貌似没有&lt;code&gt;ld&lt;/code&gt;的字眼，看来gcc并没有如同我们想象的那样直接调用ld进行链接。而是调用&lt;code&gt;collect2&lt;/code&gt;进行链接&lt;/p&gt;

&lt;p&gt;实际上，&lt;code&gt;collect2&lt;/code&gt;只是一个辅助程序最终它仍调用&lt;code&gt;ld&lt;/code&gt;进行链接&lt;/p&gt;

&lt;p&gt;举个例子：对于C++程序来说，在执行main函数前，全局静态对象必须构造完成。&lt;br /&gt;
也就是说，在main之前程序需要进行一些必要的初始化，gcc就是使用collect2安排初始化过程中如何调用各个初始化函数的。根据链接过程可见，除了hello.c对应的目标文件ccfb7d3z.o外，ld也链接了libc、libgcc等库，以及所谓的包含启动代码（start code）的启动文件（start/startup file），包括crt1.o、crti.o、crtbegin.o、crtend.o和crtn.o&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;《程序员的自我修养》&lt;/li&gt;
  &lt;li&gt;《深度探索Linux操作系统：系统构建和原理解析》&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Linux内核链表的分析</title>
   <link href="http://mwumli.github.io/kernel-list"/>
   <updated>2014-09-22T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/kernel-list</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#listhead&quot; id=&quot;markdown-toc-listhead&quot;&gt;内核中list_head的定义&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;栈，队列，链表…..&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;为什么没有数据域？&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;内核链表的初始化&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;两个宏&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;一个函数&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#static-inline&quot; id=&quot;markdown-toc-static-inline&quot;&gt;static inline&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;内核链表的插入&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;内核链表之删除&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;内核链表之遍历&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;内核链表删除的不安全性&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;结束&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;listhead&quot;&gt;内核中list_head的定义&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;struct list_head {
	struct list_head *next, *prev;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仅仅只有两个指针，prev指向前一个节点,next指向后一个节点  &lt;br /&gt;
但是为什么没有data域呢？  &lt;br /&gt;
内核出错了，显然不可能，别急，慢慢来&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;栈，队列，链表…..&lt;/h4&gt;
&lt;p&gt;我们可以用这个结构定义一个新的结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;strutc my_list_node {
	int	data;
	strutc list_head list;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;假如我们禁用了list中的prev,它就是一个&lt;em&gt;单链表&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如(单链表的基础上)我们启用list中的prev，它就是一个&lt;em&gt;双链表&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如(单链表基础上)我们让最后一个节点next指向第一个节点，那么它就是一个&lt;em&gt;单向循环链表&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如(单向循环链表基础上)我们启用list中的prev域，那么它就是一个&lt;em&gt;双向循环链表&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如(单链表的基础上)，我们有方法可以从头部插入，头部删除，那么它就是一个&lt;em&gt;栈&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如(单链表的基础上)，我们有方法可以头部删除，尾部插入那么它就是一个&lt;em&gt;队列&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;假如…,它就是一个…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好了,我想也不用多说了，大家应该思维澎湃了  &lt;br /&gt;
这正体现了一点：链表是其他数据结构的根本形式&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;为什么没有数据域？&lt;/h4&gt;
&lt;p&gt;怎么可能？链表没有数据，这还有什么意义  &lt;br /&gt;
是啊，没有数据域，我们该怎储存信息呢？  &lt;br /&gt;
事实上，上面我们定义的这个&lt;em&gt;struct my_list_node&lt;/em&gt;就解释了为什么没有数据域  &lt;br /&gt;
没有数据正是为了可以容纳更多的，不同的数据类型(通过自定义)&lt;/p&gt;

&lt;p&gt;这就是抽象的艺术，说起抽象，谈谈面向对象也不不错&lt;/p&gt;

&lt;p&gt;我们常说，C++是面向对象的语言，其实面向对象并不只是说一种语言，而是一种思想：我们把具体的东西通过对其共性的分析，抽象出来，从而形成一种结构，这种结构或许单独来说么有实际意义，但是通过我们增添不同的功能，从而就有了不同的意义新的结构，那么此时，其意义得以体现，这就是我理解的面向对象&lt;/p&gt;

&lt;p&gt;可以看到我们抛弃了那所谓的数据，只留下了两个指针，正因为抛弃了数据域(也不能说抛弃，应该是还未迎娶),我们才可以通过自定义添加不同的数据类型(int,char等),更多的数据成员(1,2,3…)&lt;/p&gt;

&lt;p&gt;所有有的时候，所谓的舍弃，只是为了更好的扩展&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;内核链表的初始化&lt;/h3&gt;
&lt;p&gt;两个宏，一个函数&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;两个宏&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#define LIST_HEAD_INIT(name) { &amp;amp;(name), &amp;amp;(name) }

#define LIST_HEAD(name) strutc list_head name = LIST_HEAD_INIT(name)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;一个函数&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;static inline void INIT_LIST_HEAD(struct list_head *list) 
{
	list-&amp;gt;next = list;
	list-&amp;gt;prev = list;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些有什么不同呢？  &lt;br /&gt;
我看了有看，也确实有点不同  &lt;br /&gt;
&lt;em&gt;LIST_HEAD&lt;/em&gt;和&lt;em&gt;LIST_HEAD_INIT&lt;/em&gt;是相辅相成的，如果单独使用的话，那么&lt;em&gt;LIST_HEAD_INIT&lt;/em&gt;需要用在结构体变量定义初始化的时候，而&lt;em&gt;LIST_HEAD&lt;/em&gt;只需要提供一个变量名即可完成定义兼初始化：  &lt;br /&gt;
&lt;strong&gt;LIST_HEAD_INIT&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct list_head lp = LIST_HEAD_INIT(lp);	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;LIST_HEAD&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LIST_HEAD(lp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两段代码看起来不一样，其实本质是一样的：定义了一个名为lp的struct list_head变量，同时用其自己的地址对其初始化&lt;/p&gt;

&lt;h4 id=&quot;static-inline&quot;&gt;static inline&lt;/h4&gt;
&lt;p&gt;当你看过&lt;em&gt;list.h&lt;/em&gt;后，我相信你对static inline已经熟的不能在熟  &lt;br /&gt;
但是有有点困惑，为什么这么频繁的使用呢？  &lt;br /&gt;
真是熟悉的陌生人!…呵呵&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;static&lt;/strong&gt;  &lt;br /&gt;
被static修饰的函数，作用域将限于本文件，也就是其他文件看不见&lt;/p&gt;

&lt;p&gt;可能你觉的这样说起来很模糊，而且假如我们在.h文件中定义，然后被其他.c文件&lt;em&gt;include&lt;/em&gt;,那么根据&lt;em&gt;include&lt;/em&gt;的定义：当预处理器具发现include的时候，就会寻找inlucde之后的文件,并把这个文件包含到当前文件,即替换include指令&lt;/p&gt;

&lt;p&gt;所以这样的话，.h文件也是.c文件的一部分了，那么.h文件中被static修饰的函数必然也能在.c文件中使用了，那么，static的意义不存了&lt;/p&gt;

&lt;p&gt;嗯哼，当然不是这样的，我们试着这样做一做吧:  &lt;br /&gt;
&lt;em&gt;test_static.h&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void func1(){ }
void func2(){}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们还有两个文件，一个是main.c, 一个是test_static.c，这两文件我们都引用了&lt;strong&gt;test_static.h&lt;/strong&gt;,然后我们执行下面指令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -o main main.c test_static.c test_static.h
/tmp/ccSrEpb2.o: In function `func2':
test_static.c:(.text+0x6): multiple definition of `func2'
/tmp/cc54UVtA.o:main.c:(.text+0x6): first defined here
collect2: error: ld returned 1 exit status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是的报错了：func2多重定义,对就是那个没有定义为static的家伙&lt;/p&gt;

&lt;p&gt;好了，我们给func2加上static,在编译一次(自己操作)，啊哈，编译成功  &lt;br /&gt;
是的，static让错误消失了&lt;/p&gt;

&lt;p&gt;怎么回事儿呢？  &lt;br /&gt;
添加了static ,虽然每个.c文件中都定义了static函数，但是经过编译，所有的static隐藏在自己的目的文件(.o)中，连接器(linker)在找寻symbol的过程中，是会被忽略的&lt;/p&gt;

&lt;p&gt;所以，我们加上static是为了避免多重定义连接错误&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;inline&lt;/strong&gt;  &lt;br /&gt;
inline是内联的意思，即当定义了inline,就会暗示编译器，我有”倒插门”的倾向，然后，编译器愿不愿意接受，那就得看具体编译器的不同配置了;如果我被接受了，那么在编译的时候，我会每个call我的地方”赤身裸体”(即展开代码)&lt;/p&gt;

&lt;p&gt;因为代码被插入到被调用的地方，所以效率肯定提高了(相比函数调用的上下文切换)  &lt;br /&gt;
这也就是函数前使用inline的意义：提高效率(现在存储技术发展很快，相比之下，效率尤为重要)&lt;/p&gt;

&lt;p&gt;现在，关键的来了，我们同时使用了static inline：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When an inline function is not static, then the compiler must assume that there may be calls from other source files; since a global symbol can be defined only once in any program, the function must not be defined in the other source files, so the calls therein cannot be integrated. Therefore, a non-static inline function is always compiled on its own in the usual fashion.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这段话来自&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Inline.html&quot;&gt;gcc的官方文档&lt;/a&gt;  &lt;br /&gt;
我的理解：在.h文件中定义inline,如果没有static,那么编译器(至少gcc是这样)就会认为你可能被其他文件多次调用，因为一个全局符号在任何一个程序中仅能出现一次，这个函数一定不能定义在其他源文件中，因此这此调用不能inline函数代码不能被集成到被调用处&lt;/p&gt;

&lt;p&gt;所以，我想应该是基于这个原因，所以内核代码中多次使用&lt;em&gt;static inline&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;内核链表的插入&lt;/h3&gt;
&lt;p&gt;将new插入head之后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void list_add(struct isr_head *new , struct list_head *head) 
{
	__list_add(new, head, head-&amp;gt;next);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码注释里有句话：This is good for implementing stacks.&lt;/p&gt;

&lt;p&gt;将new插入到head之前，即尾部&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void list_add_tail(struct list_head *new, struct list_head *head)  
{
	__list_add(new, head-&amp;gt;prev, head);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码注释里有句话：This is good for implementing queues.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;__list_add&lt;/strong&gt;到底是何方人士，竟引得list_add和list_add_tail竞相使用?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline void __list_add(struct list_head *new,
				struct list_head *prev;
				struct list_head *next;)
{
	next-&amp;gt;prev = new;
	new-&amp;gt;next = next;
	prev-&amp;gt;next = new;
	new-&amp;gt;prev = prev;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到代码，才知道：哦，原来只是把一个node插入到两个node之间的函数  &lt;br /&gt;
不用多说了，这里很简单，但是重要的是这种抽象的思想  &lt;br /&gt;
对了，看来那两句注释，感觉如何？&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;内核链表之删除&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;static inline void __list_del(struct list_head * prev, 
				struct list_head * next)
{
	next-&amp;gt;prev = prev;
	prev-&amp;gt;next = next;
}

static inline void list_del(struct list_head *entry)
{
	__list_del(entry-&amp;gt;prev, entry-&amp;gt;next);  
	entry-&amp;gt;next = LIST_POISON1;        
	entry-&amp;gt;prev = LIST_POISON2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码很简单，LIST_POISON1和LIST_POISON2是两个宏，被定义在poison.h中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define LIST_POISON1  ((void *) 0x00100100 + POISON_POINTER_DELTA)
#define LIST_POISON2  ((void *) 0x00200200 + POISON_POINTER_DELTA)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释说这两个非空指针在正常情况下会导致页错误，这是它的注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
 *These are non-NULL pointers that will result in page faults¬
 * under normal circumstances, used to verify that nobody uses¬
 * non-initialized list entries.
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些都可以理解，但是为什么是0x00100100和0x00200200呢？  &lt;br /&gt;
我查了很多资料，都没找到答案，恳请各位解惑&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;内核链表之遍历&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; #define list_for_each(pos, head) \
	for (pos = (head)-&amp;gt;next; pos != (head); pos = pos-&amp;gt;next)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个宏很简单，但是有个难点就是我们怎么根据pos找到node的位置，例如我上面定义的struct my_list_node这个结构  &lt;br /&gt;
list.h给出了代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define list_entry(ptr, type, member) \
	container_of(ptr, type, member)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个container_of在kernel.h中有定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define container_of(ptr, type, member) ({       \
|	const typeof( ((type *)0)-&amp;gt;member ) *__mptr = (ptr);   \
|	 (type *)( (char *)__mptr - offsetof(type,member) );})  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码还真不好说，还是给出一段代码，试试就知道了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

struct list_head {
	struct list_head *self;
};
typedef struct Type_List {
	int a;
	struct list_head list;
}Type_List;

int main(int argc, const char *argv[])
{
	Type_List *tl=(Type_List *)malloc(sizeof(Type_List));
	//打印tl的地址
	printf(&quot;%x\n&quot;, tl);

	//获取tl的成员list的地址赋给ptr
	struct list_head *ptr=&amp;amp;(tl-&amp;gt;list);
	//使用ptr获取tl的地址
	Type_List *p=(Type_List *)((char *)ptr-(unsigned long)&amp;amp;(((Type_List *)0)-&amp;gt;list));
	printf(&quot;%x\n&quot;, p);

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简而言之，就是使用list的地址减去list成员距my_list_head的起始地址的偏移量  &lt;br /&gt;
而offsetof就是求偏移量的宏&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;内核链表删除的不安全性&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#define list_for_each_safe(pos, n, head) \
    for (pos = (head)-&amp;gt;next, n = pos-&amp;gt;next; pos != (head); \
		pos = n, n = pos-&amp;gt;next)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是list.h中提供的用于安全删除链表的遍历宏  &lt;br /&gt;
之前我们看到list_for_each这个宏  &lt;br /&gt;
如果我们向下面这样用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list_for_each(ptr, head) {
	tmp = list_entry(ptr, struct my_list_head, list);
	list_del(ptr);
	free(tmp)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写的话，因为ptr已经被删除，但根据list_for_each内部实现却是在删除ptr之后，调用ptr=ptr-&amp;gt;next,因为地址已经被引入LIST_POISON1了，所以肯定报错&lt;/p&gt;

&lt;p&gt;而我们使用了list_for_each_safe,就不会这样，因为有一个临时的struct my_list_head类型变量n记录了ptr的下一个节点，所以就不会出现问题&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;结束&lt;/h3&gt;
&lt;p&gt;呵，松了口气，好长啊，不过，看了内核对list的实现，确实收获很多，尽管现在看到是”冰山一脚“，但是这一脚总算是才上去了  &lt;br /&gt;
对于文章中出现的问题，希望作为读者的你能提出来，帮助我改进&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>静态博客系统--&gt;JekyllBootstrap</title>
   <link href="http://mwumli.github.io/website-by-using-jekyllboostrap"/>
   <updated>2014-08-14T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/website-by-using-jekyllboostrap</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#jekyllbootstrap&quot; id=&quot;markdown-toc-jekyllbootstrap&quot;&gt;上菜–JekyllBootstrap&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#rakepost-or-page&quot; id=&quot;markdown-toc-rakepost-or-page&quot;&gt;使用rake快速创建post or page&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#post&quot; id=&quot;markdown-toc-post&quot;&gt;创建一篇post&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#page&quot; id=&quot;markdown-toc-page&quot;&gt;创建一个page&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;发布你的站点&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;自定义&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;说些什么&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jekyllbootstrap&quot;&gt;上菜–JekyllBootstrap&lt;/h3&gt;
&lt;p&gt;在&lt;a href=&quot;/%E8%AE%B0%E5%BD%95/2014/08/14/static-website-by-jekyll/&quot; title=&quot;使用jekyll搭建静态站点&quot;&gt;使用jekyll搭建静态站点&lt;/a&gt;一文中， 我已经介绍了怎么创建最简单站点的例子(&lt;code&gt;jekyll new myblog&lt;/code&gt;),但看起来貌似难以起步(神马都没有),一切都需要start from scratch，真是愁啊&lt;/p&gt;

&lt;p&gt;不过，现在不用担心了，我们有技能–&amp;gt;JekyllBootstrap&lt;/p&gt;

&lt;p&gt;JekyllbBootstrap就像WordPress(动态博客系统）一样，但是，jekyllbootstrap用于静态网站&lt;/p&gt;

&lt;p&gt;好了，开始准备干活吧&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个新的仓库  &lt;br /&gt;
去你的&lt;a href=&quot;https://github.com&quot; title=&quot;github首页&quot;&gt;https://github.com&lt;/a&gt;创建一个新的仓库，命名为&lt;code&gt;username.github.io&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装Jekyll-Bootstrap  &lt;br /&gt;
打开终端，切换到你想放置站点的目录，输入一下命令：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ git clone https://github.com/plusjade/jekyll-bootstrap.git username.github.io
 $ cd username.github.io
 $ git remote set-url origin git@github.com:username/username.github.com.git
 $ git push origin master
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;等待与收获  &lt;br /&gt;
等待大约10分钟，你就可以通过browser在&lt;code&gt;http://username.github.com&lt;/code&gt;看到你的站点&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;rakepost-or-page&quot;&gt;使用rake快速创建post or page&lt;/h3&gt;
&lt;p&gt;顺便说一句，&lt;code&gt;rake&lt;/code&gt;工具需要安装，Linux/Ubuntu请使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install rake  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rake&lt;/code&gt;使用之前需要有一个&lt;code&gt;Rakefile&lt;/code&gt;文件，如果你使用&lt;code&gt;JekyllBootstrap&lt;/code&gt;,那你就不用自己创建&lt;code&gt;Rakefile&lt;/code&gt;文件，已经内置;否则，你如果想使用&lt;code&gt;Rake&lt;/code&gt;，可以拷贝一下&lt;code&gt;JekyllBoostrap&lt;/code&gt;里的&lt;code&gt;Rakefile&lt;/code&gt;，或者，自己查阅相关资料按照规则编写（你可以的，嘿嘿）&lt;/p&gt;

&lt;h4 id=&quot;post&quot;&gt;创建一篇post&lt;/h4&gt;
&lt;p&gt;通过&lt;code&gt;rake&lt;/code&gt;很容易创建一篇post&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rake post title=&quot;Hello World&quot;  
Creating new post: ./_posts/2014-08-14-hello-world.md  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rake&lt;/code&gt;会帮你格式化名字并添加日期(当前时间)   &lt;br /&gt;
并且post中自动添加YAML头信息，太方便了  &lt;br /&gt;
&lt;code&gt;rake&lt;/code&gt;不会覆盖原有文件，除非你让它那么做&lt;/p&gt;

&lt;h4 id=&quot;page&quot;&gt;创建一个page&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在根目录创建&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ rake page name=&quot;about.md&quot;
  Creating new page: ./about.md  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个内嵌&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ rake page name=&quot;pages/about.md&quot;
  Creating new page: ./pages/about.md  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个”漂亮”的路径&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  $ rake page name=&quot;pages/about.md
  Creating new page: ./pages/about/index.html&quot;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三种方式的区别在于browser呈现的路径的不同,自己尝试吧&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;发布你的站点&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ git add .
$ git commit -m &quot;add new content&quot;
$ git push origin master  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，新的内容已经在你的github项目，享受新的变化吧&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;自定义&lt;/h4&gt;
&lt;p&gt;Jekyll-Bootstrap可以根据喜好自我定义  &lt;br /&gt;
主题可以更换，也可以自己写；配置根据喜好自己修改  &lt;br /&gt;
具体请参考&lt;a href=&quot;http://jekyllbootstrap.com/usage/jekyll-quick-start.html&quot; title=&quot;Jekyll-Bootstrap快速开始&quot;&gt;Jekyll-Bootstrap快速开始&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;说些什么&lt;/h3&gt;
&lt;p&gt;其实这篇文章也算是一篇简单的译文吧  &lt;br /&gt;
不管如何，看完基本能懂得怎么安装，使用Jekyll-Bootstrap就可以了  &lt;br /&gt;
至于深入用法和配置，请参考&lt;a href=&quot;http://jekyllbootstrap.com&quot; title=&quot;Jekyll-Bootstrap官方网站&quot;&gt;Jekyll-Bootstrap官方网站&lt;/a&gt;  &lt;br /&gt;
单词和句型都很简单(就连我四级都没过的人都看的懂)，你一定可以的，嘿嘿&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>使用jekyll搭建静态站点</title>
   <link href="http://mwumli.github.io/static-website-by-jekyll"/>
   <updated>2014-08-14T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/static-website-by-jekyll</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#jekyll&quot; id=&quot;markdown-toc-jekyll&quot;&gt;Jekyll的安装&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jekyll-1&quot; id=&quot;markdown-toc-jekyll-1&quot;&gt;Jekyll的使用&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#jekyll-2&quot; id=&quot;markdown-toc-jekyll-2&quot;&gt;运行jekyll开发服务器&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#jekyll-3&quot; id=&quot;markdown-toc-jekyll-3&quot;&gt;Jekyll的配置&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#rdiscountmd&quot; id=&quot;markdown-toc-rdiscountmd&quot;&gt;使用RDiscount来渲染md文档&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#pygments&quot; id=&quot;markdown-toc-pygments&quot;&gt;Pygments来实现代码高亮&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#highlight&quot; id=&quot;markdown-toc-highlight&quot;&gt;在文章中引用highlight标签&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jekyll&quot;&gt;Jekyll的安装&lt;/h3&gt;

&lt;p&gt;假如系统未曾安装gem,请使用以下命令安装:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install ruby1.9.1-full
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装ruby(1.9.3)的时候，会同时安装gem1.8.23&lt;/p&gt;

&lt;p&gt;使用gem安装jekyll:&lt;code&gt; sudo gem install jekyll&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;假如报错的话，请安装ruby1.9.1的编译扩展组件的头文件:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install ruby1.9.1-dev    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本安装已经完成了，但是你执行&lt;code&gt;jekyll new myblog&lt;/code&gt;时，可能会报&lt;code&gt;Could not find a JavaScript runtime&lt;/code&gt;这样的错误，你需要使用一下命令解决：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install nodejs  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;jekyll-1&quot;&gt;Jekyll的使用&lt;/h3&gt;

&lt;p&gt;一个获取最简单 Jekyll 模板并生成静态站点的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll new myblog
New jekyll site installed in /home/temp/myblog.  
$ cd myblog
$ ls
about.md     css/      _includes/  _layouts/  _sass/
_config.yml  feed.xml  index.html  _posts/
$ jekyll serve
Configuration file: /home/temp/myblog/_config.yml
	    Source: /home/temp/myblog
       Destination: /home/temp/myblog/_site
      Generating... 
                	    done.
 Auto-regeneration: disabled. Use --watch to enable.
Configuration file: /home/temp/myblog/_config.yml
    Server address: http://0.0.0.0:4000/
  Server running... press ctrl-c to stop.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well,你可以browse to http://localhost:4000&lt;/p&gt;

&lt;p&gt;就是这么简单。从现在开始，你可以通过创建文章、改变头信息来控制模板和输出、修改 Jekyll 设置来使你的站点变得更有趣～&lt;/p&gt;

&lt;h4 id=&quot;jekyll-2&quot;&gt;运行jekyll开发服务器&lt;/h4&gt;

&lt;p&gt;jekyll使用一下命令，将会运行一个服务器，用来在本地查看你的静态站点  &lt;br /&gt;
类似于在本地搭建的apache服务器，命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll serve  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个开发服务器将会在&lt;code&gt;http://localhost:4000&lt;/code&gt;运行&lt;/p&gt;

&lt;p&gt;假如你想脱离终端在后台运行,请使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll serve --detach
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你想关闭服务器，可以使用&lt;code&gt;kill -9 PID&lt;/code&gt;命令  &lt;br /&gt;
如果你找不到进程号，那么就用&lt;code&gt;ps aux | grep jekyll&lt;/code&gt;命令来查看，然后关闭服务器。&lt;/p&gt;

&lt;p&gt;如果你想查看变更并且自动再生成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll serve --watch 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;jekyll-3&quot;&gt;Jekyll的配置&lt;/h3&gt;

&lt;h4 id=&quot;rdiscountmd&quot;&gt;使用RDiscount来渲染md文档&lt;/h4&gt;

&lt;p&gt;如果你希望使用RDiscount来渲染markdown,而不是Maruku,只要确保RDiscount被正确的安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo gem install rdiscount  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后运行 Jekyll，并使用以下的参数选项：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jekyll --rdiscount  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以在你的_config.yml中写入代码，从而不必指定参数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;markdown: rdiscount  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;pygments&quot;&gt;Pygments来实现代码高亮&lt;/h4&gt;

&lt;p&gt;如果你是一个程序员，那么你一定希望你的文章中代码高亮  &lt;br /&gt;
不错，已经有好的解决办法了：通过 highlight 标签实现代码高亮  &lt;br /&gt;
但在此之前，你需要首先安装 Pygments&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install python-pygments  
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;highlight&quot;&gt;在文章中引用highlight标签&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用pygmentize生成高亮CSS文件&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; $ pygmentize -f html -S default &amp;gt; pygments.css  
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把生成的pygments.css移到你的css文件夹里，在post模板里引用一下&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改配置文件_config.xml,添加： &lt;code&gt;highlighter: pygments&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用格式如下:    &lt;br /&gt;
&lt;img src=&quot;/assets/imgs/heligher_demo.png&quot; alt=&quot;helighter_demo&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中&lt;code&gt;language&lt;/code&gt;可以从&lt;a href=&quot;http://pygments.org/docs/lexers/&quot; title=&quot;pygments语法高亮&quot;&gt;Syntax highlighter&lt;/a&gt;获取&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>为你和你的项目建立一个站点--Github Pages</title>
   <link href="http://mwumli.github.io/websites-by-github-pages"/>
   <updated>2014-08-03T00:00:00+00:00</updated>
   <id>http://mwumli.github.io/websites-by-github-pages</id>
   <content type="html">
&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#github-pages&quot; id=&quot;markdown-toc-github-pages&quot;&gt;什么是GitHub Pages?&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;两种站点服务&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;好处不言而喻&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;建站开始&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#user-or-organization-site&quot; id=&quot;markdown-toc-user-or-organization-site&quot;&gt;User or organization Site&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#githubrepository&quot; id=&quot;markdown-toc-githubrepository&quot;&gt;&lt;a href=&quot;https://github.com/new&quot; title=&quot;新建一个GitHub仓库&quot;&gt;创建一个仓库&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#git&quot; id=&quot;markdown-toc-git&quot;&gt;选择你正在使用的git客户端&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#terimal&quot; id=&quot;markdown-toc-terimal&quot;&gt;Terimal(终端)&lt;/a&gt;                &lt;ul&gt;
                  &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;克隆刚创建的仓库&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#hello-world&quot; id=&quot;markdown-toc-hello-world&quot;&gt;Hello World&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#pushgithub&quot; id=&quot;markdown-toc-pushgithub&quot;&gt;push你的项目到github&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#github-for-windows-or-mac&quot; id=&quot;markdown-toc-github-for-windows-or-mac&quot;&gt;GitHub for Windows or Mac&lt;/a&gt;                &lt;ul&gt;
                  &lt;li&gt;&lt;a href=&quot;#clone&quot; id=&quot;markdown-toc-clone&quot;&gt;Clone仓库&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#createindexhtml&quot; id=&quot;markdown-toc-createindexhtml&quot;&gt;Create一个index.html文件&lt;/a&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;#commit--sync&quot; id=&quot;markdown-toc-commit--sync&quot;&gt;commit &amp;amp;&amp;amp; Sync&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;未知区域&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;浏览你的网站吧&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#project-site&quot; id=&quot;markdown-toc-project-site&quot;&gt;project Site&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#generate-a-site&quot; id=&quot;markdown-toc-generate-a-site&quot;&gt;半路出家(Generate a Site)&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#repository-settings&quot; id=&quot;markdown-toc-repository-settings&quot;&gt;Repository Settings&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#automatic-generator&quot; id=&quot;markdown-toc-automatic-generator&quot;&gt;使用Automatic Generator&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;添加内容&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;选择一个主题&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#start-from-scratch&quot; id=&quot;markdown-toc-start-from-scratch&quot;&gt;白手起家(Start from scratch)&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#ph-pages&quot; id=&quot;markdown-toc-ph-pages&quot;&gt;创建一个ph-pages分支&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#section-8&quot; id=&quot;markdown-toc-section-8&quot;&gt;使其成为默认分支&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#indexhtml&quot; id=&quot;markdown-toc-indexhtml&quot;&gt;创建一个index.html&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#hello-world-1&quot; id=&quot;markdown-toc-hello-world-1&quot;&gt;Hello World&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#commit&quot; id=&quot;markdown-toc-commit&quot;&gt;commit文件&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#section-9&quot; id=&quot;markdown-toc-section-9&quot;&gt;查看你的项目站点&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;github-pages&quot;&gt;什么是GitHub Pages?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://pages.github.com/&quot; title=&quot;GitHub Pages&quot;&gt;Github Pages&lt;/a&gt;是GitHub推出的一个新的服务  &lt;br /&gt;
可以用来为你的&lt;a href=&quot;https://pages.github.com/&quot; title=&quot;GitHub 首页&quot;&gt;GitHub&lt;/a&gt;账户和你的每一个托管在&lt;a href=&quot;https://pages.github.com/&quot; title=&quot;GitHub 首页&quot;&gt;GitHub&lt;/a&gt;的项目建立一个web站点,show you and show your projects&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;两种站点服务&lt;/h3&gt;
&lt;p&gt;GitHub提供两种类型的站点服务:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;User or organization Site – 个人或组织站点&lt;/li&gt;
  &lt;li&gt;Project Site – 项目站点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每一个GitHub用户只可以创建一个个人站点，同时，你可以建立多个项目站点&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;好处不言而喻&lt;/h3&gt;
&lt;p&gt;建立个人或组织站点，让更多的人更好的认识你或你的组织  &lt;br /&gt;
建立项目站点，你可以可视化的展示你的每一个项目，而不是让你的partner(或者更多喜欢这个项目的人)看着一堆源代码而手足无措&lt;/p&gt;

&lt;p&gt;你可以很轻松建立一个网站(尽管它是static),有专门的主机托管，还可以通过git进行版本控制，那不是很酷吗？&lt;/p&gt;

&lt;p&gt;好了，该做出你的选择了…&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;建站开始&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;user-or-organization-site&quot;&gt;User or organization Site&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;githubrepository&quot;&gt;&lt;a href=&quot;https://github.com/new&quot; title=&quot;新建一个GitHub仓库&quot;&gt;创建一个仓库&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;从&lt;a href=&quot;https://pages.github.com/&quot; title=&quot;GitHub 首页&quot;&gt;GitHub&lt;/a&gt;开始，&lt;a href=&quot;https://github.com/new&quot; title=&quot;新建一个GitHub仓库&quot;&gt;创建&lt;/a&gt;一个名为&lt;strong&gt;username.github.io&lt;/strong&gt;的仓库  &lt;br /&gt;
其中,仓库名的第一部分&lt;em&gt;username&lt;/em&gt;是你在GitHub上的用户名(或组织名)  &lt;br /&gt;
假如&lt;em&gt;username&lt;/em&gt;和你的用户名不匹配，站点将不能工作，因此，请确保它正确  &lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/user-repo@2x.png&quot; alt=&quot;在GirHub上新建一个仓库&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;git&quot;&gt;选择你正在使用的git客户端&lt;/h4&gt;

&lt;p&gt;这里讲述三种客户端：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Terimal – 这种经常用在Unix或类Unix系统下(Linux,mac当然也可以)&lt;/li&gt;
  &lt;li&gt;GitHub for Windows – 一看就知道，这是windows下的客户端&lt;/li&gt;
  &lt;li&gt;GitHub for Mac – 这个是Mac下的客户端&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好了，开始咯&lt;/p&gt;

&lt;h5 id=&quot;terimal&quot;&gt;Terimal(终端)&lt;/h5&gt;

&lt;h6 id=&quot;section-3&quot;&gt;克隆刚创建的仓库&lt;/h6&gt;

&lt;p&gt;在terimal下转到你想存放你项目的地方，然后clone这个新的仓库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/username/username.github.io  
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;hello-world&quot;&gt;Hello World&lt;/h6&gt;

&lt;p&gt;进入项目目录，新建一个&lt;em&gt;index.html&lt;/em&gt;,如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd username.github.io
$ echo &quot;Hello World&quot; &amp;gt; index.html  
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;pushgithub&quot;&gt;push你的项目到github&lt;/h6&gt;

&lt;p&gt;添加，提交，推送你对项目做出的改变&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add --all
$ git commit -m &quot;Initial commit&quot;
$ git push
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h5 id=&quot;github-for-windows-or-mac&quot;&gt;GitHub for Windows or Mac&lt;/h5&gt;

&lt;h6 id=&quot;clone&quot;&gt;Clone仓库&lt;/h6&gt;

&lt;p&gt;点击绿色的”Set up in Desktop”按钮  &lt;br /&gt;
当GitHub桌面app打开，保存这个项目  &lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/setup-in-desktop@2x.png&quot; alt=&quot;从GitHub上启动桌面app&quot; /&gt;  &lt;br /&gt;
假如app没有启动，那么双击的桌面app启动它，并且在app里克隆你的项目&lt;/p&gt;

&lt;h6 id=&quot;createindexhtml&quot;&gt;Create一个index.html文件&lt;/h6&gt;

&lt;p&gt;使用你最喜欢的编辑器，新建index.html,内容如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;I'm hosted with GitHub Pages.&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，添加到你的项目&lt;/p&gt;

&lt;h6 id=&quot;commit--sync&quot;&gt;commit &amp;amp;&amp;amp; Sync&lt;/h6&gt;

&lt;p&gt;进入你的仓库(app里),commit你的变化，然后按下sync(同步)按钮  &lt;br /&gt;
假如你在Windows下：  &lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/sync-windows@2x.png&quot; alt=&quot;windows提交并同步变化到项目&quot; /&gt;  &lt;br /&gt;
假如你在Mac下：  &lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/sync-mac.png&quot; alt=&quot;Mac提交并同步变化到项目&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-4&quot;&gt;未知区域&lt;/h5&gt;

&lt;p&gt;假如你不知道你的平台，额，我无能为力了&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;浏览你的网站吧&lt;/h4&gt;

&lt;p&gt;启动你的浏览器，输入&lt;em&gt;http://username.github.io&lt;/em&gt;,然后，回车，接着，404，哈哈  &lt;br /&gt;
等一下吧，新生成一个网站需要一段时间滴  &lt;br /&gt;
时间也不是很长，大概10分钟吧  &lt;br /&gt;
未来可能会做的更好，期待吧&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;project-site&quot;&gt;project Site&lt;/h3&gt;

&lt;p&gt;创建项目站点，有两种办法&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Generate a Site&lt;/li&gt;
  &lt;li&gt;Start from scratch&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实际上两者创建了分支gh-pages，只是第一种办法是在当前项目的主分支的当前状态开辟新的分支；第二种则是开辟一个没有父节点的分支  &lt;br /&gt;
说的简单点，第一种的gh-pages分支有当前项目的主分支的内容,所以被称为&lt;em&gt;半路出家&lt;/em&gt;；而第二种则没有当前项目主分支的内容，完全像一个新的仓库,所以被称为&lt;em&gt;白手起家&lt;/em&gt;(Start from scratch)&lt;/p&gt;

&lt;h4 id=&quot;generate-a-site&quot;&gt;半路出家(Generate a Site)&lt;/h4&gt;

&lt;h5 id=&quot;repository-settings&quot;&gt;Repository Settings&lt;/h5&gt;

&lt;p&gt;访问&lt;a href=&quot;https://pages.github.com/&quot; title=&quot;GitHub 首页&quot;&gt;GirHub,com&lt;/a&gt;,创建一个新的仓库或者进入一个已存在的仓库  &lt;br /&gt;
然后点击右手边的&lt;em&gt;Settings&lt;/em&gt;,进入项目设置页面  &lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/settings@2x.png&quot; alt=&quot;Repository settings&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;automatic-generator&quot;&gt;使用Automatic Generator&lt;/h5&gt;

&lt;p&gt;滑动settings页面到&lt;em&gt;GitHub Pages&lt;/em&gt;模块  &lt;br /&gt;
按下&lt;em&gt;Automatic Page Generator&lt;/em&gt;按钮  &lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/automatic@2x.png&quot; alt=&quot;Automatic Pages Generator&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-6&quot;&gt;添加内容&lt;/h5&gt;

&lt;p&gt;使用内置编辑器添加内容给你的网站  &lt;br /&gt;
假如你已经有了&lt;em&gt;README.md&lt;/em&gt;在你的项目，你可以点击右手边&lt;em&gt;Load README.md&lt;/em&gt;进行导入  &lt;br /&gt;
当你做完这些，点击&lt;em&gt;Continue to Layouts&lt;/em&gt;  &lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/add-content@2x.png&quot; alt=&quot;add content to your project site&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-7&quot;&gt;选择一个主题&lt;/h5&gt;

&lt;p&gt;在顶部的提供主题里，选择一个你喜欢的主题  &lt;br /&gt;
当你完成，点击右手边的&lt;em&gt;Publish page&lt;/em&gt;按钮  &lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/choose-layout@2x.png&quot; alt=&quot;choose a theme&quot; /&gt;&lt;/p&gt;

&lt;p&gt;半路出家搞定&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;start-from-scratch&quot;&gt;白手起家(Start from scratch)&lt;/h4&gt;

&lt;h5 id=&quot;ph-pages&quot;&gt;创建一个ph-pages分支&lt;/h5&gt;

&lt;p&gt;在你的项目页面，点击左手边分支下拉菜单，输入&lt;code&gt;gh-pages&lt;/code&gt;,然后按下enter进行创建  &lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/create-branch@2x.png&quot; alt=&quot;create gh-pages branch&quot; /&gt;  &lt;br /&gt;
这个分支用于发布你的项目站点，你可以随时添加项目的进度等&lt;/p&gt;

&lt;h5 id=&quot;section-8&quot;&gt;使其成为默认分支&lt;/h5&gt;

&lt;p&gt;假如你已经为你的项目创建了新分支&lt;em&gt;gh-pages&lt;/em&gt;  &lt;br /&gt;
进入仓库设置界面  &lt;br /&gt;
在顶部的模块，改变默认分支为&lt;em&gt;gh-pages&lt;/em&gt;  &lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/default-branch@2x.png&quot; alt=&quot;change default branch&quot; /&gt;  &lt;br /&gt;
这一步并不是必须的，因为此步的意义只是让其看起来更像一个web site project&lt;/p&gt;

&lt;h5 id=&quot;indexhtml&quot;&gt;创建一个index.html&lt;/h5&gt;

&lt;p&gt;返回仓库总览界面，点击紧邻仓库名旁边的plus图标创建一个名为index.html的文件    &lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/create-file@2x.png&quot; alt=&quot;create file&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;hello-world-1&quot;&gt;Hello World&lt;/h5&gt;

&lt;p&gt;为这个index.html文件添加内容&lt;em&gt;Hello world&lt;/em&gt;  &lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/hello-world@2x.png&quot; alt=&quot;hello-world&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;commit&quot;&gt;commit文件&lt;/h5&gt;

&lt;p&gt;滑动到页面底部，写上提交信息，提交这个新文件  &lt;br /&gt;
&lt;img src=&quot;https://pages.github.com/images/commit-web@2x.png&quot; alt=&quot;commit-web&quot; /&gt;  &lt;br /&gt;
呼，打完收工&lt;/p&gt;

&lt;p&gt;对咯，这种办法创建项目站点完全可以在Terimal,GitHub for Windows,还有GitHub for Mac下进行，请自行探索吧&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;查看你的项目站点&lt;/h4&gt;

&lt;p&gt;领年终奖了  &lt;br /&gt;
启动你的浏览器，输入&lt;em&gt;http://username.github.io/repository&lt;/em&gt;  &lt;br /&gt;
&lt;em&gt;Repository&lt;/em&gt;是你的项目仓库名  &lt;br /&gt;
然后，回车，接着，404，额，又被坑了  &lt;br /&gt;
等10分钟吧，这么简单创建一个web站点，也不差这点时间对吧?&lt;/p&gt;

</content>
 </entry>
 
 
</feed>
