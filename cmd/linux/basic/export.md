# export

export 命令用于将 shell 变量输出为环境变量或将函数输出为环境变量

一般的变量值在当前进程中有效  
而环境变量为设置环境变量的进程以及子进程所熟知  

这里为了区分 export 输出的函数和变量,做了如下声明 : 
* 把 export 输出的变量称为环境变量
* 把 export 输出的函数称为环境函数  


## 使用

1. 指定环境变量 :  `hello="hello"; export hello`
2. 移除环境变量 :  `export -n hello`  
3. 查看当前所有的环境变量 : `export -p` 或 `export`
4. 指定环境函数 : `nihao() { echo "hello";} ; export -f nihao`
5. 移除环境函数 : `export -fn nihao`
6. 查看当前所有的环境函数 : `export -f`

## 参数  

* `-f [function_name]` --  输出环境函数或指定函数为环境函数
* `-n [var_name]` -- 从环境变量列表中移除指定环境变量(没有删除变量，删除变量请用 `unset`)
* `-p ` -- 列出所有的环境变量(默认)

## 变量的继承  

1. 执行脚本时是在一个子 shell 环境运行的，脚本执行完后该子 shell 自动退出  

2. 一个 shell 中的环境变量(export 输出的变量)会被复制到子 shell 中

3. 一个 shell 中的环境变量只对该 shell 以及它的子 shell 有效，该 shell 结束时变量消失(并不能返还到父 shell 中)  

4. 不用 export 定义的变量只对该 shell 有效，对子 shell 也是无效的  

5. 直接执行一个脚本文件是在一个子 shell 环境中运行的，而 source 则是在当前环境中运行的  
   因此, source 运行一个脚本 export 变量会被其及其子shell获知 

### 与进程的关系 

如果你学过进程的话，会发现在 环境变量的这种继承特性和 fork 之后的子进程和父进程的环境继承很类似 :

1. 子进程拥有父进程 fork 之前的所有变量  
2. 但是在子进程中新定义的变量却不能被父进程访问
3. 子进程继承父进程的变量已经脱离父进程，即改变任意一个也不会影响另一个的值


这里我们只说到环境变量在进程中的体现 , 但是没有提到 shell 中的普通变量  
事实上，shell 中的普通变量是一个伪变量,即只能被当前脚本所使用,除非 export 输出此变量  
(这点我也没有证实，只是某个地方看到而已，有待商榷(shangque))


